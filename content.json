{"meta":{"title":"栈点","subtitle":"不念过去，不畏将来","description":"一个想好好学习的小学生","author":"ycwang","url":"yongchunxiaofen.top"},"pages":[],"posts":[{"title":"Python学习","slug":"python-learning","date":"2016-11-03T08:13:20.000Z","updated":"2016-11-16T02:04:28.000Z","comments":true,"path":"2016/11/03/python-learning/","link":"","permalink":"yongchunxiaofen.top/2016/11/03/python-learning/","excerpt":"字符串字符串方法 find()方法 join()方法:join方法与split()方法相逆，用来在队列中添加元素。 12345seq=['1','2','3','4','5']sep='+'sep.join(seq)#-----output:-------1+5+5+7 lower():返回字符串中的小写字母版 replace():返回某字符串的所有匹配项均被替换之后的字符串 123print 'This is a string'.replace('is','ezz')#------output:------Thezz ezz a string split()方法：join逆方法。将字符串分隔成序列 123print '1+2+3+4+5'.split('+')#-------output:-----------['1', '2', '3', '4', '5'] strip()方法：返回去除掉两侧空格的字符串 123print ' International '.strip()#-------output:------------International","text":"字符串字符串方法 find()方法 join()方法:join方法与split()方法相逆，用来在队列中添加元素。 12345seq=['1','2','3','4','5']sep='+'sep.join(seq)#-----output:-------1+5+5+7 lower():返回字符串中的小写字母版 replace():返回某字符串的所有匹配项均被替换之后的字符串 123print 'This is a string'.replace('is','ezz')#------output:------Thezz ezz a string split()方法：join逆方法。将字符串分隔成序列 123print '1+2+3+4+5'.split('+')#-------output:-----------['1', '2', '3', '4', '5'] strip()方法：返回去除掉两侧空格的字符串 123print ' International '.strip()#-------output:------------International ​ 字典创建字典字典可以通过一下方式创建： ​ phonebook={&#39;Alice&#39;:&#39;2341&#39;,&#39;Beth&#39;:&#39;9102&#39;,&#39;Cecil&#39;:&#39;3258&#39;} dict函数dict函数可以通过其他映射或者这样的序列建立字典。 12345678items=&#123;('Ruby','56'),('python','89')&#125;ite = dict(items)print iteprint ite['Ruby']#--------output:----------&#123;'python': '89', 'Ruby': '56'&#125;56 dict也可以直接创建字典，例如 123456d = dict(Ruby='56',python='89')print dprint d['Ruby']#---output:----&#123;'python': '89', 'Ruby': '56'&#125;56 字典方法 clear():清楚字典中的所有项。 copy()方法： 1234567x=&#123;'username':'admin','machines':['foo','bar','baz']&#125;y=x.copy()y['username']='wyc'y['machines'].remove('foo')print y#--------output:-------&#123;'username': 'wyc', 'machines': ['bar', 'baz']&#125; fromkeys():用给定的键建立新的字典，每个键值对应的值为None 123print &#123;&#125;.fromkeys(['name','age'])#------output:-----------&#123;'age': None, 'name': None&#125; get()方法：一般来说，访问字典中不存在的键值时会报错，而使用get(‘key’)时，如果不存在会返回一个None 循环循环中的一些迭代方法 并行迭代：zip(seq1,seq2)函数 123456789101112names=['anne','jane','geogre','damon']ages=[12,34,32,102]print zip(names,ages)for name,age in zip(names,ages): print name,'is',age,'years old!' # ----------output:--------------[('anne', 12), ('jane', 34), ('geogre', 32), ('damon', 102)]anne is 12 years old!jane is 34 years old!geogre is 32 years old!damon is 102 years old! 异常一些常见的内建异常 12345678910Exception #所有异常的基类AttributeError #特性引用或赋值失败时引发IOError #试图打开不存在的文件是引发IndexError #使用序列中不存在的索引时引发KeyError #使用映射中不存在的键时引发NameError #找不到名字（变量）时引发SyntaxError #在代码为错误形式时引发TypeError #内建操作或者函数应当用于错误类型的对象时引发ValueError #在内建操作或者函数应用于正确类型的对象，但是该对象使用不合适的值时引发ZeroDivisionError #除法或者模除操作的第二个参数为0时引发 捕获异常时访问异常对象本身 如果希望在except子句中访问异常对象本身，可以使用两个参数。比如，如果想让程序继续运行，又因为某种原因想记录下错误，如下功能就很有用。如下的示例程序会打印异常，但是程序会继续运行。 1234567try: x = input(\"Enter the first number: \") y = input(\"Enter the second number: \") print x/yexcept(ZeroDivisionError,TypeError),e: print e Finally子句Finally子句用来在可能的异常后进行清理工作。它和try子句联合使用： 123456x = Nonetry: x = 1/0finally: print 'cleaning up!' del x 必须要说明的是，在一个try语句中，不能同时使用except和finally子句——但是一个子句可以放在另一个子句中。 类和类型类特性的私有化​ Python并不直接支持私有方式，但是可以使用一些小技巧达到私有化的效果。 为了让方法或者特性变为私有（从类的外部无法访问），只要在它的名字前面加上双下划线即可； 尽管如此，在类的外部还是可以通过某种方法来访问这些类的私有方法的，尽管不这么做。。。 12345678910111213141516171819print '\\n-----------类的成员函数私有化------------'class Private: def __inAccessible(self): print \"This function can't used out class\" def Accessible(self): print \"This function can used out class\" self.__inAccessible()obj = Private()obj.Accessible()obj._Private__inAccessible() #类外部访问私有方法：类名前为单下划线，而私有方法前为双下划线print '\\n-----------类的成员函数私有化end------------'#----------output:--------------This function can used out classThis function can't used out classThis function can't used out class 魔法方法、属性和迭代器 Python中，有的名称会在前后都加两个下划线，这种写法很特别。这些名字组成的集合所包含的方法称为魔法方法。 123# 为了保证类是新型的，应该把赋值语句__metaclass__ = type#放在模块的最开始 构造方法构造方法与其他普通方法的不同之处在于，当创建一个对象时，构造方法会被立即调用。 123456789class FooBar: def __init__(self): self.name=52f=FooBar()print f.name#---------output:-------------52 super()函数考虑有如下的类： 12345678910111213141516171819202122232425262728293031class Bird: def __init__(self): self.hungry = True def eat(self): if self.hungry: print 'add food' self.hungry = False #进食完成，不饿 else: print 'No,Thanks!' class SongBird(Bird): def __init__(self): self.sound = 'Squawk' def sing(self): print self.sound#调用子类的sing()方法很容易sb = SongBird()sb.sing() #尝试调用父类的eat()方法sb.eat()#--------output:-------------SquawkTraceback (most recent call last): File \"E:\\Eclipse+PyDev\\eclipse-jee-mars\\spider\\demo\\magic.py\", line 54, in &lt;module&gt; sb.eat() File \"E:\\Eclipse+PyDev\\eclipse-jee-mars\\spider\\demo\\magic.py\", line 37, in eat if self.hungry:AttributeError: 'SongBird' object has no attribute 'hungry' SongBird类中没有hungry特性。 原因是：子类在构造时，构造方法被重写，新的构造方法并未对父类的构造方法进行初始化。 可以采用super()函数解决这种问题：super()函数的位置在子类构造函数的第一行。如下程序所示： 123456789101112131415161718192021222324252627class Bird: def __init__(self): self.hungry = True def eat(self): if self.hungry: print 'add food' self.hungry = False #进食完成，不饿 else: print 'No,Thanks!' class SongBird(Bird): def __init__(self): super(SongBird,self).__init__() #使用super函数，两个参数分别为子类的类名和self self.sound = 'Squawk' def sing(self): print self.sound#调用子类的sing()方法很容易sb = SongBird()sb.sing() #尝试调用父类的eat()方法sb.eat()#--------output:---------Squawkadd food 模块探究不可能介绍所有的模块，当见到一个新的模块(module)时，要学会自己分析它。 使用模块之前，首先得导入模块：假设有一个模块copy 1import copy 导入时没有报告异常，说明该包存在且可用。 dir使用dir函数可以查看模块中包含的内容，它会将对象的所有特性列出。 运行 123456print dir(copy)#打印出所有copy的特性#-------output:-----------['Error', 'PyStringMap', '_EmptyClass', '__all__', '__builtins__', '__doc__', '__file__', '__name__', '__package__', '_copy_dispatch', '_copy_immutable', '_copy_inst', '_copy_with_constructor', '_copy_with_copy_method', '_deepcopy_atomic', '_deepcopy_dict', '_deepcopy_dispatch', '_deepcopy_inst', '_deepcopy_list', '_deepcopy_method', '_deepcopy_tuple', '_keep_alive', '_reconstruct', '_test', 'copy', 'deepcopy', 'dispatch_table', 'error', 'name', 't', 'weakref'] ​ 其中一些名字以下划线结束——暗示其并不是为在模块外部使用而准备的。这儿用列表推倒式过滤掉这样的特性： 1234print [n for n in dir(copy) if not n.startswith('_')]#------output：--------------['Error', 'PyStringMap', 'copy', 'deepcopy', 'dispatch_table', 'error', 'name', 't', 'weakref'] __all__变量在完整的dir(copy)列表中，有一个__all__变量名字。该变量包含一个列表，列表与之前推导过的列表比较类似： 123print copy.__all__#----------output:-----------['Error', 'copy', 'deepcopy'] ​ __all__对应的列表定义了模块的公有接口。更准确的说，如果使用以下代码：from copy import * ，那么，只能以这种方式导入__all__列表中的四个属性。 如果要导入PyStringMap的话，就得显示地实现，或者导入copy然后使用copy.PyStringMap，或者使用from copy import PyStringMap的方式导入。 ### 用help获取帮助 help能够对导入的包使用提供帮助。 1234567891011print help(copy.copy)#------output：----------Help on function copy in module copy:copy(x) Shallow copy operation on arbitrary Python objects. See the module's __doc__ string for more info.None 从帮助信息可知，copy带有一个参数x，是浅复制操作。提到了模块的__doc__字符串。事实上，帮助文档就是从文档字符串中取出来的。 12345print copy.copy.__doc__#--------output：--------------Shallow copy operation on arbitrary Python objects. See the module's __doc__ string for more info. 文档例如需要知道range函数的参数时什么，则只需要这样： 12345678print range.__doc__#------output:--------range([start,] stop[, step]) -&gt; list of integersReturn a list containing an arithmetic progression of integers.range(i, j) returns [i, i+1, i+2, ..., j-1]; start (!) defaults to 0.When step is given, it specifies the increment (or decrement). 查看和使用源代码如果想要知道某个函数的源代码，则需要调用__file__属性即可调出源代码的路径。 123print copy.__file__#-------output:-----------C:\\Python27\\lib\\copy.pyc","categories":[{"name":"python","slug":"python","permalink":"yongchunxiaofen.top/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"yongchunxiaofen.top/tags/python/"}]},{"title":"Python-列表和元组","slug":"Python-sequence","date":"2016-10-25T07:46:16.000Z","updated":"2016-10-25T08:06:07.000Z","comments":true,"path":"2016/10/25/Python-sequence/","link":"","permalink":"yongchunxiaofen.top/2016/10/25/Python-sequence/","excerpt":"两者最主要的区别： 列表可以修改 元组不可以修改 序列中的元素可以是数字，可以是字符串，甚至可以是另一个序列。 例如： 123456789101112edwad = ['Edward', 42]john = ['John Smith', 50]database = [edwad, john]print database[0]print database[1]print database//运行以上代码，打印如下内容['Edward', 42]['John Smith', 50][['Edward', 42], ['John Smith', 50]] 通用序列操作索引，分片，加、乘、检查某个元素是否属于序列成员。","text":"两者最主要的区别： 列表可以修改 元组不可以修改 序列中的元素可以是数字，可以是字符串，甚至可以是另一个序列。 例如： 123456789101112edwad = ['Edward', 42]john = ['John Smith', 50]database = [edwad, john]print database[0]print database[1]print database//运行以上代码，打印如下内容['Edward', 42]['John Smith', 50][['Edward', 42], ['John Smith', 50]] 通用序列操作索引，分片，加、乘、检查某个元素是否属于序列成员。 除此之外，还可以计算序列长度、找出最大最小的元素。 索引：索引序号0指向第一个序列中的元素，而使用负数索引时，Python会从最后一个元素开始计数。最后一个元素的索引值是-1. 12345678910print '中文测试'fourth = raw_input('Year: ')[3]print fourth//执行上述代码输出如下内容Input： Year: 2005Output： 5 分片：分片操作访问一定范围内的元素。分片通过冒号分隔的两个索引来实现。例如： 12345tag = '&lt;a href=\"http://www.python.org\"&gt;Python Web Site &lt;/a&gt;'print tag[9:30]//执行代码输出以下内容http://www.python.org ​ 需要注意的是索引被冒号分隔的两个索引，符合左闭右开原则，即分号左边对应的元素被包含，而分号右边对应的元素不被包含。 123456789101112131415numbers = [1,2,3,4,5,6,7,8,9,10]#如果要访问序列中最后三个元素时，可以使用以下方法print numbers[-3:]#程序输出为：[8,9,10]#同样适用于序列开始的元素print numbers[:3]//Output:[1,2,3]#打印整个序列print numbers[:][1,2,3,4,5,6,7,8,9,10] ​ 步长增大的情况： ​ 普通的分片情况中，步长被设置为1.同理，步长也可以设置为其他比1大的数。 123456numbers = [1,2,3,4,5,6,7,8,9,10]print numbers[0:10:1] # 步长为1#[1,2,3,4,5,6,7,8,9,10]print numbers[0:10:2] # 步长为2#[1, 3, 5, 7, 9] 序列相加：两种相同类型的序列才能进行连接操作。_引自Python基础教程（第二版） 12345678910111213print [1,2,3]+[4,5,6]print [1,2,3]+4#[1, 2, 3, 4, 5, 6]#Traceback (most recent call last):# File \"E:\\Eclipse+PyDev\\eclipse-jee-#mars\\spider\\demo\\__init__.py\", line 19, in #&lt;module&gt;# print [1,2,3]+4#TypeError: can only concatenate list (not #\"int\") to list#提示只有序列才可以和序列相加#——————————————博主注————————————————————print [1,2,3]+['world']输出：[1, 2, 3, 'world'] 上述代码中最后一个例子是int数列和一个字符串序列相加，结果可以顺利输出connect之后的结果，因此，《Python基础教程（第二版）》中的“两种相同类型的序列才能进行连接操作”该句存疑。 乘法：一个数字乘以一个序列会生成一个新的序列。 123sequence = [None]*10print sequence#输出：[None, None, None, None, None, None, None, None, None, None] 成员资格检查：使用in运算符，如果被检查的元素存在序列中，返回一个bool运算符True，否则返回False 1234567891011permissions = 'rwct'print 'w' in permissionscolors = ['blue','yellow','brown','red','black']print 'blue' in colorsprint 'white' in colors#输出结果为：#True#True#False 长度、最小最大值：对应len,min,max函数。 123456789numbers = [100,2,56]print '长度为：' ,len(numbers)print '最小值为：',min(numbers)print '最大值为：',max(numbers)# -------------输出为：-----------------------长度为： 3最小值为： 2最大值为： 100 列表list函数将字符串转换为列表 1234print list('python')#-------------输出：-------------['p', 'y', 't', 'h', 'o', 'n'] list函数适用于所有类型的序列，而不只是字符串。 列表方法 调用方法一般为：对象.方法(参数) append():用于在列表末尾追加新的对象 count()方法：统计某个元素在列表中出现的次数。 extend():在列表的末尾一次性追加一个序列中的多个值。即用一个列表扩展原有列表。 index(): 1234567891011121314seq = ['I','am','a','teacher','a']seq1 = ['You','are','a','student'] print seqseq.append('student')print seqprint seq.count('a')seq.extend(seq1)print seq#-------输出：-----------['I', 'am', 'a', 'teacher', 'a']['I', 'am', 'a', 'teacher', 'a', 'student']2['I', 'am', 'a', 'teacher', 'a', 'student', 'You', 'are', 'a', 'student'] insert()方法：序列.insert(index, object) 12345numbers = [1,2,3,5,5]numbers.insert(3,'four')print numbers#--------------output:-----------[1, 2, 3, 'four', 5, 5] pop()方法：移除列表中的一个元素（默认是最后一个），且返回该元素的值。 remove()方法：用于移除列表中某个值的第一个匹配项。 reverse()方法：反转序列 1234567891011x=['to','be','or','not','to','be']print xx.remove('be')print xx.reverse()print x#-----output:---------------['to', 'be', 'or', 'not', 'to', 'be']['to', 'or', 'not', 'to', 'be']['be', 'to', 'not', 'or', 'to'] sort()方法：在原位置对列表进行排序 123456num=[5,3,5,72,1,4]num.sort()print num#-----------output:---------[1, 3, 4, 5, 5, 72] 高级排序： compare(x,y)函数:x&gt;y,返回正数，x&lt;y返回负数，相等返回0. sort()函数的参数可选参数：cmp，key和reverse。 12345 x=['aardvar','abalone','came','add','aerate']x.sort(key=len) #以长度len为关键词进行排序print x#---------output：-----------['add', 'came', 'aerate', 'aardvar', 'abalone'] 123456num=[5,3,5,72,1,4]num.sort(reverse=True) #排序且反转print num#-------output:---------[72, 5, 5, 4, 3, 1]","categories":[{"name":"python","slug":"python","permalink":"yongchunxiaofen.top/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"yongchunxiaofen.top/tags/python/"}]},{"title":"python爬虫实战","slug":"python-spider-00","date":"2016-10-15T02:46:11.000Z","updated":"2016-10-15T03:27:16.000Z","comments":true,"path":"2016/10/15/python-spider-00/","link":"","permalink":"yongchunxiaofen.top/2016/10/15/python-spider-00/","excerpt":"","text":"爬虫分析过程 待爬取目标分析 目标：百度百科python词条的相关此条网页——标题及简介 入口页：http://baidu.baidu.com/view/21087.htm URL格式： 词条页面URL：/view/125370.htm 数据格式： 标题： 1&lt;dd class=\"lemmaWgt-lemmaTitle-title\"&gt;&lt;h1&gt;***&lt;/h1&gt;&lt;/dd&gt; 简介： 1&lt;div class=\"lemma-summary\"&gt;***&lt;div&gt; 页面编码：UTF-8 实例代码","categories":[{"name":"python","slug":"python","permalink":"yongchunxiaofen.top/categories/python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"yongchunxiaofen.top/tags/爬虫/"},{"name":"python","slug":"python","permalink":"yongchunxiaofen.top/tags/python/"}]},{"title":"Beautiful Soup常用语法","slug":"Beautiful-soup","date":"2016-10-14T07:37:14.000Z","updated":"2016-10-14T12:53:41.000Z","comments":true,"path":"2016/10/14/Beautiful-soup/","link":"","permalink":"yongchunxiaofen.top/2016/10/14/Beautiful-soup/","excerpt":"Beautiful Soup简介 Beautiful Soup是一个可以从HTML或XML文件中提取数据的Python库。它能够通过你喜欢的转换器实现惯用的文档导航，查找，修改文档的方式。Beautiful Soup会帮你节省数小时甚至数天的工作时间。 快速开始下面的一段HTML代码将作为例子被多次用到.这是爱丽丝梦游仙境的的一段内容(以后内容中简称为 爱丽丝 的文档): 12345678910111213html_doc = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;Elsie&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\" 几个简单的浏览结构化数据的方法12345678910111213141516171819202122232425262728soup.title# &lt;title&gt; The Dormouse's story &lt;/title&gt;soup.title.name# u'title'soup.title.string# u'The Dormouse's story'soup.title.parent.name# u'head'soup.p# &lt;p class=\"tltle\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;soup.p['class']# u'title'soup.a# &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;soup.find_all('a')# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;]soup.find(id=\"link3\")# &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;","text":"Beautiful Soup简介 Beautiful Soup是一个可以从HTML或XML文件中提取数据的Python库。它能够通过你喜欢的转换器实现惯用的文档导航，查找，修改文档的方式。Beautiful Soup会帮你节省数小时甚至数天的工作时间。 快速开始下面的一段HTML代码将作为例子被多次用到.这是爱丽丝梦游仙境的的一段内容(以后内容中简称为 爱丽丝 的文档): 12345678910111213html_doc = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"title\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;Elsie&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\" 几个简单的浏览结构化数据的方法12345678910111213141516171819202122232425262728soup.title# &lt;title&gt; The Dormouse's story &lt;/title&gt;soup.title.name# u'title'soup.title.string# u'The Dormouse's story'soup.title.parent.name# u'head'soup.p# &lt;p class=\"tltle\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;soup.p['class']# u'title'soup.a# &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;soup.find_all('a')# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;]soup.find(id=\"link3\")# &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt; 从文档中找到所有标签的连接： 12345for link in soup.find_all('a'): print link.get('href') # http://example.com/elsie # http://example.com/lacie # http://example.com/tillie 从文档中获取所有文字内容 123456789101112print soup.get_text()# The Dormouse's story## The Dormouse's story## Once upon a time there were three little sisters; and their names were# Elsie,# Lacie and# Tillie;# and they lived at the bottom of a well.## ... 网页解析器比较 解析器 使用方法 优势 劣势 Python标准库 BeautifulSoup(markup, “html.parser”) - Python的内置标准库 - 执行速度适中 - 文档容错能力强 - Python 2.7.3 or 3.2.2前的版本中文文档容错能力差 lxml HTML解析器 BeautifulSoup(markup, “lxml”) 速度快 文档容错能力强 - 需要安装C语言库 lxml HTML解析器 BeautifulSoup(markup,[“lxml-xml”]) 速度快 唯一支持XML的解析器 - 需要安装C语言库 html5lib BeautifulSoup(markup,”html5lib”) - 最好的容错性 - 以浏览器的方式解析文档 - 生成HTML5格式的文档 - 速度慢 -不依赖外部扩展 使用入门12345from bs4 import BeautifulSoupsoup = BeautifulSoup(open(\"index.html\"))soup = BeautifulSoup(\"&lt;html&gt;data&lt;/html&gt;\") 对象的种类BeautifulSoup将复杂的HTML文档转换成一个复杂的树形结构，每个结点都是Python对象，所有对象都可以归为4种： Tag NavigableString BeautifulSoup Comment TagTag对象与XML或HTML原生文档中的tag相同： 1234soup = BeautifulSoup('&lt;b class=\"boldest\"&gt;Extremely bold&lt;/b&gt;')tag = soup.btype(tag)# &lt;class 'bs4.element.Tag'&gt; Tag中最重要的两个属性：name和attributes name每个tag都有自己的名字，通过.name来获取： 12tag.name# u'b' 如果改变了tag的name,那将影响所有通过当前Beautiful Soup对象生成的HTML文档: 123tag.name = \"blockquote\"tag# &lt;blockquote class=\"boldest\"&gt;Extremely bold&lt;/blockquote&gt; Attributes一个tag可能有很多个属性. tag `` 有一个 “class” 的属性,值为 “boldest” . tag的属性的操作方法与字典相同: 12tag['class']# u'boldest' 也可以直接”点”取属性, 比如: .attrs : 12tag.attrs# &#123;u'class': u'boldest'&#125; 123456789101112131415161718tag.attrs# &#123;u'class': u'boldest'&#125;tag['class'] = 'verybold'tag['id'] = 1tag# &lt;blockquote class=\"verybold\" id=\"1\"&gt;Extremely bold&lt;/blockquote&gt;del tag['class']del tag['id']tag# &lt;blockquote&gt;Extremely bold&lt;/blockquote&gt;tag['class']# KeyError: 'class'print(tag.get('class'))# None NavigableStringBeautiful Soup用 NavigableString 类来包装tag中的字符串: 123456tag.string# u'Extremely bold'# 检查一下其类型type(tag.string)# &lt;class 'bs4.element.NavigableString'&gt; BeautifulSoupBeautifulSoup 对象并不是真正的HTML或XML的tag,所以它没有name和attribute属性.但有时查看它的 .name 属性是很方便的,所以 BeautifulSoup 对象包含了一个值为 “[document]” 的特殊属性 .name 12soup.name# u'[document]' Comment 注释12345markup = \"&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;/b&gt;\"soup = BeautifulSoup(markup)comment = soup.b.stringtype(comment)# &lt;class 'bs4.element.Comment'&gt; 遍历文档树123456789101112131415161718html_doc = \"\"\"&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;p class=\"title\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;Elsie&lt;/a&gt;,&lt;a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"&gt;Lacie&lt;/a&gt; and&lt;a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=\"story\"&gt;...&lt;/p&gt;\"\"\"# 导入bs4模块from bs4 import BeautifulSoup# 以html.parser方式遍历文档html_docsoup = BeautifulSoup(html_doc, 'html.parser') .contents 和 .childrentag的 .contents 属性可以将tag的子节点以列表的方式输出: 1234567891011121314head_tag = soup.headhead_tag# &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;head_tag.contents[&lt;title&gt;The Dormouse's story&lt;/title&gt;] # 索引形式获取title_tag = head_tag.contents[0]title_tag# &lt;title&gt;The Dormouse's story&lt;/title&gt; title_tag.contents# [u'The Dormouse's story'] 通过tag的 .children 生成器,可以对tag的子节点进行循环: 123for child in title_tag.children: print child # The Dormouse's story 所有子孙节点：.descendants.contents 和 .children 属性仅包含tag的直接子节点，.descendants 属性可以对所有tag的子孙节点进行递归循环，和 children类似，我们也需要遍历获取其中的内容。 1234for child in head_tag.descendants: print child # &lt;title&gt;The Dormouse's story&lt;/title&gt; # The Dormouse's story 上面的例子中, 标签只有一个子节点,但是有2个子孙节点:节点和的子节点, BeautifulSoup 有一个直接子节点(节点),却有很多子孙节点: 1234len(list(soup.children))# 1len(list(soup.descendants))# 25 父节点.parent通过 .parent 属性来获取某个元素的父节点.在例子“爱丽丝”的文档中,标签是标签的父节点: 12345title_tag = soup.titletitle_tag# &lt;title&gt;The Dormouse's story&lt;/title&gt;title_tag.parent# &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt; .parents通过元素的 .parents 属性可以递归得到元素的所有父辈节点,下面的例子使用了.parents 方法遍历了标签到根节点的所有节点. 12345678910111213link = soup.alink# &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;for parent in link.parents: if parent is None: print parent else: print parent.name # p# body# html# [document]# None 兄弟节点.next_sibling 和 .previous_sibling在文档树中,使用 .next_sibling 和 .previous_sibling 属性来查询兄弟节点: 12345sibling_soup.b.next_sibling# &lt;c&gt;text2&lt;/c&gt;sibling_soup.c.previous_sibling# &lt;b&gt;text1&lt;/b&gt; 搜索文档树 find() find_all() 过滤器字符串最简单的过滤器是字符串.在搜索方法中传入一个字符串参数,Beautiful Soup会查找与字符串完整匹配的内容,下面的例子用于查找文档中所有的标签: 12soup.find_all('b')# [&lt;b&gt;The Dormouse's story&lt;/b&gt;] 正则表达式如果传入正则表达式作为参数,Beautiful Soup会通过正则表达式的 match() 来匹配内容.下面例子中找出所有以b开头的标签,这表示和标签都应该被找到: 12345import refor tag in soup.find_all(re.compile(\"^b\")): print tag.name # body# b 下面代码找出所有名字中包含”t”的标签: 1234for tag in soup.find_all(re.compile(\"t\")): print(tag.name)# html# title 列表如果传入列表参数,Beautiful Soup会将与列表中任一元素匹配的内容返回.下面代码找到文档中所有标签和标签: 12345soup.find_all([\"a\", \"b\"]) # 列表的形式搜索# [&lt;b&gt;The Dormouse's story&lt;/b&gt;,# &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;] TrueTrue 可以匹配任何值,下面代码查找到所有的tag,但是不会返回字符串节点 12345678910111213for tag in soup.find_all(True): print tag.name # html# head# title# body# p# b# p# a# a# a# p 方法该文档暂不介绍。 find_all()find_all( name , attrs , recursive , string , **kwargs ) find_all() 方法搜索当前tag的所有tag子节点,并判断是否符合过滤器的条件.这里有几个例子: 1234567891011121314151617181920212223# 搜索namesoup.find_all(\"title\")# [&lt;title&gt;The Dormouse's story&lt;/title&gt;]# 搜索name 和属性soup.find_all(\"p\", \"title\")# [&lt;p class=\"title\"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;]# 搜索namesoup.find_all(\"a\")# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;]# 如果一个指定名字的参数不是搜索内置的参数名,搜索时会把该参数当作指定名字 tag 的属性来搜索# 如果包含一个名字为 id 的参数,Beautiful Soup会搜索每个tag的”id”属性soup.find_all(id=\"link2\")# [&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;]# 正则匹配import resoup.find(string=re.compile(\"sisters\"))# u'Once upon a time there were three little sisters; and their names were\\n' name 参数name 参数可以查找所有名字为 name 的tag,字符串对象会被自动忽略掉. 12soup.find_all(\"title\")# [&lt;title&gt;The Dormouse's story&lt;/title&gt;] keyword 参数如果一个指定名字的参数不是搜索内置的参数名,搜索时会把该参数当作指定名字tag的属性来搜索,如果包含一个名字为 id 的参数,Beautiful Soup会搜索每个tag的”id”属性. 12soup.find_all(id='link2')# [&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;] 如果传入参数href参数，Beautiful Soup会搜索每个tag的”href“属性。 12soup.find_all(href=re.compile(\"elsie\"))# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;] 下面的例子在文档树中查找所有包含id属性的tag，无论id的值是什么： 1234soup.find_all(id=True)# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;] string参数通过string参数可以搜索文档中的字符串内容，与name 参数的可选值一样，string 参数接收 字符串，正则表达式，列表，True。 123456789101112131415soup.find_all(string=\"Elsie\")# [u'Elsie']soup.find_all(string=[\"Tillie\", \"Elsie\", \"Lacie\"])# [u'Elsie', u'Lacie', u'Tillie']soup.find_all(string=re.compile(\"Dormouse\"))[u\"The Dormouse's story\", u\"The Dormouse's story\"]def is_the_only_string_within_a_tag(s): \"\"Return True if this string is the only child of its parent tag.\"\" return (s == s.parent.string)soup.find_all(string=is_the_only_string_within_a_tag)# [u\"The Dormouse's story\", u\"The Dormouse's story\", u'Elsie', u'Lacie', u'Tillie', u'...'] 虽然 string 参数用于搜索字符串,还可以与其它参数混合使用来过滤tag，Beautiful Soup会找到 .string 方法与 string 参数值相符的tag.下面代码用来搜索内容里面包含“Elsie”的标签: 12soup.find_all(\"a\", string=\"Elsie\")# [&lt;a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"&gt;Elsie&lt;/a&gt;] limit参数find_all() 方法返回全部的搜索结果，如果文档树很大，搜索结果则非常慢。 如果不需要全部结果，可以使用limit 参数限制返回结果数量。 当搜索到的结果数量达到limit 的限制时，就停止搜索返回的结果。 文档中总共有3个tag符合搜索条件，但结果只返回了2个，因为对其搜索数量做了限制。 123sou.find_all('a', limit=2)# [&lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;] recursive 参数调用tag的find_all() 方法时，Beautiful Soup会检索当前tag的所有子孙节点，如果只想搜索tag的直接子节点，可以使用参数recursive=False. 一段简单的文档： 1234567&lt;html&gt; &lt;head&gt; &lt;title&gt; The Dormouse's story &lt;/title&gt; &lt;/head&gt;... 是否使用recursive参数的搜索结果： 123456soup.html.find_all(\"title\")# [&lt;title&gt;The Dormouse's story&lt;/title&gt;]soup.html.find_all(\"title\", recursive=False)# [] 这是一段文档片段： 1234567&lt;html&gt; &lt;head&gt; &lt;title&gt; The Dormouse's story &lt;/title&gt; &lt;/head&gt; ... 标签在标签下，但并不是直接子节点，标签才是直接子节点。 在允许查询所有后代节点时，Beautiful Soup 能够查到标签，但是使用了recursive=False 参数之后，只能查找直接子节点，这样就查询不到标签了。 像调用find_all()一样调用tagfind_all() 几乎是BeautifulSoup中最常用的搜索方法，所以定义了其简写方法。 Beautiful Soup对象和tag 对象可以被当作一个方法来使用，这个方法的执行结果与调用这个对象的find_all() 方法相同，如下的两行代码是等价的： 12soup.find_all(\"a\")soup(\"a\") 这两行代码也是等价的： 12soup.title.find_all(string=True)soup.title(string=True) find()find( name , attrs , recursive , string , **kwargs ) find_all() 方法将返回文档中符合条件的所有tag，尽管有时候只想得到一个结果，比如文档中只有一个标签，Name使用find_all() 方法来查找 标签就不太合适， 使用find_all() 方法并设置limit=1 参数不如直接使用find() 方法。 下面两行代码是等价的： 12345soup.find_all('title', limit=1)## [&lt;title&gt;The Dormouse's story&lt;/title&gt;]soup.find('title')# [&lt;title&gt;The Dormouse's story&lt;/title&gt;] 唯一的区别是find_all() 方法的返回结果是值包含一个元素的列表，而find()方法直接返回结果。 find_all() 方法没有找到目标是返回空列表，find()方法找不到目标时，返回None find_parent() 和 find_parent()find_parents( name , attrs , recursive , string , **kwargs ) find_parent( name , attrs , recursive , string , **kwargs ) find_all() 和 find() 只搜索当前节点的所有子节点，孙子节点等。 find_parents() 和 find_parent() 用来搜索当前节点的父辈结点，搜索方法与普通tag的搜索方法相同，搜索文档搜索文档包含的内容。 我们从一个文档中的一个叶子节点开始： 12345678910111213141516a_string = soup.find(string=\"Lacie\")a_string# u'Lacie'a_string.find_parents(\"a\")# [&lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt;]a_string.find_parent(\"p\")# &lt;p class=\"story\"&gt;Once upon a time there were three little sisters; and their names were# &lt;a class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"&gt;Elsie&lt;/a&gt;,# &lt;a class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"&gt;Lacie&lt;/a&gt; and# &lt;a class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"&gt;Tillie&lt;/a&gt;;# and they lived at the bottom of a well.&lt;/p&gt;a_string.find_parents(\"p\", class=\"title\")# [] 修改文档树输出指定文档解析器编码","categories":[{"name":"python","slug":"python","permalink":"yongchunxiaofen.top/categories/python/"}],"tags":[{"name":"Beautiful Soup","slug":"Beautiful-Soup","permalink":"yongchunxiaofen.top/tags/Beautiful-Soup/"},{"name":"爬虫","slug":"爬虫","permalink":"yongchunxiaofen.top/tags/爬虫/"}]},{"title":"python入门学习","slug":"python-01","date":"2016-10-12T13:01:38.000Z","updated":"2016-10-14T13:48:31.000Z","comments":true,"path":"2016/10/12/python-01/","link":"","permalink":"yongchunxiaofen.top/2016/10/12/python-01/","excerpt":"print命令和逗号print “Enter your name:” 然后使用raw_input()函数得到用户的相应，someName = raw_input() 。 运行代码，键入名字，会得到“Enter your name:”和Name并未在同一行。如果希望在同一行，只需要在printf末尾放一个逗号即可。 运算符成员运算符 in 如果在指定的序列中找到值返回true，否则返回false not in 如果在指定的序列中没有找到值则返回true，否则返回false 身份运算符 is 是判断两个标识符是否是引用自一个对象 is not 判断两个标识符是不是引用自不同对象 条件判断python不支持switch语句，多个条件判断，只能用elif实现。","text":"print命令和逗号print “Enter your name:” 然后使用raw_input()函数得到用户的相应，someName = raw_input() 。 运行代码，键入名字，会得到“Enter your name:”和Name并未在同一行。如果希望在同一行，只需要在printf末尾放一个逗号即可。 运算符成员运算符 in 如果在指定的序列中找到值返回true，否则返回false not in 如果在指定的序列中没有找到值则返回true，否则返回false 身份运算符 is 是判断两个标识符是否是引用自一个对象 is not 判断两个标识符是不是引用自不同对象 条件判断python不支持switch语句，多个条件判断，只能用elif实现。 for循环语句for循环的语法格式如下： for iterating_var in sequence: ​ statements(s) 实例：12345678for letter in 'python': print '当前字母：', letterfruits = ['banana'，'apple','mango']for fruit in fruits: print '当前字母：', fruitprint \"Good bye!\" python 函数定义一个函数简单的规则： 函数代码块以def为关键词开头,后接函数标识符名称和圆括号() 任何传入参数和自变量必须放在圆括号中间。 函数的第一行语句可以选择性地使用文档字符串–用于存放函数说明 函数内容以冒号起始，并且缩进 return 结束函数，选择性返回一个值给调用方。不带表达式的return相当于返回None。 语法： 1234def functionname( parameters ): \"函数_文档字符串\" function_suite return [expression] 实例： 1234def printme( str ): \"打印传入的字符串到标准显示设备上\" print str return 函数调用12345678def printme(str): \"打印传入的字符串\" print str; return;# 调用函数printme(\"我要调用用户自定义函数！\")；printme（\"再调用一次！\"）； 按值传递和按引用传递参数python中所有参数都是按引用传递。 如果在函数中修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。 例如： ​ 123456789101112131415def changeme(mylist): \"修改传入的列表\" mylist.append([1,2,3,4]); print \"函数内取值\", mylist return #调用changeme函数mylist = [10,20,30];changeme(mylist)print \"函数外取值：\",mylist#输出为#函数内取值 [10, 20, 30, [1, 2, 3, 4]]#函数外取值： [10, 20, 30, [1, 2, 3, 4]]'''","categories":[{"name":"python","slug":"python","permalink":"yongchunxiaofen.top/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"yongchunxiaofen.top/tags/python/"}]},{"title":"《高质量C++编程指南》读书笔记","slug":"code-rules","date":"2016-09-17T03:27:46.000Z","updated":"2016-09-17T08:43:03.000Z","comments":true,"path":"2016/09/17/code-rules/","link":"","permalink":"yongchunxiaofen.top/2016/09/17/code-rules/","excerpt":"使用visual studio 2013的过程中，除了代码高亮，代码自动缩进等功能让人兴奋不已之外，代码行内的自动加空格也是一大亮点，一直在写代码的过程中琢磨它的行内代码规则，自己也总结了一些，终究是不够全面，而且市面上的书对代码格式规范总结的书也不多。直到看了林锐老师《高质量C++编程指南》，书中对这一部分做了很全面的总结。对这一部分做了一个笔记，以便于对代码格式规范学习和时常查阅。 代码行内的空格： 关键字之后留空格。 像const、virtual、inline、case 等关键词之后至少留一个空格，否则无法辨析关键字。 像if、for、while等关键字之后应留一个空格再跟左括号’(‘,以突出关键字。 函数名之后不留空格，紧跟左括号，以与关键字区别。 ‘（’向后紧跟，而‘）’、‘，’、‘；’向前紧跟，紧跟处不留空格。 ‘,’ 之后要留空格，如Func(x, y, z)。如果‘；’不是一行的结束符，其后要留空格，如for (initialization; condition; update). 赋值操作符、比较操作符、算术操作符、逻辑操作符和位域操作符，比如“=”、“+=”、“&gt;=”、“+”、“*”、“%”、“&amp;&amp;”、“&lt;&lt;”、“^”等二元操作符的前后应加空格。 一元操作符如“!”、“~”、“++”、“--”、“&amp;”（地址运算符）等前后不加空格。 像“［］”、“.”、“-&gt;”这类操作符前后不加空格 对于表达式比较长的for语句和if语句，为了紧凑起见可以适当地去掉一些空格，如 for (i=0; i&lt;10; i++)和if ((a&lt;=b) &amp;&amp; (c&lt;=d))","text":"使用visual studio 2013的过程中，除了代码高亮，代码自动缩进等功能让人兴奋不已之外，代码行内的自动加空格也是一大亮点，一直在写代码的过程中琢磨它的行内代码规则，自己也总结了一些，终究是不够全面，而且市面上的书对代码格式规范总结的书也不多。直到看了林锐老师《高质量C++编程指南》，书中对这一部分做了很全面的总结。对这一部分做了一个笔记，以便于对代码格式规范学习和时常查阅。 代码行内的空格： 关键字之后留空格。 像const、virtual、inline、case 等关键词之后至少留一个空格，否则无法辨析关键字。 像if、for、while等关键字之后应留一个空格再跟左括号’(‘,以突出关键字。 函数名之后不留空格，紧跟左括号，以与关键字区别。 ‘（’向后紧跟，而‘）’、‘，’、‘；’向前紧跟，紧跟处不留空格。 ‘,’ 之后要留空格，如Func(x, y, z)。如果‘；’不是一行的结束符，其后要留空格，如for (initialization; condition; update). 赋值操作符、比较操作符、算术操作符、逻辑操作符和位域操作符，比如“=”、“+=”、“&gt;=”、“+”、“*”、“%”、“&amp;&amp;”、“&lt;&lt;”、“^”等二元操作符的前后应加空格。 一元操作符如“!”、“~”、“++”、“--”、“&amp;”（地址运算符）等前后不加空格。 像“［］”、“.”、“-&gt;”这类操作符前后不加空格 对于表达式比较长的for语句和if语句，为了紧凑起见可以适当地去掉一些空格，如 for (i=0; i&lt;10; i++)和if ((a&lt;=b) &amp;&amp; (c&lt;=d)) 简单的Windows应用程序命名规则： 类名和函数名用大写字母开头的单词组合而成。 变量和参数用小写字母开头的单词组合而成。 常量全用大写的字母，用下划线分割单词 1例如：const int MAX = 100; 静态变量加前缀s_（表示static）。 1例如：static int s_initValue; //静态变量 如果不得已需要全局变量，则使全局变量加前缀g_（表示global）。 1例如：int g_howManyPeople; // 全局变量 类的数据成员加前缀m_（表示member），这样可以避免数据成员与成员函数的参数同名。 123456例如：void Object::SetValue(int Width, int Height)&#123; m_width = Width; m_height = Height;&#125; 函数设计参数规则：如果输入参数以值传递的方式传递对象，则宜用”const &amp;“方式来传递，这样可以省去临时对象的构造和析构过程，提高效率。 内存管理相关注意事项 用 malloc 或 new 申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为 NULL 的内存。 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。 避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。 动态内存的申请与释放必须配对，防止内存泄漏。 用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"yongchunxiaofen.top/tags/代码规范/"}]},{"title":"华为OJ系列（四）","slug":"HuaWei-OJ-Seris-04","date":"2016-09-06T02:30:34.000Z","updated":"2016-09-08T13:52:24.000Z","comments":true,"path":"2016/09/06/HuaWei-OJ-Seris-04/","link":"","permalink":"yongchunxiaofen.top/2016/09/06/HuaWei-OJ-Seris-04/","excerpt":"1. 名字的漂亮度题目描述 给出一个名字，该名字有26个字符串组成，定义这个字符串的“漂亮度”是其所有字母“漂亮度”的总和。每个字母都有一个“漂亮度”，范围在1到26之间。没有任何两个字母拥有相同的“漂亮度”。字母忽略大小写。给出多个名字，计算每个名字最大可能的“漂亮度”。 输入描述: 整数N，后续N个名字 输出描述: 每个名称可能的最大漂亮程度 输入例子: 2zhangsanlisi 输出例子: 192101","text":"1. 名字的漂亮度题目描述 给出一个名字，该名字有26个字符串组成，定义这个字符串的“漂亮度”是其所有字母“漂亮度”的总和。每个字母都有一个“漂亮度”，范围在1到26之间。没有任何两个字母拥有相同的“漂亮度”。字母忽略大小写。给出多个名字，计算每个名字最大可能的“漂亮度”。 输入描述: 整数N，后续N个名字 输出描述: 每个名称可能的最大漂亮程度 输入例子: 2zhangsanlisi 输出例子: 192101 思路分析： 将漂亮度计算的函数单独抽象出来计算，输入每个名字时调用即可。 具体计算时，考虑使用map先统计每个字母出现的次数，imap[char]++. 由于使用这种方法存储时，key是出现的字母，而value是每个字母出现的次数。 然后再使用multimap将出现的字母和对应的次数交换位置 即key是次数，value是对应的字母，由于自动会对key排序 从后往前遍历，用对应的次数乘以相应的权值，将结果求和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;vector&gt;using namespace std;int func(string str)&#123; map&lt;char,int&gt;imap; for (string::size_type i = 0; i &lt; str.size(); i++) &#123; if(str[i]&lt;='Z' &amp;&amp; str[i]&gt;='A') //大写统一转换为小写 str[i]=str[i]+32; imap[str[i]]++; //统计字符出现的次数存储为value &#125; multimap&lt;int,char&gt;map_sort1; //该map存储key为次数，value为字母 map&lt;char, int&gt;::iterator it = imap.begin(); for (int i = 0; i &lt; imap.size(); i++) &#123; map_sort1.insert(pair&lt;int, char&gt;(it-&gt;second, it-&gt;first)); ++it; &#125; //数字置于first int sum = 0; int index = 0; multimap&lt;int, char&gt;::reverse_iterator it1 = map_sort1.rbegin(); for (int i = map_sort1.size()-1; i &gt;=0; i--) //由于排序的性质是从小往大的顺序排列 &#123; //遍历从map的后边开始 sum = sum + (it1-&gt;first)*(26 - index); //初始时，索引值是26， ++index; //每循环一次索引值减1 ++it1; &#125; return sum;&#125;void BeautyOfName(int N)&#123; vector&lt;string&gt;ivec; for (int i = 0; i&lt;N; i++) &#123; string str; cin &gt;&gt; str; ivec.push_back(str); &#125; for (int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; func(ivec[i]) &lt;&lt; endl; &#125;&#125;int main()&#123; int a; while (cin &gt;&gt; a) &#123; BeautyOfName(a); &#125; return 0;&#125; 2. 按字节截取字符串题目描述 编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串。但是要保证汉字不被截半个，如”我ABC”4，应该截为”我AB”，输入”我ABC汉DEF”6，应该输出为”我ABC”而不是”我ABC+汉的半个”。 输入描述: 输入待截取的字符串及长度 输出描述: 截取后的字符串 输入例子: 我ABC汉DEF6 输出例子: 我ABC 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void func(string str,int number)&#123; if(str.empty() || number == 0) return; int N = 0; //存储判断得到的字节数 int M = 0; //存储索引值 for (int i = 0; i &lt; number; i++) &#123; if ((str[i] &lt;= 'Z'&amp;&amp;str[i] &gt;= 'A') || (str[i] &lt;= 'z'&amp;&amp;str[i] &gt;= 'a')) &#123; ++N; if (N == number) M = i; //记录编号 &#125; else &#123; N ++; if (N == number || N == number + 1) M = i; &#125; &#125; for (int i = 0; i &lt;= M; i++) &#123; cout &lt;&lt; str[i]; &#125; cout &lt;&lt; endl;&#125;int main()&#123; string str; int number; while (cin&gt;&gt;str&gt;&gt;number) &#123; func(str, number); &#125; return 0;&#125; 3. 与7相关的数字题目描述 输出7有关数字的个数，包括7的倍数，还有包含7的数字（如17，27，37…70，71，72，73…）的个数 输入描述: 一个正整数N。(N不大于30000) 输出描述: 不大于N的与7有关的数字个数，例如输入20，与7有关的数字包括7,14,17. 输入例子: 20 输出例子: 3 思路分析 遍历从1到给定的数，如果是7的倍数，则个数+1 如果不是7的倍数，将该数字转换为对应的字符串查找是否包含7 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;void func(int N)&#123; if (N &lt;= 0) return; int number = 0; for (int i = 1; i &lt;= N; i++) &#123; if (i % 7 == 0) //统计7的倍数 &#123; ++number; &#125; else //不含7的倍数 &#123; vector&lt;int&gt;ivec; ivec.clear(); int temp_1 = i; while (temp_1) &#123; int temp; temp = temp_1 % 10; ivec.push_back(temp); temp_1 /= 10; &#125; if (find(ivec.begin(), ivec.end(), 7) != ivec.end()) ++number; &#125; &#125; cout &lt;&lt; number &lt;&lt; endl;&#125;int main()&#123; int N; while (cin &gt;&gt; N) &#123; func(N); &#125; return 0;&#125; 4. &lt;我的华为机试题目&gt;字符串输出题目描述 输入一串整数，对整数进行排序，然后将排序后的数输出，输出时有如下规则：如果排序后的数是相邻数，只输出相邻数中最小和最大的数，其余数字正常输出。 输入描述: 以逗号分开的一串数字，比如7,1,3,2,5,8,6,9 输出描述: 输出排序后的数，相邻数只输出最小和最大数.输出数之间以空格分隔。 输入例子: 7,1,3,2,5,8,6,9 输出例子： 1 3 5 9 思路分析： 由于输入的数字不确定个数，而且之间是以逗号分隔开，因此，考虑以字符串的形式读入之后再分割化为整数进行排序输出。 其中使用atoi函数将字符串转换为对应的整数，而其中存储字符串的char ch[]在每次使用完毕要进行初始化操作，这儿将其每个字符初始化为字符串结尾符&apos;\\0&apos;。 进行相邻数字的判定时，先输出vector中的第一个数字，然后从第二个数字遍历到倒数第二个数字，如果当前数减1等于前一个数 &amp;&amp; 当前数加1等于后一个数时，进行一个空操作，其else（非条件）时，输出当前对应的数字。 最后输出最后一个数字。 其中，为了防止输入的数字中有重复的数字，将所有数字压入set进行了一次去重操作。 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;using namespace std;void func(string str)&#123; char ch[100]; memset(ch, '\\0', 100); int k = 0; vector&lt;int&gt;ivec; for (int i = 0; i &lt; str.size(); i++) &#123; if (str[i] != ',') ch[k++] = str[i]; if (str[i] == ',') &#123; int temp = atoi(ch); ivec.push_back(temp); memset(ch, '\\0', 100); k = 0; &#125; &#125; char ch1[100]; memset(ch1, '\\0', 100); int kk = 0; for (int i = str.size() - 1; i &gt;= 0; i--) &#123; if (str[i] == ',') &#123; for (int jj = i + 1; jj &lt; str.size(); jj++) &#123; ch1[kk++] = str[jj]; int temp1 = atoi(ch1); ivec.push_back(temp1); &#125; break; &#125; &#125; set&lt;int&gt;iset(ivec.begin(),ivec.end()); //踢除重复数 vector&lt;int&gt;vec(iset.begin(),iset.end()); cout &lt;&lt; vec[0] &lt;&lt; \" \"; for (int i = 1; i &lt; vec.size()-1; i++) &#123; if ((vec[i] - 1 == vec[i - 1]) &amp;&amp; (vec[i] + 1 == vec[i + 1])) ; else &#123; cout &lt;&lt; vec[i] &lt;&lt; \" \"; &#125; &#125; cout &lt;&lt; vec[vec.size() - 1] &lt;&lt; endl;&#125;int main()&#123; string str; while (cin &gt;&gt; str) &#123; func(str); &#125; return 0;&#125; 5. 连续子数组的最大和题目描述 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？ 思路分析： 1. 考虑输入的合法性 2. 判断是否全是负数的情况 代码：1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; if(array.empty()) return 0; vector&lt;int&gt;::iterator it = max_element(array.begin(),array.end()); int temp = (*it); if(temp &lt; 0) &#123; return temp; &#125; int sum = 0; int max = 0; for(vector&lt;int&gt;::size_type i =0;i&lt;array.size();i++) &#123; sum = sum + array[i]; if(sum&lt;0) &#123; sum = 0; &#125; else &#123; if(sum &gt; max) max = sum; &#125; &#125; return max; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"华为OJ","slug":"华为OJ","permalink":"yongchunxiaofen.top/tags/华为OJ/"}]},{"title":"笔试中应该注意的坑之基础篇","slug":"some-problems-01","date":"2016-08-31T01:13:18.000Z","updated":"2016-09-05T08:25:01.000Z","comments":true,"path":"2016/08/31/some-problems-01/","link":"","permalink":"yongchunxiaofen.top/2016/08/31/some-problems-01/","excerpt":"1. if语句if语句中的坑主要是if语句与各种零值的比较语句写法： 布尔变量与零值的比较布尔变量的语义，零值为“假”（记为FALSE），任何非零值都是“真”（记为TRUE）。TRUE的值究竟是什么并没有统一标准。例如VC++中将TRUE定义为1，而Visual Basic则将TRUE定义为-1.所以不能将布尔变量直接与TRUE，FALSE或者1、0进行比较。 比较良好的写法如下： 比如有一bool型变量flag，bool flag，判断flag与零值的比较的语句如下： if(flag) //如果flag为真则执行if语句 以下写法均为不良风格，例如： if (flag == TRUE) if (flag == 1 ) if (flag == FALSE) if (flag == 0) 整型变量与零值比较例如 int value与零值的比较可以写成如下： if(value == 0) if(value != 0) 而不可魔方布尔变量风格写成 if(value) if(!value) 浮点变量与零值比较如果有一double型变量x，其与零值的比较可以写为如下语句： if(x-0.0&gt;1e-6) //1e-6是允许的精度范围 if ((x&gt;=-EPSINON) &amp;&amp; (x&lt;=EPSINON)) 其中EPSINON 是允许的误差（即精度）","text":"1. if语句if语句中的坑主要是if语句与各种零值的比较语句写法： 布尔变量与零值的比较布尔变量的语义，零值为“假”（记为FALSE），任何非零值都是“真”（记为TRUE）。TRUE的值究竟是什么并没有统一标准。例如VC++中将TRUE定义为1，而Visual Basic则将TRUE定义为-1.所以不能将布尔变量直接与TRUE，FALSE或者1、0进行比较。 比较良好的写法如下： 比如有一bool型变量flag，bool flag，判断flag与零值的比较的语句如下： if(flag) //如果flag为真则执行if语句 以下写法均为不良风格，例如： if (flag == TRUE) if (flag == 1 ) if (flag == FALSE) if (flag == 0) 整型变量与零值比较例如 int value与零值的比较可以写成如下： if(value == 0) if(value != 0) 而不可魔方布尔变量风格写成 if(value) if(!value) 浮点变量与零值比较如果有一double型变量x，其与零值的比较可以写为如下语句： if(x-0.0&gt;1e-6) //1e-6是允许的精度范围 if ((x&gt;=-EPSINON) &amp;&amp; (x&lt;=EPSINON)) 其中EPSINON 是允许的误差（即精度） 关于循环语句 for循环多重循环中，如果有可能，应将最长的循环放在最内层，最短的循环放在最外层，减少CPU跨切循环层的次数。 如果循环体内存在逻辑判断，并且循环次数很大，宜将逻辑判断移到循环体的外面。如下图右框内的程序，简洁度略有下降，但是执行效率却大幅度提高。 建议for 语句的循环控制变量的取值采用“半开半闭区间”写法。 比如：int i=0; i&lt; N; i++ switch 语句 每个case结尾的break不要忘记，否则导致多个分支重叠执行。 不要忘记最后的default分支 常量 宏定义常量#define 宏常量没有数据类型，编译器不进行类型检查 const常量 const常量有数据类型 ，编译器可以进行类型舰船 类中的常量 不能在类声明中初始化const数据成员，const数据成员的初始化只能在类构造函数的初始化列表中进行。 const数据成员只在某个对象生存期间是常量，而对于整个类而言确是可变的，因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。 函数函数内部的实现 函数体的“入口处”，对参数的有效性进行检查。 函数的“出口处”，对return语句的正确性和效率进行检查。 return 语句不可返回指向“ ”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁 搞清楚返回的究竟是“值”，“指针”还是“引用” 关于断言断言assert是仅在debug版本下起作用的宏。它用于检查不应该发生的情况。运行过程中，如果assert的参数为假，程序就会中断。## 引用和指针关于引用一些非常重要的规则&lt;区别与指针&gt;：- 引用被创建的同时必须被初始化- 不能有NULL引用，引用必须与合法的存储单元关联- 一旦被初始化，就不能改变引用的关系# 内存管理## 常见的内存错误- 内存分配并未成功，却使用了它。 - 在函数入口处使用assert进行检查。- 内存分配成功，但是并未初始化 - 无论使用何种方式创建数组，都应该赋初值- 分配成功且初始化，但操作越过了内存边界 - 数组遍历时多1或者少1的操作，注意边界条件- 忘记了释放内存- 释放了内存仍然使用它 - 程序中的对象调用过于复杂，在难以搞懂是否释放的情况下使用 - return返回指向栈上的内存 - 使用free或者delete释放内存后，没有将指针设置为NULL，导致产生“野指针”## 指针和数组不少地方指针和数组可以相互替换使用。但是两者绝不是等价的。数组要么在静态存储区被创建，要么在栈上创建。数组名对应着一块内存，其地址与容量在生命周期内保持不变，只有数组的内容可以改变。指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。 关于两者的内容修改123456char a[] = “hello”; a[0] = ‘X’; cout &lt;&lt; a &lt;&lt; endl; char *p = “world”; // 注意p指向常量字符串 p[0] = ‘X’; // 编译器不能发现该错误 cout &lt;&lt; p &lt;&lt; endl; 字符数组a的容量是6个字符，其内容为hello\\0（位于栈上）。a的内容可以改变，如a[0]=‘X’。 指针p指向常量字符串“world”（位于静态存储区，内容为world\\0），常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句p[0]= ‘X’有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。 关于两者进行内容复制 不能对数组名进行直接复制与比较。若想把数组a的内容复制给数组b，不能用语句b = a ，否则将产生编译错误。应该用标准库函数strcpy进行复制。同理，比较b和a的内容是否相同，不能用if(b==a) 来判断，应该用标准库函数strcmp进行比较。语句p =a 并不能把a的内容复制指针p，而是把a的地址赋给了p。要想复制a的内容，可以先用库函数malloc为p申请一块容量为strlen(a)+1个字符的内存，再用strcpy进行字符串复制。同理，语句if(p==a) 比较的不是内容而是地址，应该用库函数strcmp来比较。## 指针参数如何传递内存如果函数的参数是一个指针，不要指望用该指针去申请动态内存。 如下例中，Test函数的语句GetMemory(str,200)并没有使str获得期望的内存，str依旧是NULL。12345678910void GetMemory(char *p, int num) &#123; p = (char *)malloc(sizeof(char) * num); &#125; void Test(void) &#123; char *str = NULL; GetMemory(str, 100); // str 仍然为NULL strcpy(str, \"hello\"); // 运行错误 &#125; 我们来分析一下，其实上例的问题出在函数GetMemory中。 编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是_p，编译器使 _p= p。 如果函数体内的程序修改了_p的内容，就导致参数p的内容作相应的修改。这就是指针可以用作输出参数的原因。 在本例中，_p申请了新的内存，只是把_p所指的内存地址改变了，但是p丝毫未变（形参有时候就是很害人）。 所以函数GetMemory并不能输出任何东西。 事实上，每执行一次GetMemory就会泄露一块内存，因为没有用free释放内存。 而以下的方案确实可行的 12345678910111213char *GetMemory3(int num) &#123; char *p = (char *)malloc(sizeof(char) * num); return p; &#125; void Test3(void) &#123; char *str = NULL; str = GetMemory3(100); strcpy(str, \"hello\"); cout&lt;&lt; str &lt;&lt; endl; free(str); &#125; 以上代码的可执行性不用质疑。 用函数返回值来传递动态内存这种方法虽然好用，但是常常有人将return语句用错。强调的是不要使用return语句返回指向“栈内存”的指针，因为该指针在函数结束时自动消亡！而上述程序的指针p指向由malloc分配的堆内存，因此可以放心return。 而以下的代码则不可取1234567891011char *GetString(void) &#123; char p[] = \"hello world\"; return p; // 编译器将提出警告 &#125; void Test4(void) &#123; char *str = NULL; str = GetString(); // str 的内容是垃圾 cout&lt;&lt; str &lt;&lt; endl; &#125; 此处，指针p是一个栈的指针。 关于free和deletedelete和free只是将指针指向的内存释放掉了， 但是指针本身却被留下来了 如果不将free/delete之后的指针指向NULL， 该指针会变成一野指针。 12345678char *p = (char *) malloc(100); strcpy(p, “hello”); free(p); // p 所指的内存被释放，但是p所指的地址仍然不变 … if(p != NULL) // 没有起到防错作用 &#123; strcpy(p, “world”); // 出错 &#125; 如果跟踪调试上述例子，会发现指针p被free以后其地址仍然不变，不是NULL，只是该地址对应的内存时垃圾，p变成了野指针。如果此时不将p设置为NULL，会让人误以为p是个合法的指针。 关于野指针野指针不是NULL指针，是指向垃圾内存的指针。人们一般不会错用NULL指针，引用使用if语句可以判断。但是if语句对其不起作用。 野指针出现的原因 指针变量没有被初始化 指针p被free或者delete之后，没有设置为NULL 指针操作超越了变量的作用范围 malloc/freemalloc的原型如下； void *malloc(size_t size) 用malloc申请一块长度为length的整数类型的内存， int *p = (int *) malloc(sizeof(int) * length) 这儿有两点需要注意：类型转换和sizeof 由于malloc的返回值类型是void *，无类型指针。所以在调用malloc时要显示地进行类型转换 malloc函数本身并不识别申请的内存是什么类型，它只关心的是内存的字节总数。于是用malloc申请的时候使用int，float等数据类型的确切字节值传递给函数作为参数","categories":[{"name":"C++面试","slug":"C-面试","permalink":"yongchunxiaofen.top/categories/C-面试/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"}]},{"title":"memcpy, memset,memmove区别分析","slug":"some-functions-about-memory-operator","date":"2016-08-28T13:29:53.000Z","updated":"2016-08-29T03:28:05.000Z","comments":true,"path":"2016/08/28/some-functions-about-memory-operator/","link":"","permalink":"yongchunxiaofen.top/2016/08/28/some-functions-about-memory-operator/","excerpt":"1. memcpyC和C++使用的内存拷贝函数，mencpy函数的功能是从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中。 头文件：12#include&lt;string.h&gt;#include&lt;cstring&gt; 返回值返回指向dest的指针123456789101112#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char* s = \"GoldenGlobalView\"; char d[20]; //clrscr(); memcpy(d, s, (strlen(s) + 1)); printf(\"%s\", d); getchar(); return 0;&#125; 输出结果：GoldenGlobalView","text":"1. memcpyC和C++使用的内存拷贝函数，mencpy函数的功能是从源src所指的内存地址的起始位置开始拷贝n个字节到目标dest所指的内存地址的起始位置中。 头文件：12#include&lt;string.h&gt;#include&lt;cstring&gt; 返回值返回指向dest的指针123456789101112#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char* s = \"GoldenGlobalView\"; char d[20]; //clrscr(); memcpy(d, s, (strlen(s) + 1)); printf(\"%s\", d); getchar(); return 0;&#125; 输出结果：GoldenGlobalView 123456789101112#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char* s = \"GoldenGlobalView\"; char d[20]; memcpy(d, s + 12, 4);//从第13个字符(V)开始复制，连续复制4个字符(View) d[4] = '\\0';//memcpy(d,s+12*sizeof(char),4*sizeof(char));也可 printf(\"%s\", d); getchar(); return 0;&#125; 输出：View作用：将s中第13个字符开始的4个连续字符复制到d中。(从0开始) 1.1 strcpy与memcpy的区别 复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体等。 复制的方法不同。strcpy不需要指定长度，它遇到被复制字符串的结束符&#39;\\0&#39;才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度 用途不同。strcpy一般复制字符串，其他类型一般用memcpy 2. memset函数原型：void *memset(void *s,int ch,size_t n); 将s中当前位置后面的n个字节用ch替换并返回s 或者是 将s所指向的某一块内存中的前n个字节的内容全部设置为ch指定的ASCⅡ值，第一个值为指定的内存地址，块的大小由第三个参数决定。 该函数通常为新申请的内存做初始化工作，其返回值为指向s的指针。123456789101112#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;memory.h&gt; int main(void)&#123; char buffer[]=\"Helloworld\\n\"; printf(\"Buffer before memset:%s\\n\",buffer); memset(buffer,'*',strlen(buffer)); printf(\"Buffer after memset:%s\\n\",buffer); return 0;&#125; 输出结果： Buffer before memset:Helloworld Buffer after memset:*********** 3. memmovememmove用于从src拷贝count个字节到dest，如果目标区域和源区域有重叠的话，memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中。但复制后src内容会被更改。但是当目标区域与源区域没有重叠则和memcpy函数功能相同。 4. memccpy表头文件: #include &lt;string.h&gt;定义函数:void *memccpy(void *dest, const void *src, int c, size_t n);函数说明: memccpy()用来拷贝src所指的内存内容前n个字节到dest所指的地址上。与memcpy()不同的是,memccpy()如果在src中遇到某个特定值(int c)立即停止复制。返回值: 返回指向dest中值为c的下一个字节指针。返回值为0表示在src所指内存前n个字节中没有值为c的字节。","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"}]},{"title":"一个简单的异常处理的例子","slug":"a-simple-example-of-exception","date":"2016-08-28T08:51:33.000Z","updated":"2016-08-28T09:37:13.000Z","comments":true,"path":"2016/08/28/a-simple-example-of-exception/","link":"","permalink":"yongchunxiaofen.top/2016/08/28/a-simple-example-of-exception/","excerpt":"","text":"C++异常处理的处理思想是：将异常的检测与处理分离。 当在一个函数体中检测到异常条件存在，但无法确定相应的处理方法时，将引发一个异常，并由函数的直接或者间接调用检测并处理这个异常。 异常处理通过三个关键字来完成：throw，try，catch 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int Div(int x, int y)&#123; if (y == 0) throw y;//异常检测 return x / y;&#125;int main()&#123; try //将可能有异常的执行代码放入try语句块中 &#123; cout &lt;&lt; \"7/3=\" &lt;&lt; Div(7, 3) &lt;&lt; endl; cout &lt;&lt; \"5/0=\" &lt;&lt; Div(5, 0) &lt;&lt; endl; &#125; catch (int)//括号中的数据类型为遇到异常时抛出的数据类型 &#123; cout &lt;&lt; \"除数为0，错误！\" &lt;&lt; endl; //异常处理 &#125; cout &lt;&lt; \"END\" &lt;&lt; endl; return 0;&#125; 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int main()&#123; int i; char ch; cout &lt;&lt; \"请输入一个整数和一个字符:\\n\" &lt;&lt; endl; try &#123; cin &gt;&gt; i &gt;&gt; ch; if (i == 0) throw 0; if (ch == '!') throw '!'; &#125; catch (int) &#123; cout &lt;&lt; \"错误：输入为0\"&lt;&lt;endl; &#125; catch (char) &#123; cout &lt;&lt; \"错误：输入了字符！\"&lt;&lt;endl; &#125; cout &lt;&lt; \"END\" &lt;&lt; endl; return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"异常处理","slug":"异常处理","permalink":"yongchunxiaofen.top/tags/异常处理/"}]},{"title":"C++ STL常用方法笔记","slug":"cpp-STL","date":"2016-08-23T02:47:25.000Z","updated":"2016-08-24T14:18:38.000Z","comments":true,"path":"2016/08/23/cpp-STL/","link":"","permalink":"yongchunxiaofen.top/2016/08/23/cpp-STL/","excerpt":"关于STL中算法库的更详细的用法说明请移步cppreference查询：http://zh.cppreference.com/w/cpp/algorithm STL容器库：http://zh.cppreference.com/w/cpp/container STL的代码从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），几乎所有的代码都采用了模板类和模版函数的方式. 在C++标准中，STL被组织为下面的13个头文件：&lt;algorithm&gt;、&lt;deque&gt;、&lt;functional&gt;、&lt;iterator&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;stack&gt;和&lt;utility&gt;。 1. vector从后面快速的插入与删除，直接访问任何元素。可以看作动态数组。自动分配一块连续的内存空间进行数据存储。当存储的数据超过分配的空间时，会重新分配一块内存块： 首先，会申请一块更大的内存块；然后，将原来的数据拷贝到新的内存块中；其次，销毁掉原内存块中的对象（调用对象的析构函数）；最后，将原来的内存空间释放掉。 随机访问方便，支持[]/vector.at()。vector被设计成只能在后端进行追加和删除操作。只能在最后进行push和pop，不能在头进行。 vector 类中定义了4中种构造函数:默认构造函数:构造一个初始长度为0的空向量.vectorv1;构造函数:有一个可选参数,如果预定义了size,他的成员都被赋为0.vectorv2(init_size,0);复制构造函数:构造一个新的向量,作为已存在的向量的完全复制.vectorv3(v2);带两个常量参数的构造函数:vectorv4(first,last);","text":"关于STL中算法库的更详细的用法说明请移步cppreference查询：http://zh.cppreference.com/w/cpp/algorithm STL容器库：http://zh.cppreference.com/w/cpp/container STL的代码从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），几乎所有的代码都采用了模板类和模版函数的方式. 在C++标准中，STL被组织为下面的13个头文件：&lt;algorithm&gt;、&lt;deque&gt;、&lt;functional&gt;、&lt;iterator&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;stack&gt;和&lt;utility&gt;。 1. vector从后面快速的插入与删除，直接访问任何元素。可以看作动态数组。自动分配一块连续的内存空间进行数据存储。当存储的数据超过分配的空间时，会重新分配一块内存块： 首先，会申请一块更大的内存块；然后，将原来的数据拷贝到新的内存块中；其次，销毁掉原内存块中的对象（调用对象的析构函数）；最后，将原来的内存空间释放掉。 随机访问方便，支持[]/vector.at()。vector被设计成只能在后端进行追加和删除操作。只能在最后进行push和pop，不能在头进行。 vector 类中定义了4中种构造函数:默认构造函数:构造一个初始长度为0的空向量.vectorv1;构造函数:有一个可选参数,如果预定义了size,他的成员都被赋为0.vectorv2(init_size,0);复制构造函数:构造一个新的向量,作为已存在的向量的完全复制.vectorv3(v2);带两个常量参数的构造函数:vectorv4(first,last); 方法: c.assign(beg,end) c.assign(n,elem) 将(beg; end)区间中的数据赋值给c。将n个elem的拷贝赋值给c。 c. at(idx) 传回索引idx所指的数据，如果idx越界，抛出out_of_range。 c.back() 传回最后一个数据，不检查这个数据是否存在。 c.begin() 传回迭代器中的第一个数据地址。 c.capacity() 返回容器中数据个数。 c.clear() 移除容器中所有数据。 c.empty() 判断容器是否为空。 c.end() // 指向迭代器中末端元素的下一个，指向一个不存在元素。 c.erase(pos) // 删除pos位置的数据，**传回下一个数据的位置**。 c.erase(beg,end) //删除[beg,end)区间的数据，传回下一个数据的位置。 c.front() //传回第一个数据。 get_allocator 使用构造函数返回一个拷贝。 c.insert(pos,elem) // 在pos位置插入一个elem拷贝，传回新数据位置 c.insert(pos,n,elem) // 在pos位置插入n个elem数据,无返回值 c.insert(pos,beg,end) // 在pos位置插入在[beg,end)区间的数据。无返回值c.max_size() 返回容器中最大数据的数量。 c.pop_back() 删除最后一个数据。 c.push_back(elem) 在尾部加入一个数据。 c.rbegin() 传回一个逆向队列的第一个数据。 c.rend() 传回一个逆向队列的最后一个数据的下一个位置。 c.resize(num) 重新指定队列的长度。 c.reserve() 保留适当的容量。 c.size() 返回容器中实际数据的个数。 c1.swap(c2) // 将c1和c2元素互换 2. list双链表，从任何地方快速插入与删除。 数据由若干个节点构成，每一个节点都包括一个信息块、一个前驱指针、一个后驱指针。不使用连续的内存空间这样可以随意地进行动态操作。可以在内部任何位置快速地插入或删除，当然也可以在两端进行push和pop。不能进行内部的随机访问，不支持[]/vector.at()。 五个构造函数:list c0;//空链表list c1(3); //建一个含三个默认值是0的元素的链表list c2(5,2);//建一个含五个元素的链表,值都是2list c4(c2);//建一个c2的copy链表list c5(c1.begin(),c1.end());//含c1一个区域的元素[first,last). 方法: assign() //分配值，有两个重载： c1.assign(++c2.begin(), c2.end()) c1.assign(7,4) //c1中现在为7个4。 back() //返回最后一元素的引用： begin() //返回第一个元素的指针(iterator) clear() //删除所有元素 empty() //判断是否链表为空 end() //返回最后一个元素的下一位置的指针(list为空时end()=begin()) erase() //删除一个元素或一个区域的元素(两个重载) front() //返回第一个元素的引用： insert() //在指定位置插入一个或多个元素(三个重载)： max_size() //返回链表最大可能长度(size_type就是int型)： merge() //合并两个链表并使之默认升序(也可改)： pop_back() //删除链表尾的一个元素 pop_front() //删除链表头的一元素 push_back() //增加一元素到链表尾 push_front() //增加一元素到链表头 rbegin() //返回链表最后一元素的后向指针(reverse_iterator or const) rend() //返回链表第一元素的下一位置的后向指针 remove //()删除链表中匹配值的元素(匹配元素全部删除) remove_if() //删除条件满足的元素(会遍历一遍链表) resize() //重新定义链表长度(两重载)： reverse() //反转链表: size() //返回链表中元素个数 sort() //对链表排序，默认升序(可自定义) splice() //对两个链表进行结合(三个重载) swap() //交换两个链表(两个重载) unique() //删除相邻重复元素(断言已经排序，因为它不会删除不相邻的相同元素) 123456789101112example:// 输出一个链表void ShowList(list&lt;int&gt;&amp; listTemp)&#123; // size()返回链表中元素个数 cout &lt;&lt; listTemp.size() &lt;&lt; endl; for (list&lt;int&gt;::iterator it = listTemp.begin(); it != listTemp.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; ' '; &#125; cout &lt;&lt; endl;&#125; 3. map一对多映射，基于关键字快速查找，不允许重复值。由于其按链表的方式存储，它也继承了链表的优缺点。 构造函数:Templatemap();//默认构造函数map(const map&amp; m)//拷贝构造函数map(iterator begin,iterator end);//区间构造函数map(iterator begin,iterator end,const traits&amp;_compare)//带比较谓词的构造函数map(iterator begin,iterator end,const traits&amp;_compare,const allocator&amp;_all)//带分配器 example:123456789101112131415161718192021222324252627282930313233343536371.#include &lt;iostream&gt; #include &lt;map&gt; using namespace std; int main(void) &#123; map&lt;char,int,less&lt;char&gt; &gt; map1; map&lt;char,int,less&lt;char&gt; &gt;::iterator mapIter;map1[''c'']=3; map1[''d'']=4; map1[''a'']=1; map1[''b'']=2; for(mapIter=map1.begin();mapIter!=map1.end();++mapIter) cout&lt;&lt;\" \"&lt;&lt;(*mapIter).first&lt;&lt;\": \"&lt;&lt;(*mapIter).second;map&lt;char,int,less&lt;char&gt; &gt;::const_iterator ptr; ptr=map1.find(''d''); cout&lt;&lt;''\\n''&lt;&lt;\" \"&lt;&lt;(*ptr).first&lt;&lt;\" 键对应于值：\"&lt;&lt;(*ptr).second; cin.get(); return 0; &#125; 2.#include&lt;map&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; map&lt;string,int&gt; m; m[\"a\"]=1; m[\"b\"]=2; m[\"c\"]=3; map&lt;string,int&gt;::iterator it; for(it=m.begin();it!=m.end();++it) cout&lt;&lt;\"key: \"&lt;&lt;it-&gt;first &lt;&lt;\" value: \"&lt;&lt;it-&gt;second&lt;&lt;endl; return 0;&#125; 应用篇: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271.不用STL:#include \"stdafx.h\"#include &lt;stdlib.h&gt;#include &lt;iostream&gt;using namespace std;int compare(const void *arg1, const void *arg2);void main(void)&#123; const int max_size = 10; int num[max_size]; int n; for (n = 0; cin &gt;&gt; num[n]&amp;&amp;n&lt;max_size-2; n ++); cout&lt;&lt;'\\n'; qsort(num, n+1, sizeof(int), compare); for (int i = 0; i &lt; n+1; i ++) cout &lt;&lt; num[i] &lt;&lt; \"\\n\"; system(\"pause\");&#125;int compare(const void *arg1, const void *arg2)&#123; return (*(int *)arg1 &lt; *(int *)arg2) ? -1 : (*(int *)arg1 &gt; *(int *)arg2) ? 1 : 0;&#125;2.STL:#include \"stdafx.h\"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;stdlib.h&gt;using namespace std;void main(void)&#123; vector&lt;int&gt; num; int element; while (cin &gt;&gt; element) num.push_back(element); sort(num.begin(), num.end()); for (int i = 0; i &lt; num.size(); i ++) cout &lt;&lt; num[i] &lt;&lt; \"\\n\"; system(\"pause\");&#125;3.第三版:#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iterator&gt;using namespace std;void main(void)&#123; typedef vector&lt;int&gt; int_vector; typedef istream_iterator&lt;int&gt; istream_itr; typedef ostream_iterator&lt;int&gt; ostream_itr; typedef back_insert_iterator&lt;int_vector&gt; back_ins_itr; int_vector num; copy(istream_itr(cin),istream_itr(),back_ins_itr(num)); sort(num.begin(),num.end()); copy(num.begin(),num.end(),ostream_itr(cout,'\\n')); system(\"pause\");&#125;4.#include \"stdafx.h\"#include&lt;stdlib.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define SIZE 100int iarray[SIZE];int main()&#123; iarray[20] = 50; int* ip = find(iarray, iarray + SIZE, 50); if (ip == iarray + SIZE) cout &lt;&lt; \"50 not found in array\" &lt;&lt; endl; else cout &lt;&lt; *ip &lt;&lt; \" found in array\" &lt;&lt; endl; system(\"pause\");&#125;5.#include \"stdafx.h\"#include&lt;stdlib.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std; vector&lt;int&gt; intVector(100);void main()&#123; intVector[20] = 50; vector&lt;int&gt;::iterator intIter = find(intVector.begin(), intVector.end(), 50); if (intIter != intVector.end()) cout &lt;&lt; \"Vector contains value \" &lt;&lt; *intIter &lt;&lt; endl; else cout &lt;&lt; \"Vector does not contain 50\" &lt;&lt; endl; system(\"pause\");&#125;6.int main()&#123;vector&lt;string&gt; v;string tmp;while(getline(cin,tmp))v.push_back(tmp);sort(v.begin(),v.end());copy(v.begin(),v.end(),ostream_iterator&lt;string&gt;(cout,\"\\n\"));&#125; 4. STL算法STL算法部分主要由头文件&lt;algorithm&gt;,&lt;numeric&gt;,&lt;functional&gt;组成。要使用 STL中的算法函数必须包含头文件&lt;algorithm&gt;，对于数值算法须包含&lt;numeric&gt;，&lt;functional&gt;中则定义了一些模板类，用来声明函数对象。STL中算法大致分为四类：1）、非可变序列算法：指不直接修改其所操作的容器内容的算法。2）、可变序列算法：指可以修改它们所操作的容器内容的算法。3）、排序算法：包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。4）、数值算法：对容器内容进行数值计算。 以下对所有算法进行细致分类并标明功能： &lt;一&gt;查找算法(13个)：判断容器中是否包含某个值 adjacent_find:在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。 binary_search: 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。 count: 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。 count_if: 利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。 123456789101112#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int a[] = &#123; 1, 2, 4, 5, 6 &#125;; vector&lt;int&gt;ivec(a, a + 5); cout &lt;&lt; count_if(ivec.begin(), ivec.end(), [](int i)&#123;return i % 2 == 0; &#125;); return 0;&#125; equal_range: 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。 1234567891011121314151617181920212223#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;struct S &#123; int number; char name; S ( int number, char name ) : number ( number ), name ( name ) &#123;&#125; // only the number is relevant with this comparison bool operator&lt; ( const S&amp; s ) const &#123; return number &lt; s.number; &#125;&#125;;int main() &#123; // note: not ordered, only partitioned w.r.t. S defined below std::vector&lt;S&gt; vec = &#123; &#123;1,'A'&#125;, &#123;2,'B'&#125;, &#123;2,'C'&#125;, &#123;2,'D'&#125;, &#123;4,'G'&#125;, &#123;3,'F'&#125; &#125;; S value ( 2, '?' ); auto p = std::equal_range(vec.begin(),vec.end(),value); for ( auto i = p.first; i != p.second; ++i ) std::cout &lt;&lt; i-&gt;name &lt;&lt; ' ';&#125; find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的一个InputIterator。 123456789101112#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int a[] = &#123; 1, 4, 4, 5, 6 &#125;; vector&lt;int&gt;ivec(a, a + 5); vector&lt;int&gt;::iterator it= find(ivec.begin(), ivec.end(), 5); cout &lt;&lt; *it &lt;&lt; endl; //查找之后返回iterator return 0;&#125; find_end: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”的最后一次出现。找到则返回最后一对的第一个ForwardIterator，否则返回输入的”另外一对”的第一个ForwardIterator。重载版本使用用户输入的操作符代替等于操作。 1234567891011121314151617#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123;std::vector&lt;int&gt; v&#123;1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4&#125;;std::vector&lt;int&gt;::iterator result;std::vector&lt;int&gt; t1&#123;1, 2, 3&#125;;result = std::find_end(v.begin(), v.end(), t1.begin(), t1.end());if (result == v.end()) &#123; std::cout &lt;&lt; \"subsequence not found\\n\";&#125; else &#123; std::cout &lt;&lt; \"last subsequence is at: \" &lt;&lt; std::distance(v.begin(), result) &lt;&lt; \"\\n\";&#125; find_first_of: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”中任意一个元素的第一次出现。重载版本中使用了用户自定义操作符。 find_if: 使用输入的函数代替等于操作符执行find。 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;bool isOdd(int i)&#123; if (i % 2 == 0) return 0; else return 1;&#125;int main()&#123; int a[] = &#123; 2, 4, 4, 5, 6 &#125;; vector&lt;int&gt;ivec(a,a+5); vector&lt;int&gt;::iterator it=find_if(ivec.begin(), ivec.end(), isOdd); cout &lt;&lt; \"The first odd is \" &lt;&lt; *it &lt;&lt; endl; return 0;&#125; lower_bound: 返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函数使用自定义比较操作。 upper_bound: 返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志一个大于value的值。重载函数使用自定义比较操作。 search: 给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位置，查找失败指向last1。重载版本使用自定义的比较操作。 search_n: 在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。 &lt;二&gt;排序和通用算法(14个)：提供元素排序策略 inplace_merge: 合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。 merge: 合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。 nth_element: 将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重载版本使用自定义的比较操作。 partial_sort: 对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。 partial_sort_copy: 与partial_sort类似，不过将经过排序的序列复制到另一个容器。 partition: 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。 random_shuffle: 对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。 reverse: 将指定范围内元素重新反序排序。 reverse_copy: 与reverse类似，不过将结果写入另一个容器。 rotate: 将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。 rotate_copy: 与rotate类似，不过将结果写入另一个容器。 sort: 以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。 stable_sort: 与sort类似，不过保留相等元素之间的顺序关系。 stable_partition: 与partition类似，不过不保证保留容器中的相对顺序。 &lt;三&gt;删除和替换算法(15个) copy: 复制序列 copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。 iter_swap: 交换两个ForwardIterator的值。 remove: 删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和remove_if函数。 remove_copy: 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。 remove_if: 删除指定范围内输入操作结果为true的所有元素。 remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。 replace: 将指定范围内所有等于vold的元素都用vnew代替。 replace_copy: 与replace类似，不过将结果写入另一个容器。 replace_if: 将指定范围内所有操作结果为true的元素用新值代替。 replace_copy_if: 与replace_if，不过将结果写入另一个容器。 swap: 交换存储在两个对象中的值。 swap_range: 将指定范围内的元素与另一个序列元素值进行交换。 unique: 清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。 unique_copy: 与unique类似，不过把结果输出到另一个容器。 &lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合 next_permutation: 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。 prev_permutation: 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。 &lt;五&gt;算术算法(4个) accumulate: iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。 partial_sum: 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。 inner_product: 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。 adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。 &lt;六&gt;生成和异变算法(6个) fill: 将输入值赋给标志范围内的所有元素。 fill_n: 将输入值赋给first到first+n范围内的所有元素。 for_each: 用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。 generate: 连续调用输入的函数来填充指定的范围。 generate_n: 与generate函数类似，填充从指定iterator开始的n个元素。 transform: 将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。 &lt;七&gt;关系算法(8个) equal: 如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。 includes: 判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;操作符，成功返回true。重载版本使用用户输入的函数。 lexicographical_compare: 比较两个序列。重载版本使用用户自定义比较操作。 max: 返回两个元素中较大一个。重载版本使用自定义比较操作。 max_element: 返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。 min: 返回两个元素中较小一个。重载版本使用自定义比较操作。 min_element: 返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。 mismatch: 并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。 &lt;八&gt;集合算法(4个) set_union: 构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。 set_intersection: 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。 set_difference: 构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用自定义的比较操作。 set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。 &lt;九&gt;堆算法(4个) make_heap: 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。 pop_heap: 并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被”弹出”的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。 push_heap: 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。 sort_heap: 对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"STL","slug":"STL","permalink":"yongchunxiaofen.top/tags/STL/"}]},{"title":"智能指针简析","slug":"intelligent-pointer","date":"2016-08-21T08:42:15.000Z","updated":"2016-08-22T00:23:17.000Z","comments":true,"path":"2016/08/21/intelligent-pointer/","link":"","permalink":"yongchunxiaofen.top/2016/08/21/intelligent-pointer/","excerpt":"转自程序媛想事儿-C++智能指针简单剖析 导读最近在补看《C++ Primer Plus》第六版，这的确是本好书，其中关于智能指针的章节解析的非常清晰，一解我以前的多处困惑。C++面试过程中，很多面试官都喜欢问智能指针相关的问题，比如你知道哪些智能指针？shared_ptr的设计原理是什么？如果让你自己设计一个智能指针，你如何完成？等等……。而且在看开源的C++项目时，也能随处看到智能指针的影子。这说明智能指针不仅是面试官爱问的题材，更是非常有实用价值。 下面是我在看智能指针时所做的笔记，希望能够解决你对智能指针的一些困扰。 目录 智能指针背后的设计思想 C++智能指针简单介绍 为什么摒弃auto_ptr？ unique_ptr为何优于auto_ptr？ 如何选择智能指针？ 正文1. 智能指针背后的设计思想我们先来看一个简单的例子：12345678910void remodel(std::string &amp; str)&#123; std::string * ps = new std::string(str); ... if (weird_thing()) throw exception(); str = *ps; delete ps; return;&#125; 当出现异常时（weird_thing()返回true），delete将不被执行，因此将导致内存泄露。 如何避免这种问题？有人会说，这还不简单，直接在throw exception();之前加上delete ps;不就行了。是的，你本应如此，问题是很多人都会忘记在适当的地方加上delete语句（连上述代码中最后的那句delete语句也会有很多人忘记吧），如果你要对一个庞大的工程进行review，看是否有这种潜在的内存泄露问题，那就是一场灾难！ 这时我们会想：当remodel这样的函数终止（不管是正常终止，还是由于出现了异常而终止），本地变量都将自动从栈内存中删除—因此指针ps占据的内存将被释放，如果ps指向的内存也被自动释放，那该有多好啊。 我们知道析构函数有这个功能。如果ps有一个析构函数，该析构函数将在ps过期时自动释放它指向的内存。但ps的问题在于，它只是一个常规指针，不是有析构凼数的类对象指针。如果它指向的是对象，则可以在对象过期时，让它的析构函数删除指向的内存。 这正是 auto_ptr、unique_ptr和shared_ptr这几个智能指针背后的设计思想。我简单的总结下就是：将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。 因此，要转换remodel()函数，应按下面3个步骤进行： 包含头义件memory（智能指针所在的头文件）； 将指向string的指针替换为指向string的智能指针对象； 删除delete语句。 下面是使用auto_ptr修改该函数的结果：","text":"转自程序媛想事儿-C++智能指针简单剖析 导读最近在补看《C++ Primer Plus》第六版，这的确是本好书，其中关于智能指针的章节解析的非常清晰，一解我以前的多处困惑。C++面试过程中，很多面试官都喜欢问智能指针相关的问题，比如你知道哪些智能指针？shared_ptr的设计原理是什么？如果让你自己设计一个智能指针，你如何完成？等等……。而且在看开源的C++项目时，也能随处看到智能指针的影子。这说明智能指针不仅是面试官爱问的题材，更是非常有实用价值。 下面是我在看智能指针时所做的笔记，希望能够解决你对智能指针的一些困扰。 目录 智能指针背后的设计思想 C++智能指针简单介绍 为什么摒弃auto_ptr？ unique_ptr为何优于auto_ptr？ 如何选择智能指针？ 正文1. 智能指针背后的设计思想我们先来看一个简单的例子：12345678910void remodel(std::string &amp; str)&#123; std::string * ps = new std::string(str); ... if (weird_thing()) throw exception(); str = *ps; delete ps; return;&#125; 当出现异常时（weird_thing()返回true），delete将不被执行，因此将导致内存泄露。 如何避免这种问题？有人会说，这还不简单，直接在throw exception();之前加上delete ps;不就行了。是的，你本应如此，问题是很多人都会忘记在适当的地方加上delete语句（连上述代码中最后的那句delete语句也会有很多人忘记吧），如果你要对一个庞大的工程进行review，看是否有这种潜在的内存泄露问题，那就是一场灾难！ 这时我们会想：当remodel这样的函数终止（不管是正常终止，还是由于出现了异常而终止），本地变量都将自动从栈内存中删除—因此指针ps占据的内存将被释放，如果ps指向的内存也被自动释放，那该有多好啊。 我们知道析构函数有这个功能。如果ps有一个析构函数，该析构函数将在ps过期时自动释放它指向的内存。但ps的问题在于，它只是一个常规指针，不是有析构凼数的类对象指针。如果它指向的是对象，则可以在对象过期时，让它的析构函数删除指向的内存。 这正是 auto_ptr、unique_ptr和shared_ptr这几个智能指针背后的设计思想。我简单的总结下就是：将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。 因此，要转换remodel()函数，应按下面3个步骤进行： 包含头义件memory（智能指针所在的头文件）； 将指向string的指针替换为指向string的智能指针对象； 删除delete语句。 下面是使用auto_ptr修改该函数的结果： 1234567891011# include &lt;memory&gt;void remodel (std::string &amp; str)&#123; std::auto_ptr&lt;std::string&gt; ps (new std::string(str))； ... if (weird_thing ()) throw exception()； str = *ps； // delete ps； NO LONGER NEEDED return;&#125; 2. C++智能指针简单介绍STL一共给我们提供了四种智能指针：auto_ptr、unique_ptr、shared_ptr和weak_ptr（本文章暂不讨论）。 模板auto_ptr是C++98提供的解决方案，C+11已将将其摒弃，并提供了另外两种解决方案。然而，虽然auto_ptr被摒弃，但它已使用了好多年：同时，如果您的编译器不支持其他两种解决力案，auto_ptr将是唯一的选择。 使用注意点： 所有的智能指针类都有一个explicit构造函数，以指针作为参数。比如auto_ptr的类模板原型为： 12345templet&lt;class T&gt;class auto_ptr &#123; explicit auto_ptr(X* p = 0) ; ...&#125;; 因此不能自动将指针转换为智能指针对象，必须显式调用： 123456shared_ptr&lt;double&gt; pd; double *p_reg = new double;pd = p_reg; // not allowed (implicit conversion)pd = shared_ptr&lt;double&gt;(p_reg); // allowed (explicit conversion)shared_ptr&lt;double&gt; pshared = p_reg; // not allowed (implicit conversion)shared_ptr&lt;double&gt; pshared(p_reg); // allowed (explicit conversion) 对全部三种智能指针都应避免的一点： 12string vacation(\"I wandered lonely as a cloud.\");shared_ptr&lt;string&gt; pvac(&amp;vacation); // No pvac过期时，程序将把delete运算符用于非堆内存，这是错误的。 使用举例12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;class report&#123;private: std::string str;public: report(const std::string s) : str(s) &#123; std::cout &lt;&lt; \"Object created.\\n\"; &#125; ~report() &#123; std::cout &lt;&lt; \"Object deleted.\\n\"; &#125; void comment() const &#123; std::cout &lt;&lt; str &lt;&lt; \"\\n\"; &#125; &#125;;int main() &#123; &#123; std::auto_ptr&lt;report&gt; ps(new report(\"using auto ptr\")); ps-&gt;comment(); &#125; &#123; std::shared_ptr&lt;report&gt; ps(new report(\"using shared ptr\")); ps-&gt;comment(); &#125; &#123; std::unique_ptr&lt;report&gt; ps(new report(\"using unique ptr\")); ps-&gt;comment(); &#125; return 0;&#125; 3. 为什么摒弃auto_ptr？先来看下面的赋值语句: 123auto_ptr&lt; string&gt; ps (new string (\"I reigned lonely as a cloud.”）;auto_ptr&lt;string&gt; vocation; vocaticn = ps; 上述赋值语句将完成什么工作呢？如果ps和vocation是常规指针，则两个指针将指向同一个string对象。这是不能接受的，因为程序将试图删除同一个对象两次——一次是ps过期时，另一次是vocation过期时。要避免这种问题，方法有多种： 定义陚值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中的一个对象是另一个对象的副本，缺点是浪费空间，所以智能指针都未采用此方案。 建立所有权（ownership）概念。对于特定的对象，只能有一个智能指针可拥有，这样只有拥有对象的智能指针的构造函数会删除该对象。然后让赋值操作转让所有权。这就是用于auto_ptr和uniqiie_ptr 的策略，但unique_ptr的策略更严格。 创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1,。当减为0时才调用delete。这是shared_ptr采用的策略。 当然，同样的策略也适用于复制构造函数。每种方法都有其用途，但为何说要摒弃auto_ptr呢？下面举个例子来说明。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;using namespace std;int main() &#123; auto_ptr&lt;string&gt; films[5] = &#123; auto_ptr&lt;string&gt; (new string(\"Fowl Balls\")), auto_ptr&lt;string&gt; (new string(\"Duck Walks\")), auto_ptr&lt;string&gt; (new string(\"Chicken Runs\")), auto_ptr&lt;string&gt; (new string(\"Turkey Errors\")), auto_ptr&lt;string&gt; (new string(\"Goose Eggs\")) &#125;; auto_ptr&lt;string&gt; pwin; pwin = films[2]; // films[2] loses ownership. 将所有权从films[2]转让给pwin，此时films[2]不再引用该字符串从而变成空指针 cout &lt;&lt; \"The nominees for best avian baseballl film are\\n\"; for(int i = 0; i &lt; 5; ++i) cout &lt;&lt; *films[i] &lt;&lt; endl; cout &lt;&lt; \"The winner is \" &lt;&lt; *pwin &lt;&lt; endl; cin.get(); return 0;&#125; 运行下发现程序崩溃了，原因在上面注释已经说的很清楚，films[2]已经是空指针了，下面输出访问空指针当然会崩溃了。但这里如果把auto_ptr换成shared_ptr或unique_ptr后，程序就不会崩溃，原因如下： 使用shared_ptr时运行正常，因为shared_ptr采用引用计数，pwin和films[2]都指向同一块内存，在释放空间时因为事先要判断引用计数值的大小因此不会出现多次删除一个对象的错误。 使用unique_ptr时编译出错，与auto_ptr一样，unique_ptr也采用所有权模型，但在使用unique_ptr时，程序不会等到运行阶段崩溃，而在编译器因下述代码行出现错误： 12unique_ptr&lt;string&gt; pwin;pwin = films[2]; // films[2] loses ownership. 指导你发现潜在的内存错误。这就是为何要摒弃auto_ptr的原因，一句话总结就是：避免潜在的内存崩溃问题。 4. unique_ptr为何优于auto_ptr？可能大家认为前面的例子已经说明了unique_ptr为何优于auto_ptr，也就是安全问题，下面再叙述的清晰一点。 请看下面的语句: 123auto_ptr&lt;string&gt; p1(new string (\"auto\") ； //#1auto_ptr&lt;string&gt; p2; //#2p2 = p1; 在语句#3中，p2接管string对象的所有权后，p1的所有权将被剥夺。前面说过，这是好事，可防止p1和p2的析构函数试图刪同—个对象；但如果程序随后试图使用p1，这将是件坏事，因为p1不再指向有效的数据。 下面来看使用unique_ptr的情况： 123unique_ptr&lt;string&gt; p3 (new string (\"auto\"); //#4unique_ptr&lt;string&gt; p4； //#5p4 = p3; 编译器认为语句#6非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。 但unique_ptr还有更聪明的地方。有时候，会将一个智能指针赋给另一个并不会留下危险的悬挂指针。假设有如下函数定义： 12345unique_ptr&lt;string&gt; demo(const char * s)&#123; unique_ptr&lt;string&gt; temp (new string (s))； return temp；&#125; 并假设编写了如下代码： 12unique_ptr&lt;string&gt; ps;ps = demo('Uniquely special\")； demo()返回一个临时unique_ptr，然后ps接管了原本归返回的unique_ptr所有的对象，而返回时临时的 unique_ptr 被销毁，也就是说没有机会使用 unique_ptr 来访问无效的数据，换句话来说，这种赋值是不会出现任何问题的，即没有理由禁止这种赋值。实际上，编译器确实允许这种赋值，这正是unique_ptr更聪明的地方。 总之，当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如： 12345unique_ptr&lt;string&gt; pu1(new string (\"hello world\"));unique_ptr&lt;string&gt; pu2;pu2 = pu1; // #1 not allowedunique_ptr&lt;string&gt; pu3;pu3 = unique_ptr&lt;string&gt;(new string (\"You\")); // #2 allowed 其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。 当然，您可能确实想执行类似于#1的操作，仅当以非智能的方式使用摒弃的智能指针时（如解除引用时），这种赋值才不安全。要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。下面是一个使用前述demo()函数的例子，该函数返回一个unique_ptr对象：使用move后，原来的指针仍转让所有权变成空指针，可以对其重新赋值。 12345unique_ptr&lt;string&gt; ps1, ps2;ps1 = demo(\"hello\");ps2 = move(ps1);ps1 = demo(\"alexia\");cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl; 5. 如何选择智能指针？在掌握了这几种智能指针后，应使用哪种智能指针呢？ （1）如果程序要使用多个指向同一个对象的指针，应选择shared_ptr。这样的情况包括： 有一个指针数组，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素； 两个对象包含都指向第三个对象的指针； STL容器包含指针。 很多STL算法都支持复制和赋值操作，这些操作可用于shared_ptr，但不能用于unique_ptr（编译器发出warning）和auto_ptr（行为不确定）。如果你的编译器没有提供shared_ptr，可使用Boost库提供的shared_ptr。 （2）如果程序不需要多个指向同一个对象的指针，则可使用unique_ptr。如果函数使用new分配内存，并返还指向该内存的指针，将其返回类型声明为unique_ptr是不错的选择。这样，所有权转让给接受返回值的unique_ptr，而该智能指针将负责调用delete。可将unique_ptr存储到STL容器在那个，只要不调用将一个unique_ptr复制或赋给另一个算法（如sort()）。例如，可在程序中石油类似于下面的代码段。 123456789101112131415161718unique_ptr&lt;int&gt; make_int(int n)&#123; return unique_ptr&lt;int&gt;(new int(n));&#125;void show(unique_ptr&lt;int&gt; &amp;p1)&#123; cout &lt;&lt; *a &lt;&lt; ' ';&#125;int main()&#123; ... vector&lt;unique_ptr&lt;int&gt; &gt; vp(size); for(int i = 0; i &lt; vp.size(); i++) vp[i] = make_int(rand() % 1000); // copy temporary unique_ptr vp.push_back(make_int(rand() % 1000)); // ok because arg is temporary for_each(vp.begin(), vp.end(), show); // use for_each() ...&#125; 其中push_back调用没有问题，因为它返回一个临时unique_ptr，该unique_ptr被赋给vp中的一个unique_ptr。另外，如果按值而不是按引用给show()传递对象，for_each()将非法，因为这将导致使用一个来自vp的非临时unique_ptr初始化pi，而这是不允许的。前面说过，编译器将发现错误使用unique_ptr的企图。在unique_ptr为右值时，可将其赋给shared_ptr，这与将一个unique_ptr赋给一个需要满足的条件相同。与前面一样，在下面的代码中，make_int()的返回类型为unique_ptr： 123unique_ptr&lt;int&gt; pup(make_int(rand() % 1000)); // okshared_ptr&lt;int&gt; spp(pup); // not allowed, pup as lvalueshared_ptr&lt;int&gt; spr(make_int(rand() % 1000)); // ok 模板shared_ptr包含一个显式构造函数，可用于将右值unique_ptr转换为shared_ptr。shared_ptr将接管原来归unique_ptr所有的对象。在满足unique_ptr要求的条件时，也可使用auto_ptr，但unique_ptr是更好的选择。如果你的编译器没有unique_ptr，可考虑使用Boost库提供的scoped_ptr，它与unique_ptr类似。","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"智能指针","slug":"智能指针","permalink":"yongchunxiaofen.top/tags/智能指针/"}]},{"title":"腾讯研发编程题","slug":"Tencent-OJ-Seris","date":"2016-08-20T08:01:07.000Z","updated":"2016-08-20T08:03:16.000Z","comments":true,"path":"2016/08/20/Tencent-OJ-Seris/","link":"","permalink":"yongchunxiaofen.top/2016/08/20/Tencent-OJ-Seris/","excerpt":"","text":"1. 腾讯2016研发工程师编程题——微信红包 春节期间小明使用微信收到很多个红包，非常开心。在查看领取红包记录时发现，某个红包金额出现的次数超过了红包总数的一半。请帮小明找到该红包金额。写出具体算法思路和代码实现，要求算法尽可能高效。给定一个红包的金额数组gifts及它的大小n，请返回所求红包的金额。若没有金额超过总数的一半，返回0。 测试样例： [1,2,3,2,2],5 返回： 2 代码： 12345678910int getValue(vector&lt;int&gt; gifts, int n) &#123; for (vector&lt;int&gt;::iterator it = gifts.begin(); it != gifts.end(); it++) &#123; int temp = count(gifts.begin(), gifts.end(), *it); if (temp &gt; gifts.size() / 2) return *it; &#125; return 0; &#125;","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"查找","slug":"查找","permalink":"yongchunxiaofen.top/tags/查找/"}]},{"title":"华为OJ系列（三）","slug":"HuaWei-OJ-Seris-03","date":"2016-08-18T07:15:48.000Z","updated":"2016-09-05T07:52:36.000Z","comments":true,"path":"2016/08/18/HuaWei-OJ-Seris-03/","link":"","permalink":"yongchunxiaofen.top/2016/08/18/HuaWei-OJ-Seris-03/","excerpt":"1. 【中级】单词倒排题目描述 对字符串中的所有单词进行倒排。说明：1、每个单词是以26个大写或小写英文字母构成；2、非构成单词的字符均视为单词间隔符；3、要求倒排后的单词间隔符以一个空格表示；如果原字符串中相邻单词间有多个间隔符时，倒排转换后也只允许出现一个空格间隔符；4、每个单词最长20个字母； 输入描述: 输入一行以空格来分隔的句子 输出描述: 输出句子的逆序 输入例子: I am a student 输出例子: student a am I 思路分析： 使用getline(cin,str)输入字符串 判断字符串中的每个字符，将非字母转换成空格字符 包括空格也进行转换 设定一个游标k = 0，while(str[k] == &apos; &apos;) { ++ k; } 使得k指向开头不为空的第一个字符 同理，设定一个游标 j = str.size() -1指向字符串的最后一个字符 while(str[j] == &apos; &apos;) { --j ;} 使得j指向结尾最后一个不为空字符的字符 当在j 和k之间遍历时，考虑中间为多个空格的情况 对开头的第一个单词，单独进行输出 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;void RevertSentence(string str)&#123; for (string::size_type i = 0; i &lt; str.size(); i++) //将非字母转换为空格 &#123; if ((str[i]&lt;'a' &amp;&amp; str[i]&gt;'Z') || str[i] &gt; 'z' || str[i] &lt; 'A') str[i] = ' '; &#125; int j = str.size() - 1; while (str[j] == ' ') &#123; j--; //使得遍历从后边不为空格的第一个字母开始 &#125; int k = 0; while (str[k] == ' ') &#123; ++k; //使得遍历从开头不为空格的第一个字母开始 &#125; for (int i = j; i &gt;= k; i--) &#123; if (str[i] == ' ') &#123; for (int i1 = i + 1; i1 &lt;= j; i1++) cout &lt;&lt; str[i1]; cout &lt;&lt; \" \"; j = i - 1; while (str[j] == ' ') //去掉中间多余的空格 &#123; --i; --j; &#125; &#125; &#125; for (int i = k; i &lt;= j; i++) &#123; cout &lt;&lt; str[i]; &#125; cout &lt;&lt; endl;&#125;int main()&#123; string str; getline(cin, str); RevertSentence(str); return 0;&#125;","text":"1. 【中级】单词倒排题目描述 对字符串中的所有单词进行倒排。说明：1、每个单词是以26个大写或小写英文字母构成；2、非构成单词的字符均视为单词间隔符；3、要求倒排后的单词间隔符以一个空格表示；如果原字符串中相邻单词间有多个间隔符时，倒排转换后也只允许出现一个空格间隔符；4、每个单词最长20个字母； 输入描述: 输入一行以空格来分隔的句子 输出描述: 输出句子的逆序 输入例子: I am a student 输出例子: student a am I 思路分析： 使用getline(cin,str)输入字符串 判断字符串中的每个字符，将非字母转换成空格字符 包括空格也进行转换 设定一个游标k = 0，while(str[k] == &apos; &apos;) { ++ k; } 使得k指向开头不为空的第一个字符 同理，设定一个游标 j = str.size() -1指向字符串的最后一个字符 while(str[j] == &apos; &apos;) { --j ;} 使得j指向结尾最后一个不为空字符的字符 当在j 和k之间遍历时，考虑中间为多个空格的情况 对开头的第一个单词，单独进行输出 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;void RevertSentence(string str)&#123; for (string::size_type i = 0; i &lt; str.size(); i++) //将非字母转换为空格 &#123; if ((str[i]&lt;'a' &amp;&amp; str[i]&gt;'Z') || str[i] &gt; 'z' || str[i] &lt; 'A') str[i] = ' '; &#125; int j = str.size() - 1; while (str[j] == ' ') &#123; j--; //使得遍历从后边不为空格的第一个字母开始 &#125; int k = 0; while (str[k] == ' ') &#123; ++k; //使得遍历从开头不为空格的第一个字母开始 &#125; for (int i = j; i &gt;= k; i--) &#123; if (str[i] == ' ') &#123; for (int i1 = i + 1; i1 &lt;= j; i1++) cout &lt;&lt; str[i1]; cout &lt;&lt; \" \"; j = i - 1; while (str[j] == ' ') //去掉中间多余的空格 &#123; --i; --j; &#125; &#125; &#125; for (int i = k; i &lt;= j; i++) &#123; cout &lt;&lt; str[i]; &#125; cout &lt;&lt; endl;&#125;int main()&#123; string str; getline(cin, str); RevertSentence(str); return 0;&#125; 2. 字符串运用-密码截取题目描述 Catcher是MCA国的情报员，他工作时发现敌国会用一些对称的密码进行通信，比如像这些ABBA，ABA，A，123321，但是他们有时会在开始或结束时加入一些无关的字符以防止别国破解。比如进行下列变化 ABBA-&gt;12ABBA,ABA-&gt;ABAKK,123321-&gt;51233214 。因为截获的串太长了，而且存在多种可能的情况（abaaab可看作是aba,或baaab的加密形式），Cathcer的工作量实在是太大了，他只能向电脑高手求助，你能帮Catcher找出最长的有效密码串吗？ 输入描述: 输入一个字符串 输出描述: 返回有效密码串的最大长度 输入例子: ABBA 输出例子: 4 解题思路： 设定两个指针，一个指针i从字符串开始处向后遍历 另一个指针j从字符串末尾开始向前遍历，j遍历的判断条件是j&gt;i 如果i和j对应的字符相同 则判断其之间的字符是否相同 其中有两种情况 一种是奇数个对称（ABCBA），另一个是偶数个对称（ABBA） 两种情况都要考虑 这样会将所有的对称的字符的个数都会计算出来 并且将其存储到vector中 所有的字符遍历完毕之后 对vector中的int排序 输出vector中最后一个数，即为密码串的最大长度 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using std::sort;using std::vector;using std::cin;using std::cout;using std::endl;using std::string;void CalculateLength(string str)&#123; int last = str.size() -1 ; vector&lt;int&gt;ivec; for (string::size_type i = 0; i &lt; last -1; i++) &#123; //string::size_type k =i+1; for (string::size_type j = last; j &gt; i; j--) &#123; if (str[i] == str[j]) &#123; int k = 1; if (i + 1 == j) //内层相邻 &#123; ivec.push_back(2 * k); break; &#125; if (i + 2 == j) &#123; ivec.push_back(2 * k + 1); break; &#125; while (str[i + k] == str[j - k]) &#123; if (i + k + 1 == j - k) //相邻对称 总和=2（k+1） &#123; ivec.push_back(2 * (k + 1)); break; &#125; if (i + k + 2 == j - k) //不相邻对称 总和 = 2（k+1）+1 &#123; ivec.push_back(2 * (k + 1) + 1); break; &#125; ++k; &#125; &#125; &#125; &#125; vector&lt;int&gt;::iterator it = ivec.end(); sort(ivec.begin(), it); cout &lt;&lt; *(it-1) &lt;&lt; endl;&#125;int main()&#123; string str; while (getline(cin, str)) &#123; CalculateLength(str); &#125; return 0;&#125; 3. 整数与IP地址间的转换题目描述 原理：ip地址的每段可以看成是一个0-255的整数，把每段拆分成一个二进制形式组合起来，然后把这个二进制数转变成一个长整数。 举例： 一个ip地址为10.0.3.193每段数字 相对应的二进制数10 000010100 000000003 00000011193 11000001组合起来即为：00001010 00000000 00000011 11000001,转换为10进制数就是：167773121，即该IP地址转换后的数字就是它了。 的每段可以看成是一个0-255的整数，需要对IP地址进行校验 输入描述:输入 1 输入IP地址2 输入10进制型的IP地址 输出描述:输出 1 输出转换成10进制的IP地址2 输出转换后的IP地址 输入例子: 10.0.3.193167969729 输出例子: 16777312110.3.3.193 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#include&lt;cmath&gt;using std::stack;using std::sort;using std::vector;using std::cin;using std::cout;using std::endl;using std::string;int CharToInt(char ch) //数字字符转换十进制&#123; return ch - '0';&#125;vector&lt;long&gt;ivecsum; //设为全局变量void IntToBi(long sum) //将单个的十进制的IP转换为二进制&#123; //vector&lt;long&gt;ivecsum; stack&lt;long&gt;istack; while (sum) &#123; long temp = sum % 2; sum /= 2; istack.push(temp); &#125; if (istack.size() &lt; 8) &#123; for (int i = istack.size(); i &lt; 8; i++) istack.push(0); &#125; while (!istack.empty()) &#123; ivecsum.push_back(istack.top()); istack.pop(); &#125;&#125;void TransToInt(string str) //将十进制IP转换成一个长整型&#123; vector&lt;long&gt;ivec; int j = 0; ivecsum.clear(); //第二次调用时，清空全局的容器 for (string::size_type i = 0; i &lt; str.size(); i++) &#123; long sum = 0; if (str[i] == '.') &#123; for (int k = i-1; k &gt;= j; k--) sum = sum + CharToInt(str[k])*pow(10, i-k-1); j = i + 1; ivec.push_back(sum); &#125; &#125; //单独处理最后一个 long sum1 = 0; int length = str.size(); for (int ii = length - 1; ii &gt;= j; ii--) sum1 = sum1 + CharToInt(str[ii]) *pow(10, length - 1 - ii); ivec.push_back(sum1); for (int i = 0; i &lt; 4; i++) &#123; if (ivec[i] &lt;= 255 &amp;&amp; ivec[i] &gt;= 0) IntToBi(ivec[i]); else return; &#125; long sumsum = 0; for (int i = 31; i &gt;= 0; i--) &#123; sumsum = sumsum + ivecsum[i] * pow(2, 32 - i - 1); &#125; cout &lt;&lt; sumsum &lt;&lt; endl;&#125;void TransToBi(long number) //将长整型转换成带分隔符的类型&#123; vector&lt;int&gt;ivec1; stack&lt;int&gt;istack1; while (number) &#123; int tempp = number % 2; istack1.push(tempp); number /= 2; &#125; if (istack1.size() &lt; 32) &#123; for (int i = istack1.size(); i &lt; 32; i++) &#123; istack1.push(0); &#125; &#125; while (!istack1.empty()) &#123; ivec1.push_back(istack1.top()); istack1.pop(); &#125; int num = 0; int j = 0; //结尾位置 vector&lt;int&gt;IvecResult; for (int i = 0; i &lt; 32; i++) &#123; ++num; int sum = 0; if (num == 8) &#123; j = i+1; for (int kk = j - 8,k1 = 0; kk &lt; j, k1 &lt; 8; kk++, k1++) &#123; sum = sum + ivec1[kk] * pow(2, 7 - k1); &#125; num = 0; IvecResult.push_back(sum); &#125; &#125; for (int i = 0; i &lt; 3; i++) &#123; cout &lt;&lt; IvecResult[i] &lt;&lt; \".\"; &#125; cout &lt;&lt; IvecResult[3] &lt;&lt; endl;&#125;int main()&#123; string str1; long number; while (cin &gt;&gt; str1 &gt;&gt; number) &#123; TransToInt(str1); TransToBi(number); &#125; return 0;&#125; 4. 及格线描述： 10个学生考完期末考试评卷完成后，A老师需要划出及格线，要求如下：(1) 及格线是10的倍数；(2) 保证至少有60%的学生及格；(3) 如果所有的学生都高于60分，则及格线为60分 输入： 输入10个整数，取值0~100 输出： 输出及格线，10的倍数 输入样例： 61 51 49 3020 10 70 80 90 99 输出样例： 50 思路分析： 输入十个数之后，对数字存储到vector中进行排序 要保证60%的学生及格，即6个学生 所以判断排序之后第6个学生的成绩 代码：123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void PassLine(int a)&#123; int passline=0; vector&lt;int&gt;ivec; for (int i = 0; i &lt; a; i++) &#123; int temp; cin &gt;&gt; temp; ivec.push_back(temp); //将输入的十个数存入ivec中 &#125; sort(ivec.begin(), ivec.end()); int temp1 = ivec[4]; if (temp1 &gt;= 60) passline = 60; else passline = temp1 - temp1 % 10; cout &lt;&lt; passline;&#125;int main()&#123; int a = 10; PassLine(a); return 0;&#125; 5. 蛇形矩阵题目描述 题目说明 蛇形矩阵是由1开始的自然数依次排列成的一个矩阵上三角形。 样例输入5样例输出1 3 6 10 152 5 9 144 8 137 1211 输入描述: 输入正整数N（N不大于100） 输出描述: 输出一个N行的蛇形矩阵。 输入例子: 4 输出例子: 1 3 6 102 5 94 87 思路分析： 新建一N行N列的二维数组，用来存放蛇形矩阵 根据蛇形矩阵的规律，先遍历将第1列的值计算出来 设外层遍历索引为i，内层遍历索引为j 则i为[0,N)，j的范围为[1，N) 根据蛇形矩阵的规律，有如下关系式： ivec[i][j] = ivec[i][j - 1] + i + 1 + j; 计算出矩阵中的各个数 此时计算出来的数并不是蛇形矩阵，而是一个N行N列的矩阵 蛇形矩阵在输出时体现， 将N的值赋值给M 外层循环i的值为0到M 内存循环每执行完一个j时，N执行--操作 另外注意输出的空格，每一行的数字之间是用空格来间隔的 但是每一行的第一个数字之前和最后一个数字之后是没有空格的。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;vector&gt;using std::vector;using std::cin;using std::cout;using std::endl;void Matrix(int N)&#123; vector&lt;vector&lt;int&gt;&gt;ivec(N); for (int i = 0; i &lt; N; i++) &#123; ivec[i].resize(N); //建立一个N*N的二维数组；实际的数组维度 &#125; ivec[0][0] = 1; for (int j = 0; j &lt; 1; j++) &#123; for (int i = 1; i &lt; N; i++) &#123; ivec[i][0] = ivec[i-1][0] + i; &#125; &#125; for (int i = 0; i &lt; N; i++) &#123; for (int j = 1; j &lt; N; j++) &#123; ivec[i][j] = ivec[i][j - 1] + i + 1 + j; &#125; &#125; int M = N; for (int i = 0; i &lt; M; i++) &#123; cout &lt;&lt; ivec[i][0]; for (int j = 1; j &lt; N; j++) &#123; cout &lt;&lt; \" \"&lt;&lt;ivec[i][j]; //空格是在数字之间，最后一个数字之后不能有空格 &#125; cout &lt;&lt; endl; --N; &#125; &#125;int main()&#123; int Number; while (cin&gt;&gt;Number ) &#123; if (Number&gt;=1 &amp;&amp; Number &lt;=100) &#123; Matrix(Number); &#125; &#125; return 0;&#125; 6. 字符串加密题目描述 有一种技巧可以对数据进行加密，它使用一个单词作为它的密匙。下面是它的工作原理：首先，选择一个单词作为密匙，如TRAILBLAZERS。如果单词中包含有重复的字母，只保留第1个，其余几个丢弃。现在，修改过的那个单词死于字母表的下面，如下所示：A B C D E F G H I J K L M N O P Q R S T U V W X Y ZT R A I L B Z E S C D F G H J K M N O P Q U V W X Y上面其他用字母表中剩余的字母填充完整。在对信息进行加密时，信息中的每个字母被固定于顶上那行，并用下面那行的对应字母一一取代原文的字母(字母字符的大小写状态应该保留)。因此，使用这个密匙，Attack AT DAWN(黎明时攻击)就会被加密为Tpptad TP ITVH。 输入描述: 先输入key和要加密的字符串 输出描述: 返回加密后的字符串 输入例子: nihaoni 输出例子: le 思路分析： 将输入转换成大写运行计算 输出的时候再将对应的小写转换成大写 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;map&gt;using std::map;using std::string;using std::vector;using std::cin;using std::cout;using std::endl;using std::pair;void AddKey(string Key,string WaitToKey)&#123; //将Key全部转换成大写 for (string::size_type i = 0; i &lt; Key.size(); i++) &#123; if (Key[i] &lt;= 'z' &amp;&amp; Key[i] &gt;= 'a') Key[i] = Key[i] - 32; &#125; //对Key去重 int length = Key.size(); for (string::size_type i = 0; i &lt; length-1; i++) &#123; for (string::size_type j = length - 1; j &gt; i; j--) &#123; if (Key[i] == Key[j]) Key[j] = '0'; &#125; &#125; vector&lt;char&gt;ivec; for (string::size_type i = 0; i &lt; Key.size(); i++) &#123; if (Key[i] != '0') ivec.push_back(Key[i]); &#125; //加上余下的字母 for (string::size_type i = 0; i &lt; Key.size(); i++) &#123; if (Key[i] &lt;= 'z' &amp;&amp; Key[i] &gt;= 'a') &#123; toupper(Key[i]); &#125; &#125; for (int i = 0; i &lt; 26; i++) &#123; ivec.push_back('A' + i); &#125; for (int i = 0; i &lt; ivec.size() - 1; i++) &#123; for (int j = ivec.size() - 1; j &gt; i; j--) &#123; if (ivec[i] == ivec[j]) ivec[j] = '0'; &#125; &#125; vector&lt;char&gt;ivec1; for (int i = 0; i &lt; ivec.size(); i++) &#123; if (ivec[i] != '0') ivec1.push_back(ivec[i]); &#125; //加上余下的字母——完毕 //构造关于key和明文的map map&lt;char,char&gt;imap; for (int i = 0; i &lt; 26; i++) &#123; imap.insert(pair&lt;char, char&gt;(ivec1[i], 'A' + i)); &#125; string temp; for (string::size_type i = 0; i &lt; WaitToKey.size(); i++) &#123; //如果明文是小写字符，将其转换成大写，输出时再转换成对应的小写 if (WaitToKey[i] &lt;= 'z' &amp;&amp; WaitToKey[i] &gt;= 'a') &#123; WaitToKey[i] = WaitToKey[i] - 32; //将输入转换成大写 for (map&lt;char, char&gt;::iterator it = imap.begin(); it != imap.end();it++) &#123; if (WaitToKey[i] == it-&gt;second) printf(\"%c\",(it-&gt;first) +32); &#125; continue; &#125; if (WaitToKey[i] &lt;= 'Z' &amp;&amp; WaitToKey[i] &gt;= 'A') &#123; for (map&lt;char, char&gt;::iterator it = imap.begin(); it != imap.end(); it++) &#123; if (WaitToKey[i] == it-&gt;second) printf(\"%c\", it-&gt;first); &#125; &#125; &#125; cout &lt;&lt; endl; &#125;int main()&#123; string str1, str2; while (cin &gt;&gt; str1 &gt;&gt; str2) &#123; AddKey(str1, str2); &#125; return 0;&#125; 7. 统计每个月兔子的总数题目描述 有一只兔子，从出生后第3个月起每个月都生一只兔子，小兔子长到第三个月后每个月又生一只兔子，假如兔子都不死，问每个月的兔子总数为多少？ 输入描述: 输入int型表示month 输出描述: 输出兔子总数int型 输入例子: 9 输出例子: 34 思路分析： 归纳总结出递归 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using std::cin;using std::cout;using std::endl;int NumberOfRabbits(int N)&#123; if(N&lt;=0) cout&lt;&lt;\"Error Input!\"&lt;&lt;endl; int num[2]=&#123;1,1&#125;; if(N&lt;=2) return num[N-1]; else return NumberOfRabbits(N-1) + NumberOfRabbits(N-2); &#125;int main()&#123; int Number; while(cin&gt;&gt;Number) &#123; cout &lt;&lt; NumberOfRabbits(Number)&lt;&lt;endl; &#125; return 0;&#125; 8. 求小球落地5次后所经历的路程和第5次反弹的高度题目描述 假设一个球从任意高度自由落下，每次落地后反跳回原高度的一半; 再落下, 求它在第5次落地时，共经历多少米?第5次反弹多高？ 输入描述: 输入起始高度，int型 输出描述: 分别输出第5次落地时，共经过多少米第5次反弹多高 输入例子: 1 输出例子: 2.8750.03125 思路分析： 第n次反弹的高度为double H = height*pow(0.5, n); //第五次反弹的高度 代码：123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;void HeightOfBall(double height)&#123; double sum = 0; double H = height*pow(0.5, 5); //第五次反弹的高度 for (int i = 0; i &lt; 5; i++) &#123; sum = sum + height*pow(0.5, i) * 2 ; //用每次的高度乘以2 //在最后的结果中再减去一个初始高度 &#125; cout &lt;&lt; sum - height &lt;&lt; endl; cout &lt;&lt; H &lt;&lt; endl;&#125;int main()&#123; double height; while (cin &gt;&gt; height) &#123; HeightOfBall(height); &#125; return 0;&#125; 9. 字符串匹配（字符匹配）题目描述 题目标题：判断短字符串中的所有字符是否在长字符串中全部出现 输入描述: 输入两个字符串。第一个为短字符，第二个为长字符。 输出描述: 返回值： 输入例子: bcabc 输出例子: true 思路分析 注意理解本题目的意思，判断短字符串中的字符是否全部在长字符串中出现 是单个的字符匹配，而不是字符串匹配。 假设两个字符串分别为ShortStr，LongStr 不能使用Longstr.find(ShortStr)==string::npos的方法来判断 不过可以遍历短字符串中的每个字符 利用string.find()函数查找是否对应出现 12345678910111213141516171819202122232425262728#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;bool PiPei(string ShortStr, string LongStr)&#123; for (string::size_type i = 0; i &lt; ShortStr.size(); i++) //遍历短串中的每个字符 &#123; if (LongStr.find(ShortStr[i]) == string::npos) //如果其中一个在长串中不存在，则返回，并输出false &#123; return false; &#125; &#125; return true;&#125;int main()&#123; string str1, str2; while (cin&gt;&gt;str1&gt;&gt;str2) &#123; if (PiPei(str1, str2)) cout &lt;&lt; \"true\" &lt;&lt; endl; else cout &lt;&lt; \"false\" &lt;&lt; endl; &#125; return 0;&#125; 10. 数组中出现次数超过一半的数字题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 思路分析： map&lt;key,value&gt;imap中的key和value分别表示关键词以及其对应的值。 在本题中，遍历vector中的值，将其一个个存入map，如果之前没有则新加入map，如果之前有则对value进行++操作 遍历vector中的数组，有imap[numbers[i]]++ 遍历完毕之后，map中的key表示关键词，而value则表示的是关键词出现的数量。 只要it-&gt;second大于长度的一半即输出it-&gt;first 代码示例： 12345678910111213141516171819int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if (numbers.empty()) return 0; map&lt;int,int&gt;imap; int len = numbers.size(); for(int i=0;i&lt;len;i++) &#123; imap[numbers[i]]++; //将numbers中的值存入imap &#125; map&lt;int,int&gt;::iterator it; for(it=imap.begin();it!=imap.end();++it) &#123; if(it-&gt;second &gt; len/2) return it-&gt;first; &#125; return 0; &#125;","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"华为OJ","slug":"华为OJ","permalink":"yongchunxiaofen.top/tags/华为OJ/"}]},{"title":"华为OJ系列（二）","slug":"HuaWei-OJ-Seris-02","date":"2016-08-15T06:48:13.000Z","updated":"2016-08-18T02:00:25.000Z","comments":true,"path":"2016/08/15/HuaWei-OJ-Seris-02/","link":"","permalink":"yongchunxiaofen.top/2016/08/15/HuaWei-OJ-Seris-02/","excerpt":"1. 字符逆序题目描述 将一个字符串str的内容颠倒过来，并输出。str的长度不超过100个字符。 如：输入“I am a student”，输出“tneduts a ma I”。 输入参数： inputString：输入的字符串 返回值： 输出转换好的逆序字符串 输入描述: 输入一个字符串，可以有空格 输出描述: 输出逆序的字符串 输入例子: I am a student 输出例子: tneduts a ma I 思路分析： 对string字符串从后往前遍历输出即可 代码：123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;string&gt;using std::string;using std::cin;using std::cout;using std::endl;void RevertChar(string str)&#123; for (int i = str.size()-1; i &gt;=0; i--) &#123; cout &lt;&lt; str[i]; &#125; cout &lt;&lt; endl;&#125;int main()&#123; char ch[100]; gets_s(ch); RevertChar(ch); return 0;&#125;","text":"1. 字符逆序题目描述 将一个字符串str的内容颠倒过来，并输出。str的长度不超过100个字符。 如：输入“I am a student”，输出“tneduts a ma I”。 输入参数： inputString：输入的字符串 返回值： 输出转换好的逆序字符串 输入描述: 输入一个字符串，可以有空格 输出描述: 输出逆序的字符串 输入例子: I am a student 输出例子: tneduts a ma I 思路分析： 对string字符串从后往前遍历输出即可 代码：123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;string&gt;using std::string;using std::cin;using std::cout;using std::endl;void RevertChar(string str)&#123; for (int i = str.size()-1; i &gt;=0; i--) &#123; cout &lt;&lt; str[i]; &#125; cout &lt;&lt; endl;&#125;int main()&#123; char ch[100]; gets_s(ch); RevertChar(ch); return 0;&#125; 2. 求最小公倍数题目描述 正整数A和正整数B 的最小公倍数是指 能被A和B整除的最小的正整数值，设计一个算法，求输入A和B的最小公倍数。 输入描述: 输入两个正整数A和B。 输出描述: 输出A和B的最小公倍数。 输入例子: 57 输出例子: 35 思路分析： 从输入的两个数中较大的一个数开始遍历，直到两个数的乘积为止 如果当前数%输入的两个数的结果都为0，那么这个数即为所求 输出当前数之后，break结束遍历 代码：12345678910111213141516171819202122#include&lt;iostream&gt;void SomeNumber(int a, int b)&#123; int j = (a&gt;b ? a : b); for (int i = (a&gt;b ? a : b); i &lt;= (b*a); i++) &#123; if (i % a == 0 &amp;&amp; i % b == 0) &#123; std::cout &lt;&lt; i; break; &#125; &#125; std::cout &lt;&lt; std::endl;&#125;int main()&#123; int A, B; std::cin &gt;&gt; A &gt;&gt; B; SomeNumber(A, B); return 0;&#125; 3. 字串的连接最长路径查找题目描述 给定n个字符串，请对n个字符串按照字典序排列。 输入描述: 输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。 输出描述: 数据输出n行，输出结果为按照字典序排列的字符串。 输入例子: 9captocatcardtwotooupboatboot 输出例子: boatbootcapcardcattotootwoup 思路分析： 将输入的字符串存入vector容器中 利用algorithm中的sort进行自动排序 再输出 代码： 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using std::string;using std::cin;using std::cout;using std::endl;using std::sort;using std::vector;void CharLength(int length)&#123; vector&lt;string&gt;ivec; string str; for (int i = 0; i &lt; length; i++) &#123; cin &gt;&gt; str; ivec.push_back(str); &#125; sort(ivec.begin(), ivec.end()); for (int i = 0; i &lt; length; i++) &#123; cout &lt;&lt; ivec[i] &lt;&lt; endl; &#125; &#125;int main()&#123; int length; cin &gt;&gt; length; CharLength(length); return 0;&#125; 4. 求int型数据在内存中存储时1的个数题目描述 输入一个int型数据，计算出该int型数据在内存中存储时1的个数。 输入描述: 输入一个整数（int类型） 输出描述: 这个数转换成2进制后，输出1的个数 输入例子: 5 输出例子: 2 思路分析： 记得以前做选择题的时候，对一个整数x做如下运算 x &amp; (x-1) 可以一位一位地消灭x的二进制的1 而 x | x+1 可以一位一位地消灭x的二进制位的0 而本代码正是利用了这种算法来计算1的个数。 代码：1234567891011121314#include&lt;iostream&gt;int main()&#123; int x; std::cin &gt;&gt; x; int number = 0; while (x) &#123; x = x &amp; (x-1) ; number ++; &#125; std::cout &lt;&lt; number &lt;&lt; std::endl;&#125; 5. 简单密码题目描述 密码是我们生活中非常重要的东东，我们的那么一点不能说的秘密就全靠它了。哇哈哈. 接下来渊子要在密码之上再加一套密码，虽然简单但也安全。 假设渊子原来一个BBS上的密码为zvbo9441987,为了方便记忆，他通过一种算法把这个密码变换成YUANzhi1987，这个密码是他的名字和出生年份，怎么忘都忘不了，而且可以明目张胆地放在显眼的地方而不被别人知道真正的密码。 他是这么变换的，大家都知道手机上的字母： 1–1， abc–2, def–3, ghi–4, jkl–5, mno–6, pqrs–7, tuv–8 wxyz–9, 0–0,就这么简单，渊子把密码中出现的小写字母都变成对应的数字，数字和其他的符号都不做变换， 声明：密码中没有空格，而密码中出现的大写字母则变成小写之后往后移一位，如：X，先变成小写，再往后移一位，不就是y了嘛，简单吧。记住，z往后移是a哦。 输入描述: 输入包括多个测试数据。输入是一个明文，密码长度不超过100个字符，输入直到文件结尾 输出描述: 输出渊子真正的密文 输入例子: YUANzhi1987 输出例子: zvbo9441987 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;void SimpleKey(string str)&#123; for (int i = 0; i &lt; str.size(); i++) &#123; if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') cout &lt;&lt; str[i]; if (str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'c') cout &lt;&lt; 2; if (str[i] &gt;= 'd' &amp;&amp; str[i] &lt;= 'f') cout &lt;&lt; 3; if (str[i] &gt;= 'g' &amp;&amp; str[i] &lt;= 'i') cout &lt;&lt; 4; if (str[i] &gt;= 'j' &amp;&amp; str[i] &lt;= 'l') cout &lt;&lt; 5; if (str[i] &gt;= 'm' &amp;&amp; str[i] &lt;= 'o') cout &lt;&lt; 6; if (str[i] &gt;= 'p' &amp;&amp; str[i] &lt;= 's') cout &lt;&lt; 7; if (str[i] &gt;= 't' &amp;&amp; str[i] &lt;= 'v') cout &lt;&lt; 8; if (str[i] &gt;= 'w' &amp;&amp; str[i] &lt;= 'z') cout &lt;&lt; 9; if (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') &#123; str[i] = str[i] + 32 ; //将大写转换成小写 if (str[i] == 'z') //如果转换后为z， &#123; str[i] = 'a'-1; &#125; str[i] = str[i] + 1; //转换成小写之后往后移动一位 cout &lt;&lt; str[i]; &#125; &#125; cout &lt;&lt; endl;&#125;int main()&#123; char ch[100]; while (cin &gt;&gt; ch) &#123; SimpleKey(ch); &#125; return 0;&#125; 6. 汽水瓶题目描述 有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？ 输入描述: 输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1&lt;=n&lt;=100），表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。 输出描述: 对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。 输入例子: 310810 输出例子: 1540 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;iterator&gt;using std::iterator;using std::vector;using std::cin;using std::cout;using std::endl;void EmptyCan(vector&lt;int&gt;ivec)&#123; vector&lt;int&gt;::iterator it; int temp, temp1, temp2; for (vector&lt;int&gt;::iterator it = ivec.begin(); it != ivec.end(); it++) &#123; temp = *it; int sum = 0; while (temp &gt; 1) &#123; if (temp &gt; 2) &#123; temp1 = temp / 3;//第一次兑换得到temp1瓶汽水 temp2 = temp % 3;//第一次兑换剩下的空瓶子的数量， //此时，已经兑换了temp1瓶汽水，手里还剩temp1 + temp2个瓶子 sum = sum + temp1; //3 + 1 //cout &lt;&lt; sum &lt;&lt; endl; temp = temp1 + temp2; //更新瓶子的数量 &#125; if (temp == 2) &#123; sum += 1; //cout &lt;&lt; sum &lt;&lt; endl; break; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125;&#125;int main()&#123; int Input; vector&lt;int&gt;ivec; while (cin&gt;&gt;Input) &#123; if (Input == 0) break; //n==0时表示输入结束 ivec.push_back(Input); &#125; EmptyCan(ivec); return 0;&#125; 7. 删除字符串中出现次数最少的字符题目描述 实现删除字符串中出现次数最少的字符，若多个字符出现次数一样，则都删除。输出删除这些单词后的字符串，字符串中其它字符保持原来的顺序。 输入描述: 字符串只包含小写英文字母, 不考虑非法输入，输入的字符串长度小于等于20个字节。 输出描述: 删除字符串中出现次数最少的字符后的字符串。 输入例子: abcdd 输出例子: dd 解题思路： 从前往后两两比较两个字符是否相等， 内外层遍历序号分别为i，j 如果两个字符相等，则将外层序号对应的字符存入vector中 外层i的遍历是从第1个字符到倒数第一个字符 内存j的遍历是从第1个字符到最后一个字符 将ivec[i]存入vector的条件是 i != j &amp;&amp; ivec[i] == ivec[j] 存入之后，break退出当前j 最后对最后一个字符补充判断 如果前边有一个和最后一个字符相等 将最后一个字符也存入ivec中，并break 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using std::vector;using std::string;using std::cin;using std::cout;using std::endl;void DeleteChar(string str)&#123; vector&lt;char&gt;ivec; char a; for (int i = 0; i &lt; str.size() - 1; i++) &#123; for (int j = 0 ; j &lt; str.size(); j++) &#123; a = str[i]; if (i != j &amp;&amp; a == str[j]) &#123; ivec.push_back(str[i]); break; &#125; &#125; &#125; for (int i = 0; i &lt; str.size() - 1; i++) //对最后一个字符补充判断 &#123; if (str[i] == str[str.size() - 1]) &#123; ivec.push_back(str[str.size() - 1]); break; &#125; &#125; for (int i = 0; i &lt; ivec.size(); i++) &#123; cout &lt;&lt; ivec[i]; &#125; cout &lt;&lt; endl; &#125;int main()&#123; char ch[20]; while (cin &gt;&gt; ch) &#123; DeleteChar(ch); &#125; return 0;&#125; 8. 加强版字符串排序题目描述 编写一个程序，将输入字符串中的字符按如下规则排序。规则1：英文字母从A到Z排列，不区分大小写。 如，输入：Type 输出：epTy 规则2：同一个英文字母的大小写同时存在时，按照输入顺序排列。 如，输入：BabA 输出：aABb 规则3：非英文字母的其它字符保持原来的位置。 如，输入：By?e 输出：Be?y 样例： 输入： A Famous Saying: Much Ado About Nothing(2012/8). 输出： A aaAAbc dFgghh: iimM nNn oooos Sttuuuy (2012/8). 输入例子: A Famous Saying: Much Ado About Nothing (2012/8). 输出例子: A aaAAbc dFgghh: iimM nNn oooos Sttuuuy (2012/8). 解题思路： 外层i循环为[0,26),内层j循环为[0，str.size()) 判断条件为如果j对应的字符减去字符a或者A等于外层循环i的值 则将当前字符存入容器中 字母提取总结：根据内外层遍历，按照字母表顺序提取出字符 存入vector中 再遍历原来输入的字符串，如果当前字符为字母，则在vector中按顺序取出字母替换掉原来字符串中的字母 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;using std::cin;using std::cout;using std::endl;using std::vector;using std::string;int main()&#123; string str; vector&lt;char&gt;ivec; while (getline(cin, str)) &#123; int length = str.size(); ivec.clear(); for (int i = 0; i&lt;26; i++) &#123; for (int j = 0; j&lt;length; j++) &#123; if (str[j] - 'a' == i || str[j] - 'A' == i) &#123; ivec.push_back(str[j]); &#125; &#125; &#125; for (int i = 0, k = 0; (i&lt;length) &amp;&amp; (k &lt; ivec.size()); i++) &#123; if ((str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') || (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z')) &#123; str[i] = ivec[k++]; //k++; &#125; &#125; cout &lt;&lt; str &lt;&lt; endl;; &#125; return 0;&#125; 9. 字符串加密题目描述 1、对输入的字符串进行加解密，并输出。 2加密方法为：当内容是英文字母时则用该英文字母的后一个字母替换，同时字母变换大小写,如字母a时则替换为B；字母Z时则替换为a；当内容是数字时则把该数字加1，如0替换1，1替换2，9替换0；其他字符不做变化。 3、解密方法为加密的逆过程。 接口描述： 实现接口，每个接口实现1个基本操作： void Encrypt (char aucPassword[], char aucResult[])：在该函数中实现字符串加密并输出 说明： 1、字符串以\\0结尾。 2、字符串最长100个字符。 int unEncrypt (char result[], char password[])：在该函数中实现字符串解密并输出 说明： 1、字符串以\\0结尾。 2、字符串最长100个字符。 输入描述: 输入一串要加密的密码输入一串加过密的密码 输出描述: 输出加密后的字符输出解密后的字符 输入例子: abcdefgBCDEFGH 输出例子: BCDEFGHabcdefg 思路分析： 按部就班，一步一步来 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;iostream&gt;#include&lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;using std::getline;void AddKey(string str)&#123; for (string::size_type i = 0; i &lt; str.size(); i++) &#123; if (str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') &#123; if (str[i] == 'z') &#123; str[i] = 'A'; continue; &#125; else &#123; str[i] = str[i] - 32 + 1; continue; &#125; &#125; if (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') &#123; if (str[i] == 'Z') &#123; str[i] = 'a'; continue; &#125; else &#123; str[i] = str[i] + 32 + 1; continue; &#125; &#125; if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') &#123; if (str[i] == '9') &#123; str[i] = '0'; continue; &#125; else &#123; str[i] = str[i] + 1; continue; &#125; &#125; &#125; cout &lt;&lt; str &lt;&lt; endl;&#125; void SubKey(string str)&#123; for (string::size_type i = 0; i &lt; str.size(); i++) &#123; if (str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z') &#123; if (str[i] == 'a') &#123; str[i] = 'Z'; continue; &#125; else &#123; str[i] = str[i] - 32 - 1; continue; &#125; &#125; if (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') &#123; if (str[i] == 'A') &#123; str[i] = 'z'; continue; &#125; else &#123; str[i] = str[i] + 32 - 1; continue; &#125; &#125; if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') &#123; if (str[i] == '0') str[i] = '9'; else str[i] = str[i] - 1; &#125; &#125; cout &lt;&lt; str &lt;&lt; endl;&#125;int main()&#123; string str; string str1; while (cin &gt;&gt; str, cin &gt;&gt; str1) &#123; AddKey(str); SubKey(str1); &#125; return 0;&#125; 10. 字符串合并处理（待调试）题目描述 按照指定规则对输入的字符串进行处理。 详细描述：将输入的两个字符串合并。对合并后的字符串进行排序，要求为：下标为奇数的字符和下标为偶数的字符分别从小到大排序。这里的下标意思是字符在字符串中的位置。对排训后的字符串进行操作，如果字符为‘0’——‘9’或者‘A’——‘F’或者‘a’——‘f’，则对他们所代表的16进制的数进行BIT倒序的操作，并转换为相应的大写字符。如字符为‘4’，为0100b，则翻转后为0010b，也就是2。转换后的字符为‘2’； 如字符为‘7’，为0111b，则翻转后为1110b，也就是e。转换后的字符为大写‘E’。 举例： 输入str1为”dec”，str2为”fab”，合并为“decfab”，分别对“dca”和“efb”进行排序，排序后为“abcedf”，转换后为“5D37BF” 输入描述: 输入两个字符串 输出描述: 输出转化后的结果 输入例子: dec fab 输出例子: 5D37BF 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using std::sort;using std::vector;using std::cin;using std::cout;using std::endl;using std::string;void Output(int sum) //根据反转后二进制的加权和输出对应的字符&#123; if (sum &gt;= 10) &#123; for (int i = 0; i &lt; 6; i++) &#123; char ch[7] = \"ABCDEF\"; if (sum - 10 == i) cout &lt;&lt; ch[i]; &#125; &#125; if (sum &lt; 10 &amp;&amp; sum &gt;= 0) cout &lt;&lt; sum;&#125;int TransToBi(int number) //将字母对应的整数转换成二进制数以后反转再求值&#123; int temp; vector&lt;int&gt;ivec4; while (number) &#123; temp = number % 2; ivec4.push_back(temp); //将数逆序压入容器 number /= 2; //111 &#125; int len = ivec4.size(); if (ivec4.size() &lt; 4) //如果ivec0中的数字不够4个 &#123; for (int i = 0; i &lt; 4 - len; i++) ivec4.push_back(0); //1110 &#125; int sum = 0; for (int i = 0; i &lt; 4; i++) &#123; sum = sum + ivec4[i] * pow(2, 4 - i - 1); &#125; return sum;&#125;int CharToInt(char ch) //传入的字符转换成数字&#123; /* if (ch == 'a' || ch == 'A') return 10; else if (ch == 'b' || ch == 'B') return 11; else if (ch == 'c' || ch == 'C') return 12; else if (ch == 'd' || ch == 'D') return 13; else if (ch == 'e' || ch == 'E') return 14; else //if (ch == 'f' || ch == 'F') return 15; */ for (int i = 0; i &lt; 6; i++) &#123; if (ch - 'a' == i || ch - 'A' == i) return (i+10); &#125;&#125;void Tranfer(char ch) //转换&#123; if ((ch &gt;= '0' &amp;&amp; ch &lt;= '9')) &#123; int i = (ch - '0'); //将字符转换为数字求其二进制数 int sum = TransToBi(i); Output(sum); &#125; if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f') &#123; int number = CharToInt(ch); //得到对应的整数 int sum =TransToBi(number); //这儿得到的是反转以后的sum Output(sum); &#125; if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F') &#123; int number = CharToInt(ch); //得到对应的整数 int sum = TransToBi(number); //这儿得到的是反转以后的sum Output(sum); &#125;&#125;void MergeChar(string str)&#123; vector&lt;char&gt;ivec1; for (string::size_type i = 0; i &lt; str.size(); i += 2) ivec1.push_back(str[i]); //将第奇数个字符压入ivec中 sort(ivec1.begin(), ivec1.end()); vector&lt;char&gt;ivec2; for (string::size_type i = 1; i &lt; str.size(); i += 2) ivec2.push_back(str[i]); //将第偶数个字符压入ivec1中 sort(ivec2.begin(), ivec2.end()); vector&lt;char&gt;ivec3; for (string::size_type i = 0; i &lt; str.size(); i++) &#123; if (i % 2 == 0) ivec3.push_back(ivec1[i / 2]); if (i % 2 == 1) ivec3.push_back(ivec2[i / 2]); &#125; //以上完成字符串的局部排序 for (vector&lt;char&gt;::size_type i = 0; i &lt; ivec3.size(); i++) &#123; Tranfer(ivec3[i]); &#125;&#125;int main()&#123; string str1; string str2; cin &gt;&gt; str1; cin &gt;&gt; str2; string str = str1 + str2; MergeChar(str); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"华为OJ","slug":"华为OJ","permalink":"yongchunxiaofen.top/tags/华为OJ/"}]},{"title":"华为OJ系列（一）","slug":"HuaWei-OJ-seris","date":"2016-08-10T08:28:38.000Z","updated":"2016-08-15T06:47:22.000Z","comments":true,"path":"2016/08/10/HuaWei-OJ-seris/","link":"","permalink":"yongchunxiaofen.top/2016/08/10/HuaWei-OJ-seris/","excerpt":"1. 数字颠倒描述： 输入一个整数，将这个整数以字符串的形式逆序输出程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001 12345678910111213141516171819202122232425#include&lt;iostream&gt; using std::cin;using std::cout;using std::endl; void RevertInt(int number)&#123; int Rt1 = 0; int x1 = 10; while (number!=0) &#123; Rt1 = number%x1; cout &lt;&lt; Rt1; number = number / 10; &#125; &#125; int main()&#123; int Input1; cin &gt;&gt; Input1; RevertInt(Input1); return 0;&#125;","text":"1. 数字颠倒描述： 输入一个整数，将这个整数以字符串的形式逆序输出程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001 12345678910111213141516171819202122232425#include&lt;iostream&gt; using std::cin;using std::cout;using std::endl; void RevertInt(int number)&#123; int Rt1 = 0; int x1 = 10; while (number!=0) &#123; Rt1 = number%x1; cout &lt;&lt; Rt1; number = number / 10; &#125; &#125; int main()&#123; int Input1; cin &gt;&gt; Input1; RevertInt(Input1); return 0;&#125; 2. 字符串反转描述： 写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;using std::stack;stack&lt;char&gt;istack;void RevertChar(string str)&#123; for(auto c : str) //C++ 11标准 istack.push(c); while(!istack.empty()) &#123; cout&lt;&lt;istack.top(); istack.pop(); &#125;&#125;int main()&#123; string str1; cin&gt;&gt;str1; RevertChar(str1); return 0;&#125; 3. 字符串最后一个单词的长度题目描述 计算字符串最后一个单词的长度，单词以空格隔开。 输入描述 一行字符串，非空，长度小于5000。 输出描述: 整数N，最后一个单词的长度。 输入例子: hello world 输出例子: 5 解题思路： 将输入的字符串利用栈反转，从栈顶开始计算。 当遇到栈顶为空格时，停止计算 当整个栈为空时，停止计算。 优点：避免计算字符串中空格的数量 1234567891011121314151617181920212223242526272829303132333435363738#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;#define MAXNUMBER 5000using std::string;using std::stack;using std::cin;using std::cout;using std::endl;stack&lt;char&gt;istack;int LengthofLast(string str)&#123; int number = 0; for (auto c : str) &#123; istack.push(c); &#125; while (istack.top()!=' ') &#123; istack.pop(); number++; if (istack.size() == 0) break; &#125; return number;&#125;int main()&#123; char ch[MAXNUMBER]; gets(ch); cout&lt;&lt;LengthofLast(ch); return 0;&#125; 4. 随机数的排序以及去重题目描述 明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。 123456789Input Param n 输入随机数的个数 inputArray n个随机整数组成的数组 Return Value OutputArray 输出处理后的随机整数注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。 输入描述: 输入多行，先输入随机整数的个数，再输入相应个数的整数 输出描述: 返回多行，处理后的结果 输入例子: 11102040326740208930040015 输出例子: 10152032406789300400 代码 123456789101112131415161718192021222324252627282930313233343536//去重思路：当前数不等于前一个数时，才输出//排序调用的排序算法//使用容器vector存储不定长数组#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using std::cin;using std::cout;using std::sort;using std::vector;using std::endl;int main()&#123; int N; while (cin&gt;&gt;N) &#123; int number; vector&lt;int&gt;ivec; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; number; ivec.push_back(number); &#125; sort(ivec.begin(), ivec.end()); cout &lt;&lt; ivec[0] &lt;&lt; endl; for (int i = 1; i &lt; N; i++) &#123; if (ivec[i] != ivec[i - 1]) cout &lt;&lt; ivec[i] &lt;&lt; endl; &#125; &#125; return 0;&#125; 5. 进制转换题目描述 写出一个程序，接受一个十六进制的数值字符串，输出该数值的十进制字符串。（多组同时输入 ） 输入描述: 输入一个十六进制的数值字符串。 输出描述: 输出该数值的十进制字符串。 输入例子: 0xA 输出例子: 10 思路分析： 将输入的十六进制字符串压入栈（包括十六进制标识符0x） 根据十六进制和十进制的转换公式进行转换（） 十六进制数的第0位的权值为16的0次方，第1位的权值为16的1次方，第2位的权值为16的2次方……,计算完毕之后将所有的权值相加即可。 参考来源 从栈顶往下遍历时，一种方法时遇到x即停止，另一种方法是：遍历的长度肯定为字符串长度减去2. 由于字符串中的字符为数字或者字母时，其数值均为ASCⅡ码，根据ASC码将其转换成对应的十进制的数字。 由于需要多组输入，使用while(cin&gt;&gt;str)的形式。 使用数学函数幂pow(double,double)，其原型为double pow(double, double) 其包含在头文件#include&lt;cmath&gt;或者#include&lt;math.h&gt;中。 程序代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stack&gt;#include&lt;cmath&gt;using std::pow;using std::stack;using std::string;using std::cin;using std::cout;using std::endl;void ConvertToDecimal(string str)&#123; stack&lt;char&gt;istack; for (auto c : str) &#123; istack.push(c); //遍历string字符串，将十六进制的字符串压入栈 &#125; int number; int sum = 0; for (int i = 0; i &lt; str.size() - 2; i++) //遍历十六进制的有效部分 &#123; if (istack.top() &gt;= 'A' &amp;&amp; istack.top() &lt;= 'F') &#123; istack.top() = istack.top() - 55; &#125; if (istack.top() &gt;= 'a' &amp;&amp; istack.top() &lt;= 'f') &#123; istack.top() = istack.top() - 87; &#125; if (istack.top() &gt;= '0' &amp;&amp; istack.top() &lt;= '9') &#123; istack.top() = istack.top() - 48; &#125; number = (istack.top()) * pow(16,i); sum = sum + number; istack.pop(); &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125;int main()&#123; string str; while(cin &gt;&gt; str) &#123; ConvertToDecimal(str); &#125; return 0;&#125; 6. 指数因子 2016/8/12 16:17:22 题目描述 功能:输入一个正整数，按照从小到大的顺序输出它的所有质数的因子（如180的质数因子为2 2 3 3 5 ） 输入描述: 输入一个long型整数 输出描述: 按照从小到大的顺序输出它的所有质数的因子，以空格隔开 输入例子: 180 输出例子: 2 2 3 3 5 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using std::cin;using std::cout;using std::endl;void PrimeNumber(int ComNumber)&#123; for(int i = 2; i &lt; ComNumber; i++) &#123; while(ComNumber != i) &#123; if(ComNumber % i == 0) &#123; cout &lt;&lt; i &lt;&lt;\" \"; ComNumber /= i; &#125; else break; &#125; &#125; cout &lt;&lt; ComNumber &lt;&lt; \" \" &lt;&lt;endl; //这儿尤其要注意，TM最后一个质数后边也有空格，否则编译不能过。&#125;int main()&#123; int ComNumber; cin &gt;&gt; ComNumber; //输入一次，并未说明多次输入 PrimeNumber(ComNumber); return 0;&#125; 7. 合并表记录题目描述 数据表记录包含表索引和数值，请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。 输入描述: 先输入键值对的个数然后输入成对的index和value值，以空格隔开 输出描述: 输出合并后的键值对（多行） 输入例子: 40 10 21 23 4 输出例子: 0 31 23 4 思路分析 一种方法是可以考虑使用关联容器map来分别存储index和value，鉴于该题目中的index和value可以是类型相同的值，故采用vector。采用vector构造的二维数组来存储index和value值， 123456vector&lt;vector&lt;int&gt;&gt; ivec(lines) //ivec中有line个元素，其中每个元素中又可以包含多个元素for(int i = 0; i &lt; line; i++)&#123; ivec[i].resize(rows) //每个元素中包含rows个元素，使ivec成为lines×rows的二维数组&#125; 采用先排序，再对相同index的value相加，最后输出合并后的键值对的方法排序时，调用Algorithm中的sort算法，根据二维数组中每行首元素进行排序相同index的value相加后的值存放在相同index的最后输出时，采用条件判断，当该行的首元素和该行后边的首元素不相同时才输出。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;iterator&gt;using std::iterator;using std::sort;using std::vector;using std::cin;using std::cout;using std::endl;void MergeNumber(int number)&#123; vector&lt;vector&lt;int&gt;&gt;ivec(number); for (int i = 0; i &lt; number; i++) ivec[i].resize(2); //number行2列的数组 int index, value; for (int i = 0; i &lt; number; i++) &#123; scanf(\"%d %d\", &amp;index, &amp;value); ivec[i][0] = index; //index储存成每行的首元素，value的值存储成每行的第二个元素 ivec[i][1] = value; //将键值以数列的形式存储 &#125; vector&lt;vector&lt;int&gt;&gt;::iterator it=ivec.begin(); vector&lt;vector&lt;int&gt;&gt;::iterator it1 = ivec.end(); sort(it,it1); //将数组按照首元素重新排序 //将相同index后的value相加 for (int i = 1; i &lt; number; i++) &#123; if (ivec[i][0] == ivec[i - 1][0]) &#123; ivec[i][1] = ivec[i][1] + ivec[i - 1][1]; &#125; &#125; for (int i = 0; i &lt; number-1; ++i) &#123; if (ivec[i][0] != ivec[i+1][0]) cout &lt;&lt; ivec[i][0] &lt;&lt; \" \" &lt;&lt; ivec[i][1] &lt;&lt; endl; &#125; cout &lt;&lt; ivec[number - 1][0] &lt;&lt; \" \" &lt;&lt; ivec[number - 1][1] &lt;&lt; endl; //单独输出最后一个元素 &#125;int main()&#123; int number; cin &gt;&gt; number; //键值对的个数 MergeNumber(number); return 0;&#125; 8. 提取不重复的整数题目描述 输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。 输入描述: 输入一个int型整数 输出描述: 按照从右向左的阅读顺序，返回一个不含重复数字的新的整数 输入例子: 9876673 输出例子: 37689 思路分析： 输入的整数要得到每一位的数字时，可用取余%10得到末尾的数字。 这样每一步执行完毕之后将数字/10将前一位数字置于末位。 将%出来的结果用vector数组来存放。存放顺序就是数字从后往前排列。 至于对数字去重，本来想使用关联数组中的set来存储， 但是set会对数字自动排序。 参考牛客网友的方法，将每一个%得到的结果先存入vector中， 再遍历该数字之前的所有数，如果和当前%得到的数字相同，再pop_back()将该重复数字弹出。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;vector&gt;using std::vector;using std::cin;using std::cout;using std::endl;void ExtractInt(int Input)&#123; int temp; vector&lt;int&gt;ivec; while(Input != 0) &#123; temp = Input % 10; ivec.push_back(temp); Input /= 10; for(vector&lt;int&gt;::size_type i = 0; i &lt; ivec.size()-1; i++) &#123; if(temp == ivec[i]) &#123; ivec.pop_back(); break; &#125; &#125; &#125; for(vector&lt;int&gt;::size_type i = 0; i &lt; ivec.size(); i++) &#123; cout &lt;&lt; ivec[i]; &#125;&#125;int main()&#123; int Input; cin &gt;&gt; Input; ExtractInt(Input); return 0;&#125; 9. 字符个数统计题目描述 编写一个函数，计算字符串中含有的不同字符的个数。字符在ACSII码范围内(0~127)。不在范围内的不作统计。 输入描述: 输入N个字符，字符在ACSII码范围内(0~127)。 输出描述: 输出字符的个数。 输入例子: abc 输出例子: 3 思路分析： 输出要求是不同字符的个数,想起关联容器set的自动去重功能， 至于set的自动排列，who care？ 将输入的字符直接压入到set中， 去重，统计都给你做好。 STL，我服！ 代码：1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;string&gt;using std::cin;using std::cout;using std::endl;using std::set;using std::string;void CalcuteNumber(string str)&#123; set&lt;char&gt;iset(str.begin(),str.end()); cout &lt;&lt; iset.size() &lt;&lt; endl;&#125;int main()&#123; string str; cin &gt;&gt; str; CalcuteNumber(str); return 0;&#125; 10.句子逆序题目描述 将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I”所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符 输入描述: 将一个英文语句以单词为单位逆序排放。 输出描述: 得到逆序的句子 输入例子: I am a boy 输出例子: boy a am I 思路分析： 从后往前遍历输入的字符串，设定一个指针p指向字符串的最后一个字符 另外设定一个指针p往前移动，如果p所指向的字符为空格时 从p+1遍历到q输出每个p所指向的字符 然后将q移动到p-1的位置，作为下一个输出的终点。 如此一来，因为第一个单词前没有空格 所以第一个单词需要单独输出 由前面指针的移动，第一个单词输出时 只需要输出位置0到指针q的所有字符即可。 本例假设所有输出都正确，没有多余的空格或者其他字符。 代码：123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;string&gt;using std::cin;using std::cout;using std::endl;using std::string;void RevertSentence(string str)&#123; int j = str.size() - 1; //初始化j的位置 for (int i = str.size() - 1; i &gt;= 0; i--) &#123; if (str[i] == ' ') &#123; for (int i1 = i + 1; i1 &lt;=j; i1++) //从空格后到j遍历 cout &lt;&lt; str[i1]; cout &lt;&lt; \" \"; j = i - 1; //对j重新赋值，使其指向空格前一位置 &#125; &#125; for (int i = 0; i &lt;=j; i++) &#123; cout &lt;&lt; str[i]; //对第一个单词单独输出，使用上述循环中的j &#125; cout &lt;&lt; endl;&#125;int main()&#123; char ch[1000]; gets(ch); RevertSentence(ch); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"华为OJ","slug":"华为OJ","permalink":"yongchunxiaofen.top/tags/华为OJ/"}]},{"title":"链表的增加及删除结点","slug":"ListNode-Add-Delete","date":"2016-07-24T02:52:36.000Z","updated":"2016-07-24T03:23:06.000Z","comments":true,"path":"2016/07/24/ListNode-Add-Delete/","link":"","permalink":"yongchunxiaofen.top/2016/07/24/ListNode-Add-Delete/","excerpt":"概述链表是一种动态数据结构，是因为链表在创建时，长度为止。 每当插入一个新的结点时，只需要为当前新插入的结点分配内存，然后调整指针的指向来确保新结点被链接到链表当中。 内存分配不是创建链表的时候一次性分配完毕，而是每添加一个结点分配一个结点所需的内存空间。 由于没有闲置的空间，所以链表的空间效率比数组高。 单链表可用如下的方式定义结点： 12345struct ListNode&#123; int m_nValue; ListNode* m_pNext;&#125;","text":"概述链表是一种动态数据结构，是因为链表在创建时，长度为止。 每当插入一个新的结点时，只需要为当前新插入的结点分配内存，然后调整指针的指向来确保新结点被链接到链表当中。 内存分配不是创建链表的时候一次性分配完毕，而是每添加一个结点分配一个结点所需的内存空间。 由于没有闲置的空间，所以链表的空间效率比数组高。 单链表可用如下的方式定义结点： 12345struct ListNode&#123; int m_nValue; ListNode* m_pNext;&#125; 单链表的插入操作向该单链表中添加一个结点的C代码如下： 123456789101112131415161718192021void AddToTail(ListNode** pHead, int value)&#123; ListNode *pNew = new ListNode(); pNew-&gt;m_nValue = value; pNew-&gt;m_pNext = NULL; if(*pHead == NULL) &#123; *pHead = pNew; &#125; else &#123; ListNode *pNode = *pHead; while(pNode-&gt;m_pNext != NULL) &#123; pNode = pNode-&gt;m_pNext; &#125; pNode-&gt;m_pNext = pNew; &#125;&#125; 注*：函数的第一个参数pHead是一个二级指针。往一个空链表中插入一个结点时，新插入的结点即为链表的头指针。 由于此时会改动头指针，因此必须把pHead参数设为指向指针的指针，否则出了这个函数pHead仍然是一个空指针。 如果想在链表中找到它的第i个结点，也只能从头结点开始，沿着指向下一个结点的指针遍历链表，时间效率为O(n)。 以下代码是在链表中找到第一个含有某值的结点并删除该结点的代码 单链表的删除操作123456789101112131415161718192021222324252627282930313233void RemoveNode(ListNode** pHead, int value)&#123; if(pHead == NULL || *pHead == NULL) return; ListNode* pToBeDeleted = NULL; if((*pHead)-&gt;m_nValue == value) &#123; pToBeDeleted = *pHead; *pHead = (*pHead)-&gt;m_pNext; &#125; else &#123; ListNode* pNode = *pHead; while((*pNode)-&gt;m_pNext != NULL &amp;&amp; (*pNode)-&gt; m_pNext-&gt;m_nValue != NULL) &#123; pNode = pNode-&gt;m_pNext; &#125; if((*pNode)-&gt;m_pNext != NULL &amp;&amp; (*pNode)-&gt; m_pNext-&gt;m_nValue == value) &#123; pToBeDeleted = pNode-&gt;m_pNext; pNode-&gt;m_pNext = pNode-&gt;m_pNext-&gt;m_pNext; &#125; &#125; if(pToBeDeleted != NULL) &#123; delete pToBeDeleted; pToBeDeleted = NULL; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"yongchunxiaofen.top/categories/数据结构/"}],"tags":[{"name":"链表","slug":"链表","permalink":"yongchunxiaofen.top/tags/链表/"}]},{"title":"pragma once与#ifndef","slug":"pragma-once-and-ifndef","date":"2016-07-23T14:14:00.000Z","updated":"2016-07-23T14:27:26.000Z","comments":true,"path":"2016/07/23/pragma-once-and-ifndef/","link":"","permalink":"yongchunxiaofen.top/2016/07/23/pragma-once-and-ifndef/","excerpt":"#ifndef‘’#ifndef’这种是最早期使用的方法，是基于语言的宏定义名字不能冲突的前提下的。 这种方法不仅能保证同一个头文件不会被包含两次，也可以保证内容完全相同的两个文件也只能被包含一次。 但是他也有缺点，就是你的#ifndef 后面跟的宏名字和你程序中的其他宏名字发生了”撞车“，那么会出现以下两种后果 第一种：程序包含的file1头文件中有一个宏12//file1.h#define BOOK_H //宏名 现在又有一个文件 book.h 里面使用了宏定义方式防止头文件二次编译，而且定义防止二次编译的宏名和另一个头文件中的宏名相同，如下所示： 12345//book.h#ifndef BOOK_H#define BOOK_H// program codes#endif","text":"#ifndef‘’#ifndef’这种是最早期使用的方法，是基于语言的宏定义名字不能冲突的前提下的。 这种方法不仅能保证同一个头文件不会被包含两次，也可以保证内容完全相同的两个文件也只能被包含一次。 但是他也有缺点，就是你的#ifndef 后面跟的宏名字和你程序中的其他宏名字发生了”撞车“，那么会出现以下两种后果 第一种：程序包含的file1头文件中有一个宏12//file1.h#define BOOK_H //宏名 现在又有一个文件 book.h 里面使用了宏定义方式防止头文件二次编译，而且定义防止二次编译的宏名和另一个头文件中的宏名相同，如下所示： 12345//book.h#ifndef BOOK_H#define BOOK_H// program codes#endif 下面是你的主函数所在文件内容 12345#include\"fil1.h\" //其中包含宏BOOK_H#include\"book.h\" //在该文件的语句中，会探测到已经包含了宏BOOK_H，于是不再包含这个头文件。//这两个都是你自己的头文件#include&lt;........&gt;//.................. 预编译阶段把file1文件展开，就得到了宏 BOOK_H，在处理book.h文件时就发现BOOK_H这个宏已经存在了，就不会包含book.h头文件了，这就是弊端所在了。 第二种两者顺序反过来了，弊端类似。 #pragma once这种方式，是微软编译器独有的，也是后来才有的，所以知道的人并不是很多，用的人也不是很多，因为他不支持跨平台。如果你想写跨平台的代码，最好使用上一种。这是一种由编译器提供支持的方式，防止同一文件的二次编译，这里的同一文件指的是物理文件。 他也是有弊端的： 假如你的某一个头文件有多份拷贝，那么这些文件虽然在逻辑上都是一样的，但是在物理上他们却是不同的，所以当你把这些文件包含的时候，就会发现真的都包含进来了，然后就是编译错误了。还有，当物理上的同一文件被嵌套包含的时候，使用第一种方法预处理会每一次打开该文件做判断的，但是第二种方法则不会，所以在此#pragma once 会更快些。下面举例说明 预处理器在执行这四句的时候，先打开Test1.h然后发现里面的宏TEST1_H没有被定义，所以会包含这个文件，第二句的时候，同样还是会打开Test2.h的发现宏已定义，就不包含该文件按了。第三句时，发现之前没有包含Test2,h则会把该文件包含进来，执行第四句的时候，发现该文件已经被包含了，所以不用打开就直接跳过了。 总结：方式一由语言支持所以移植性好，方式二 可以避免名字冲突 转自：http://blog.csdn.net/zlhy_/article/details/8192580","categories":[{"name":"数据结构","slug":"数据结构","permalink":"yongchunxiaofen.top/categories/数据结构/"}],"tags":[{"name":"pragma once","slug":"pragma-once","permalink":"yongchunxiaofen.top/tags/pragma-once/"},{"name":"idndef","slug":"idndef","permalink":"yongchunxiaofen.top/tags/idndef/"}]},{"title":"常用工具整理","slug":"useful-software-tools","date":"2016-07-19T02:35:21.000Z","updated":"2016-09-06T01:51:30.000Z","comments":true,"path":"2016/07/19/useful-software-tools/","link":"","permalink":"yongchunxiaofen.top/2016/07/19/useful-software-tools/","excerpt":"常用工具整理在线画图工具：processon：https://www.processon.com/桌面快捷启动：ALTRUN桌面快捷搜索：Everything百度云文件下载：百度云不限速+会员加速版免费图床：https://ituku.tk/人类进步的阶梯：Lantern查询常用单词匹配：http://linggle.com远程桌面：TeamViewerMarkdown编辑器：Typora ，或者MarkdownPad2","text":"常用工具整理在线画图工具：processon：https://www.processon.com/桌面快捷启动：ALTRUN桌面快捷搜索：Everything百度云文件下载：百度云不限速+会员加速版免费图床：https://ituku.tk/人类进步的阶梯：Lantern查询常用单词匹配：http://linggle.com远程桌面：TeamViewerMarkdown编辑器：Typora ，或者MarkdownPad2 Visual Studio 2013 插件配置： visualstudio 2013新插件：developer assistant chrome浏览器插件总结书签整理：Xmarks网页翻译：划词翻译鼠标手势：crxMouse网页截图：Fireshot拒绝广告：Adblock pro听音乐： Listen1 (Github开源)在线笔记：有道云笔记","categories":[{"name":"工具","slug":"工具","permalink":"yongchunxiaofen.top/categories/工具/"}],"tags":[{"name":"常用工具","slug":"常用工具","permalink":"yongchunxiaofen.top/tags/常用工具/"}]},{"title":"范围for(range for)语句(C++11) + cctype头文件","slug":"the-use-of-rang-for","date":"2016-07-19T02:22:26.000Z","updated":"2016-07-19T02:28:14.000Z","comments":true,"path":"2016/07/19/the-use-of-rang-for/","link":"","permalink":"yongchunxiaofen.top/2016/07/19/the-use-of-rang-for/","excerpt":"适用对象：string对象中的字符操作 这种语句遍历给定序列中的每个元素并对序列中的每个值进行某种操作。 语法格式12for(declaration : expression) statement; 其中，expression部分是一个对象，用于表示一个序列。 declaration负责定义一个变量，该变量将被用于访问序列中的基础元素。 每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。 具体到string，一个string对象表示一个字符的序列，因此string对象可以作为范围for语句的expression的部分。 以下举例说明： 1234string str(\"some string\");//每行输出str中的一个字符for(auto c : str) //对于当前str中的每个字符 cout&lt;&lt;c&lt;&lt;endl; //输出当前字符 for循环将变量c和str联系了起来，其中我们定义循环控制变量的方式与定义任意普通变量的方式是一样的。 该例中，使用auto关键字让编译器来决定变量c的类型，当然，这儿变量c的类型是char类型。 每次迭代，str的下一个字符被拷贝给c。","text":"适用对象：string对象中的字符操作 这种语句遍历给定序列中的每个元素并对序列中的每个值进行某种操作。 语法格式12for(declaration : expression) statement; 其中，expression部分是一个对象，用于表示一个序列。 declaration负责定义一个变量，该变量将被用于访问序列中的基础元素。 每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。 具体到string，一个string对象表示一个字符的序列，因此string对象可以作为范围for语句的expression的部分。 以下举例说明： 1234string str(\"some string\");//每行输出str中的一个字符for(auto c : str) //对于当前str中的每个字符 cout&lt;&lt;c&lt;&lt;endl; //输出当前字符 for循环将变量c和str联系了起来，其中我们定义循环控制变量的方式与定义任意普通变量的方式是一样的。 该例中，使用auto关键字让编译器来决定变量c的类型，当然，这儿变量c的类型是char类型。 每次迭代，str的下一个字符被拷贝给c。 再举一个例子： 1234567891011string s(\"Hello World!!!\");//punct_cnt的类型和s.size的返回类型一样；decltype(s.size()) punct_cnt = 0;//统计s中标点符号的数量for(auto c : s) //遍历s中的每个字符 if(ispunct(c)) //如果该字符是标点符号 ++punct_cnt; //将标点符号的计数值加1cout &lt;&lt; punct_cnt &lt;&lt; \" punctuation characters in \" &lt;&lt; s &lt;&lt; endl;//程序的输出结果是：//3 punctuation characters in Hello World！！！ 附表：cctype头文件中的函数该头文件能够获取字符串的某个字符并且对其进行处理。 头文件中的函数 对应的含义 isalnum(c) 当c是字母或数字时为真 isalpha(c) 当c是字母时为真 iscntrl(c) 当c是控制字符时为真 isdigit(c) 当c是数字时为真 isgraph(c) 当c不是空格但可打印时为真 islower(c) 当c是小写字母时为真 isprint(c) 当c是可打印字符时为真（空格或具有可视形式） ispunct(c) 当c是标点符号时为真 isspace(c) 当c是空白时为真（空格/横向制表符/纵向制表符/回车符/换行符/） isupper(c) c是大写时为真 isxdigit(c) c是十六进制数字时为真 tolower(c) 如果c是大写，则输出对应的小写；否则原样输出c toupper(c) 如果c是小写，则输出对应的大写；否则原样输出c","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++11","slug":"C-11","permalink":"yongchunxiaofen.top/tags/C-11/"},{"name":"cctype","slug":"cctype","permalink":"yongchunxiaofen.top/tags/cctype/"}]},{"title":"二叉树的非递归遍历","slug":"Non-recursive-traversal-of-binary-tree","date":"2016-07-17T03:07:59.000Z","updated":"2016-07-17T03:09:31.000Z","comments":true,"path":"2016/07/17/Non-recursive-traversal-of-binary-tree/","link":"","permalink":"yongchunxiaofen.top/2016/07/17/Non-recursive-traversal-of-binary-tree/","excerpt":"前序遍历的非递归实现以如下二叉树为例，分析： 根据先序遍历的顺序，先访问根结点，再访问左子树，最后访问右子树，而对于每个子树来说，又按照同样的访问顺序进行遍历。上图的先序遍历顺序为：ABDECF 思路分析非递归的实现思路如下： 对于任意节点P， 输出结点P，然后将其入栈，再看P的左孩子是否为空； 若P的左孩子不为空，则置P的左孩子为当前节点，重复上一步的过程； 若P的左孩子为空，则将栈顶节点出栈，但不输出，并将出栈结点的右孩子置为当前节点，看其是否为空； 若不为空，则循环第1步的操作； 如果为空，则继续出栈，但不输出，同时将出栈节点的右孩子置为当前节点，看其是否为空，重复第4步和第5步的操作； 直到当前节点P为NULL并且栈空，便利结束。","text":"前序遍历的非递归实现以如下二叉树为例，分析： 根据先序遍历的顺序，先访问根结点，再访问左子树，最后访问右子树，而对于每个子树来说，又按照同样的访问顺序进行遍历。上图的先序遍历顺序为：ABDECF 思路分析非递归的实现思路如下： 对于任意节点P， 输出结点P，然后将其入栈，再看P的左孩子是否为空； 若P的左孩子不为空，则置P的左孩子为当前节点，重复上一步的过程； 若P的左孩子为空，则将栈顶节点出栈，但不输出，并将出栈结点的右孩子置为当前节点，看其是否为空； 若不为空，则循环第1步的操作； 如果为空，则继续出栈，但不输出，同时将出栈节点的右孩子置为当前节点，看其是否为空，重复第4步和第5步的操作； 直到当前节点P为NULL并且栈空，便利结束。 实例分析下面以上图为例详细分析其先序遍历的非递归实现过程： 首先，从根节点A开始，根据操作1），输出A，并将其入栈，由于A的左孩子不为空，根据操作2），将B置为当前节点，再根据操作1），将B输出，并将其入栈，由于B的左孩子也不为空，根据操作2），将D置为当前节点，再根据操作1），输出D，并将其入栈，此时输出序列为ABD； 由于D的左孩子为空，根据操作3），将栈顶节点D出栈，但不输出，并将其右孩子置为当前节点； 由于D的右孩子为空，根据操作5），继续将栈顶节点B出栈，但不输出，并将其右孩子置为当前节点； 由于B的右孩子E不为空，根据操作1），输出E，并将其入栈，此时输出序列为：ABDE； 由于E的左孩子为空，根据操作3），将栈顶节点E出栈，但不输出，并将其右孩子置为当前节点； 由于E的右孩子为空，根据操作5），继续将栈顶节点A出栈，但不输出，并将其右孩子置为当前节点； 由于A的右孩子C不为空，根据操作1），输出C，并将其入栈，此时输出序列为：ABDEC； 由于A的左孩子F不为空，根据操作2），则将F置为当前节点，再根据操作1），输出F，并将其入栈，此时输出序列为：ABDECF； 由于F的左孩子为空，根据操作3），将栈顶节点F出栈，但不输出，并将其右孩子置为当前节点； 由于F的右孩子为空，根据操作5），继续将栈顶元素C出栈，但不输出，并将其右孩子置为当前节点； 此时栈空，且C的右孩子为NULL，因此遍历结束。 代码实现根据以上思路，前序遍历的非递归实现代码如下： 123456789101112131415161718192021222324void pre_traverse(BTree pTree)&#123; PSTACK stack = create_stack(); //创建一个空栈 BTree node_pop; //用来保存出栈节点 BTree pCur = pTree; //定义用来指向当前访问的节点的指针 //直到当前节点pCur为NULL且栈空时，循环结束 while(pCur || !is_empty(stack)) &#123; //从根节点开始，输出当前节点，并将其入栈， //同时置其左孩子为当前节点，直至其没有左孩子，及当前节点为NULL printf(\"%c \", pCur-&gt;data); push_stack(stack,pCur); pCur = pCur-&gt;pLchild; //如果当前节点pCur为NULL且栈不空，则将栈顶节点出栈， //同时置其右孩子为当前节点,循环判断，直至pCur不为空 while(!pCur &amp;&amp; !is_empty(stack)) &#123; pCur = getTop(stack); pop_stack(stack,&amp;node_pop); pCur = pCur-&gt;pRchild; &#125; &#125;&#125; 参考文章兰亭风雨的专栏——二叉树递归与非递归遍历（附完整源码）","categories":[{"name":"数据结构","slug":"数据结构","permalink":"yongchunxiaofen.top/categories/数据结构/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"yongchunxiaofen.top/tags/二叉树/"}]},{"title":"中缀表达式转换为后缀表达式","slug":"Infix-convert-to-Postfix-expression","date":"2016-07-17T03:06:46.000Z","updated":"2016-07-17T03:28:16.000Z","comments":true,"path":"2016/07/17/Infix-convert-to-Postfix-expression/","link":"","permalink":"yongchunxiaofen.top/2016/07/17/Infix-convert-to-Postfix-expression/","excerpt":"使用的数据结构：栈 转换规则： 从左到右依次遍历中缀表达式的每个数字和运算符号。 如果遍历到数字，则输出称为后缀表达式的一部分； 如果遍历到运算符号，则判断当前符号与目前在栈顶的运算符的优先级，是右括号或优先级低于栈顶的元素（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。","text":"使用的数据结构：栈 转换规则： 从左到右依次遍历中缀表达式的每个数字和运算符号。 如果遍历到数字，则输出称为后缀表达式的一部分； 如果遍历到运算符号，则判断当前符号与目前在栈顶的运算符的优先级，是右括号或优先级低于栈顶的元素（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。 以中缀表达式“9+(3-1)*3+10/2”转化为后缀表达式“9 3 1-3*+ 10 2/+”为例说明。 初始化一空栈，用来对符号进出栈使用。 第一个字符是数字9，输出9，然后是符号“+”，进栈。 第三个字符是“(”,依然是符号，因其只是左括号，还未配对，故进栈。 第四个字符是数字3，输出，总表达式为9 3,接着是“-”进栈。 接下来是数字1，输出，总表达式为9 3 1，后面是符号“)”，此时，我们需要去匹配此前的“(”，所以栈顶依次出栈，并输出，直到“(”出栈为止。此时左括号上方只有“-”，因此输出“-”，总的输出表达式为9 3 1 - 接着是数字3，输出，总的表达式为9 3 1 - 3 。紧接着是符号“*”，因为此时的栈顶符号为“+”号，优先级低于“*”，因此不输出，进栈。 之后是符号“+”，此时当前栈顶元素比这个“+”的优先级高，因此栈中元素出栈并输出（没有比“+”号更低的优先级，所以全部出栈），总输出表达式为 9 3 1 - 3 +.然后将当前这个符号“+”进栈。也就是说，前6张图的栈底的“+”是指中缀表达式中开头的9后面那个“+”，而下图中的栈底（也是栈顶）的“+”是指“9+(3-1)3+”中的最后一个“+”。 紧接着数字10，输出，总表达式变为9 3 1-3 * + 10。 最后一个数字2,输出，总的表达式为 9 3 1-3*+ 10 2 因已经到最后，所以将栈中符号全部出栈并输出。最终输出的后缀表达式结果为 9 3 1-3*+ 10 2/+ 转自：http://www.nowamagic.net/librarys/veda/detail/2307","categories":[{"name":"数据结构","slug":"数据结构","permalink":"yongchunxiaofen.top/categories/数据结构/"}],"tags":[{"name":"中缀表达式","slug":"中缀表达式","permalink":"yongchunxiaofen.top/tags/中缀表达式/"},{"name":"后缀表达式","slug":"后缀表达式","permalink":"yongchunxiaofen.top/tags/后缀表达式/"}]},{"title":"计算机网络（六）：应用层","slug":"computer-networks-06","date":"2016-07-11T14:20:43.000Z","updated":"2016-07-17T09:30:25.000Z","comments":true,"path":"2016/07/11/computer-networks-06/","link":"","permalink":"yongchunxiaofen.top/2016/07/11/computer-networks-06/","excerpt":"应用层整个因特网、硬件以及软件的设计和开发就是为应用层提供服务。 因特网的两个应用类型： 传统类型：客户-服务器模式（client-server-paradigm） 新类型：对等模式（peer-to-peer paradigm） 应用层模式提出：两个在不同地点的主机程序需要通过因特网基础设施彼此发送报文。然而，两者的关系应该清楚。是两者都应该能够请求和提供服务吗？还是应用程序仅仅实现这两种功能中的一个？","text":"应用层整个因特网、硬件以及软件的设计和开发就是为应用层提供服务。 因特网的两个应用类型： 传统类型：客户-服务器模式（client-server-paradigm） 新类型：对等模式（peer-to-peer paradigm） 应用层模式提出：两个在不同地点的主机程序需要通过因特网基础设施彼此发送报文。然而，两者的关系应该清楚。是两者都应该能够请求和提供服务吗？还是应用程序仅仅实现这两种功能中的一个？ 新模式：对等（p2p模式）连接到因特网的计算机既可以接受服务，也可以提供服务。 对等模式无需一直运行和维护昂贵的服务器，它是容易扩展且经济划算的。 其存在的主要挑战是安全问题，在分布式服务之间创建安全通信比在那些由专用服务器控制的服务之间建立安全通信要更困难。另一个挑战是实用性。 混合模式一个应用可以通过结合这两种模式的优点来把这两者混合起来。比如轻量级的c/s通信可以用来寻找可以提供服务的对等节点的地址。找到这个地址时，实际服务可以通过使用对等模式从对等结点中获得。 传统模式：客户-服务器（c/s）服务提供者是一个称为服务进程的应用程序，不断运行，等待另一个称为客户进程的应用程序通过因特网建立连接并请求服务。 这种模式的问题是通信负荷集中在服务器上，这意味着服务器应该是一台强大的计算机。可能会面对大量客户同时尝试连接。另一个问题时花费。 应用程序接口应用程序接口（Application Programming Inteface，API） 程序中的接口是两个实体之间的指令集。一个实体是应用层中的进程，另一个是操作系统，操作系统封装了TCP/IP协议簇的前四层。换句话说，电脑制造商将协议簇的前四层编写进操作系统中并包含了APU。 三个常见的通信API：套接字接口、传输层接口以及STREAM。 套接字接口的位置：应用层和传输层之间套接字接口是提供应用层和操作系统间通信的指令集，是一个可以被某进程用来与另一个进程进行通信的指令集。 套接字套接字不是物理实体，而是一种抽象。套接字是提供应用程序创建和使用的数据结构。 就应用层而言，客户进程和服务器进程间的通信时两个套接字之间的通信。 套接字地址c/s的交互式双向通信。双向通信时，需要一对地址：本地地址和远程地址。由于c/s模式的通信是在套接字之间进行的，还需要一对套接字地址（一个本地套接字地址和一个远程套接字地址）。 IP地址帮助定位到需要通信的计算机，然而计算机在同一时间可能有多个进程运行，这时就需要另一个标识符来识别。它就是端口。 于是乎，套接字地址应该是**一个IP地址和一个端口号的组合。** 服务器站点： 本地（服务器）套接字地址： 由操作系统提供。服务器进程的端口号需要被分配。如果这个服务器进程是因特网管理结构定义的标准进程，那么端口号就已经分配好了。比如超文本传输协议（HTTP）的端口是80. 远程（客户）套接字地址客户套接字地址包含在发给服务器的请求报文中，它成为远程套接字地址来给客户提供相应。 使用传输层的服务UDP：无连接、不可靠的数据报服务。无连接意味着两个交换报文的终端之间没有逻辑连接。每个报文都是独立的实体，被封装在一个称为数据报分组中。UDP是不可靠协议。简单，速度快。 TCP：面向连接的可靠的字节流传输。 标准客户-服务器应用万维网WWW结构： 如今的WWW是一个分布式客户-服务器服务。使用浏览器的用户可以访问一个正在服务器上运行的服务。服务器分布在很多称为站点的地点上。每一个站点有一个或多个文档，它们可以成为网页。每个网页可以包含一些到其他网页的连接，那些被连接的网页可以在同一个站点也可以在其他站点。 网络客户（浏览器） 包括：控制程序、客户协议和解释程序。控制程序：接收来自外设的输入并使用客户端程序来访问文档。文档被访问后，控制程序使用解释程序来在屏幕上显示文档。 网络服务器 为了提高效率，服务器通常将被请求的文件存储在内存的缓存中。为了定义一个网页，需要以下三个标识符：主机、端口和路径。外加协议。协议：绝大多数是HTTP，另外还有FTP等。主机：主机标识符可以是服务器的IP地址或主机被给及的唯一名称。端口：是一个16位的整数，通常为客户-服务器应用而预定义。比如用HTTP协议来访问网页，那么熟知端口号就是80.路径：定义了下层的操作系统中文件的位置和名称。比如，/top/next/last/myfile是一个唯一定义myfile文件的路径。 为了把这四部分组合在一起，设计出了统一资源定位符URL，其四个部分之间用三个不同的分隔符，如下所示： protocol://host/path 绝大多数使用 protocol://host:port/path 当需要标识出端口号时使用 万维网上的文档可以分成三类： 静态文档 动态文档 活动文档 超文本传输协议HTTPHTTP是一种用来定义客户服务器程序如何编写和如何从万维网获取网页的协议。 持续连接：HTTP1.1默认 非持续连接 报文格式： 请求报文 响应报文 Cookie 万维网起先被设计成无状态实体。客户发送请求；服务器响应。他们之间的关系就结束了。而cookie的设计使得客户端的信息存储在文件或字符串中而保存。 HTTP1.0的会话方式： 浏览器与WEB服务器的连接过程是短暂的，每次连接只处理一个请求和响应。对每一个页面的访问，浏览器与WEB服务器都要建立一次单独的连接。浏览器到WEB服务器之间的所有通讯都是完全独立分开的请求和响应对。 HTTP客户机和服务器会话的四个步骤：客户机-&gt;服务器：建立连接客户机-&gt;服务器：发出请求信息客户机&lt;-服务器：回送响应信息客户机&lt;-服务器：关闭连接 HTTP1.1的特点在一个TCP连接上可以传送多个HTTP请求和响应多个请求和响应过程可以重叠进行增加了更多的请求和响应头。 HTTP1.0 和HTTP1.1的区别1.0协议中，客户端与WEB服务器建立连接后，只能获得一个web资源。1.1协议中，允许客户端与web服务器建立连接后，在一个连接上获取多个web资源。 响应状态码典型情况：200：正常302/307：临时重定向，指出被请求的文档已被临时移动到别处。304：未修改，表示客户机缓存的版本是最新的，客户机应该继续使用它。403：禁止，服务器理解客户端请求，但拒绝处理它。通常由于服务器上文件的权限设置所致。404：找不到，服务器上不存在客户机请求的资源500,：内部服务器错误 万维网高速缓存：代理服务器 代理服务器是一台计算机，能够保存最近请求的响应的副本。HTTP客户端向代理服务器发送请求。代理服务器检查本地高速缓存。代理服务器降低了原服务器的负载，减少了通信量并降低了延迟。但是，为了使用代理服务器，必须配置客户端访问代理服务器而不是目标服务器。 HTTP安全HTTP本质上并不提供安全。然而，HTTP可以在安全套接层（SSL)上运行。这种情况下，HTTP称为HTTPS。HTTPS提供保密性好，客户和服务器鉴别，以及数据完整性。 Ping命令ping（Packet Internet Grope，因特网包探索器）是一个用于测试网络连接量的程序。 它使用的是ICMP，ping发送一个ICMP（Internet Control and Message Protocol，因特网控制报文协议）请求消息给目的地并报告是否收听到所希望的ICMP应答。 ICMP是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。它是用来检查网络是否通畅或者网络连接速度的命令。 当给目标IP地址发送一个数据包时，对方返回一个同样大小的数据包，根据返回的数据包可以确定目标主机的存在，可以初步判断目标主机的操作系统等。 域名解析过程在浏览器地址栏中键入URL，按下回车之后发生的几个事情： 浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址。 解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接； 浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器； 服务器给出响应，将对应的html文本发送给浏览器； 释放TCP连接； 浏览器将该文本显示出来。 OSI七层协议每层对应的相关协议第一层：物理层 第二层：数据链路层 802.2、802.3ATM、HDLC、FRAME RELAY 第三层：网络层 IP、IPX、APPLETALK、ICMP 第四层：传输层 TCP、UDP、SPX 第五层：会话层 RPC、SQL、NFS 、X WINDOWS、ASP 第六层： 表示层 ASCLL、PICT、TIFF、JPEG、 MIDI、MPEG 第七层：应用层 HTTP,FTP,SNMP等","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"yongchunxiaofen.top/categories/计算机网络/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"yongchunxiaofen.top/tags/HTTP/"},{"name":"C/S","slug":"C-S","permalink":"yongchunxiaofen.top/tags/C-S/"}]},{"title":"计算机网络（五）：运输层","slug":"computer-networks-05","date":"2016-07-09T09:56:30.000Z","updated":"2016-07-11T14:16:08.000Z","comments":true,"path":"2016/07/09/computer-networks-05/","link":"","permalink":"yongchunxiaofen.top/2016/07/09/computer-networks-05/","excerpt":"运输层协议概述进程之间的通信运输层向它上面的应用层提供通信服务。它属于面向通信部分的最高层，同时也是属于用户功能的最底层。 网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三次的功能。 从IP层来说，通信的两个端机是两个主机。 严格讲，通信的实体是两个主机中的进程。 IP协议虽然通过源地址和目的地址进行通信，将分组送到目的主机，但是这个分组停留在主机的网络层而没有交付给主机中的应用进程。，所以从运输层的角度来看，通信的真正端点并不是主机而是主机中的进程。 运输层一个很重要的功能： 复用（multiplexing）：指在发送方不同的应用进程都可以使用同一个运输层协议传送数据 分用（demultiplexing）：接收方的运输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。","text":"运输层协议概述进程之间的通信运输层向它上面的应用层提供通信服务。它属于面向通信部分的最高层，同时也是属于用户功能的最底层。 网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三次的功能。 从IP层来说，通信的两个端机是两个主机。 严格讲，通信的实体是两个主机中的进程。 IP协议虽然通过源地址和目的地址进行通信，将分组送到目的主机，但是这个分组停留在主机的网络层而没有交付给主机中的应用进程。，所以从运输层的角度来看，通信的真正端点并不是主机而是主机中的进程。 运输层一个很重要的功能： 复用（multiplexing）：指在发送方不同的应用进程都可以使用同一个运输层协议传送数据 分用（demultiplexing）：接收方的运输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。 运输层提供应用进程间的逻辑通信：表示运输层之间的通信好像是沿着水平方向传送数据。但事实上运输层并没有一条水平方向的物理连接。要传送的数据是沿着多个层次传送的。 网络层和运输层之间的区别： 网络层为主机之间提供逻辑通信 运输层为应用进程之间提供端到端的逻辑通信 根据应用程序的不同需求，运输层需要有两种不同的运输协议，即面向连接的TCP和无连接的UDP。 运输层向高层用户屏蔽了下面网络核心的细节，使应用进程看见的就是好像在两个运输层实体之间有一条端到端逻辑通信信道。 运输层采用面向连接的TCP协议时，尽管下面的网络是不可靠的，但这种逻辑通信信道就相当于一条全双工的可靠信道。 采用UDP协议时，仍然是一条不可靠信道。 传输层的两个主要协议 用户数据报协议UDP（User Datagram Protocol）：UDP用户数据报。传送数据时不需要先建立连接。 传输控制协议TCP（Transmission Control Protocol）：TCP报文段。数据传送前必须建立连接，传输结束后释放连接。 协要议端口号:端口。虽然通信的终点是应用进程，但我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作就由TCP来完成。 由此可见，两个计算机要进行通信，不但要知道对方的IP地址（为了找到对方的计算机），还需要知道对方的端口号（找到对方的计算机中的应用进程） TCP 和UDP的区别：TCP和UDP都是一种常用的通信方式，在特定的条件下发挥不同的作用，具体而言，两者的区别主要表现在以下几个方面： TCP是面向连接的传输控制协议，而UDP提供的是无连接的数据报服务。 TCP具有高可靠性，确保传输数据的正确性，不出现丢失或乱序；UDP传输时，不建立连接，不对数据报进行检查与修改，无需等待对方的应答，可能会出现分组丢失、重复、乱序等情况。 TCP对系统资源要求较多，UDP反之。 UDP具有较好的实时性，工作效率比TCP高。 UDP的段结构比TCP段结构简单，因此网络开销也小。 用户数据报协议UDPUDP只在IP的数据报服务之上增加了很少一点的功能，这就是复用和分用的功能以及差错检测的功能。UDP的主要特点有： UDP是无连接的。发送数据前不需要建立连接 UDP使用最大努力交付 UDP是面向报文的。UDP一次交付一个完整的报文。 图1.UDP是面向报文的 UDP没有阻塞控制 UDP支持一对一，一对多和多对一的交互通信 UDP首部开销小，只有8个字节，而TCP的首部为20个字节。 UDP的首部格式数据字段+首部字段 首部字段占用8个字节，包括四个字段，每个字段都是两个字节 源端口 目的端口 长度 检验和 图2.UDP基于端口的分用 传输控制协议TCP最主要的特点 面向连接的传输层协议，使用前先建立连接。 每一条TCP只能有两个端点，每一条TCP连接只能是点对点的。 提供可靠交付的服务。无差错、不丢失、不重复、安旭到达。 全双工通信，通信双发的应用进程在任何时候都能发送数据。 面向字节流。“流”指流入进程或者从进程流出的字节序列。 TCP的连接每一条TCP连接有两个端点，套接字（socket）或插口。端口号拼接到IP地址即构成了套接字。 套接字的表示方法：点分十进制的IP地址后面写上端口号，中间使用冒号或者逗号隔开。比如IP地址是192.3.4.5，而端口号是80.则套接字即为（192.3.4.5:80）。 每一条TCP连接唯一地被通信两端的两个端点（两个套接字）所确定。 TCP连接::={socket1,socket2}={(IP1:port1),(IP2:port2)} 可靠传输的工作原理停止等待协议停止等待：每发送完一个分组就停止发送，等待对方确认。收到确认后再发送下一个分组。 图3.停止等待协议的无差错情况 传输出现差错的情况B接收M1时检测出了问题，就直接丢弃M1，而不通知A。 可靠传输协议的设计思想是： A只要超过了一段时间仍然没收到确认，就认为刚才发送的分组丢失了，因而重新传送前面发送过的分组。这叫做超时重传。通过设置超时计时器来完成。 图4.停止等待协议的超时重传情况 应该注意的几点： A发送完一个分组之后，必须暂时保留已发送分组的副本。只有确认后才能清除暂时保留的分组副本。 分组和确认分组都必须编号。 超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。 确认丢失和确认迟到确认丢失时，会重新传送该分组，分组到达B时： 丢弃这个重复的分组M1，不向上层交付 向A发送确认 确认迟到时，也会进行超时重传，并且会收下迟到的确认但什么也不会做。 基于以上的确认和重传机制，可以在不可靠的传输网络上实现可靠的通信。像上述的这种可靠传输协议常常称为自动重传请求ARQ。 信道利用率为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发送完一个分组就停顿下来等地对方确认。这样可使信道上一直有数据不间断地在传送。 TCP报文段的首部格式首部+数据两部分 TCP的全部功能都体现在它首部中各字段的作用。 TCP报文前20个字节是固定的，后面的4N个字节是根据需要而增加的。因此最小长度是20个字节。包括以下部分： 源端口和目的端口，各占2个字节。 序号，占4个字节。 确认号 实际长度 保留 紧急URG。当URG=1时，表明紧急指针字段有效，提高优先级。 确认ACK（ACKnowledge）仅当ACK=1时确认号字段才有效。TCP规定，连接建立后所有传送的报文段都必须把ACK置为1. 推送PSH。 复位RST。当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接。 同步SYN。在连接建立时用来同步序号。SYN=1而ACK=0时，表明这是一个链接请求报文段。对方若同意建立连接，则在相应的报文段中SYN=1和ACK=1。因此，SYN置为1表示这是一个链接请求或链接接受报文。 终止FIN用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。 图5.TCP报文段的首部格式 TCP的运输连接管理TCP是面向连接的协议。运输连接是用来传送TCP报文的。TCP运输连接的建立和释放时每一次面向连接的通信中必不可少的过程。 因此，运输连接就有三个阶段：连接建立、数据传送、连接释放。 运输连接的管理就是使运输连接的建立和释放都能正常进行。 TCP连接建立过程中要解决三个问题： 使每一方都能确知对方的存在。 允许双方协商一些参数 能够对运输实体资源进行分配 TCP主动建立连接的应用进程叫做客户（client），而被动等待连接建立的应用进程叫做服务器（server）。 TCP的连接建立 图6.用三次握手建立TCP连接 如上图，主机A运行TCP客户程序，B运行TCP服务器程序。初始状态是两个进程都处于关闭状态。 A主动打开连接，B被动打开连接。 首先B的TCP服务器创建传输控制块TCB，准备接受客户进程的连接请求。服务器进程处于LISTEN状态，等待客户的连接请求。 A的TCP客户端进程也先创建传输控制块TCB，然后向B发出连接请求报文段，此时同部位SYN=1，同时选择一个初始序号seq=x。TCP规定，SYN报文段不能携带数据，但是消耗一个序号。完成之后，TCP客户进程进入SYN-SENT（同步已发送）状态。 B 收到连接请求报文段后，如果同意连接，则向A发送确认。确认报文段中应该把SYN和ACK位都置1，确认号是ack=x+1，同时也为自己选择一个初始序号seq=y。这个报文段也不能携带数据，但消耗一个序号。完成后，TCP服务器进程进入SYN-RCVD（同步收到）状态。 TCP客户端进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1，确认号ack=y+1，而自己的序号seq=x+1.此时，TCP建立，A进入ESTABLISHED(已建立连接)状态。 上面的连接建立过程叫做三次握手。 对于第三个过程——A发送确认——的解释： 主要是为了防止已失效的连接请求报文段突然又传送到了B而产生错误。——已失效连接主要由超时连接重发造成。 TCP的连接释放数据传输结束后，通信的双方都可以释放连接。 A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的FIN置1，其序号seq=u，u等于前面已经传送过的数据的最后一个字节的序号加1.此时进入FIN-WAIT-1状态，等待B的确认。 B收到连接释放报文后发出确认，确认号是ack=u+1，而这个报文段自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号加1.然后B进入CLOSE-WAIT（关闭等待）状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接被释放，此时TCP处于半关闭状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收。即B到A的连接并未关闭。A收到B的确认后，就进入FIN-WAIT-2的状态，等待B发出的连接释放报文段。 若B没有向A发送的数据，其应用进程通知TCP释放连接。此时报文段的连接释放报文段必须使FIN=1.假定B的序列号为w。B还必须重复上次已发送过的确认号ack=u+1.这时B进入了LAST-ACK（最后确认）状态，等待A的确认。 A在收到B的连接释放报文段后，必须对此发出确认。再确认报文段中把ACK置1，确认号ack=w+1，而自己的序号是seq=u+1.然后进入到TIME-WAIT状态。现在TCP连接还没有是放电，必须经过时间等待计时器设置的时间2MSL后，A才进入到CLOSED状态。时间MSL叫做最长报文段寿命，从A进入到TIME-WAIT状态后，经过2个MSL时间后才进入到CLOSED状态，才能开始建立下一个新的连接。当A撤销相应的传输控制块TCB后，就结束了这次的TCP连接。 图7.TCP连接释放的过程 关于A的TIME-WAIT状态必须等待2MSL时间的解释 为了保证A发送的最后一个ACK报文段能够到达B。在传输过程中，最后发送的确认信号ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到A已发送的FIN+ACK报文段的确认。这时，因为超时，B会重新传送FIN+ACK报文段。这样A就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着A重传一个确认，同时启动2MSL计时器。最后，AB都正常进入关闭状态。 防止“已失效的连接请求报文段”出现在本连接中。B只要收到了A的确认，就进入CLOSED状态。注意到B结束TCP连接的时间要比A早一些。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"yongchunxiaofen.top/categories/计算机网络/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"yongchunxiaofen.top/tags/TCP/"},{"name":"UDP","slug":"UDP","permalink":"yongchunxiaofen.top/tags/UDP/"}]},{"title":"计算机网络（四）：因特网的路由选择协议","slug":"computer-networks-04","date":"2016-07-07T02:37:23.000Z","updated":"2016-07-12T09:49:38.000Z","comments":true,"path":"2016/07/07/computer-networks-04/","link":"","permalink":"yongchunxiaofen.top/2016/07/07/computer-networks-04/","excerpt":"路由选择协议的几个基本概念理想的路由算法路由选择协议的核心就是路由算法。理想的路由选择算法应该具有如下一些特点： 算法必须是正确和完整的。正确是指：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的计算机。 算法在计算上应该简单 能够适应通信量和网络拓扑的变化，即具有自适应性 具有稳健性 公平性，对所有用户（除了少数优先用户）都是平等的。 算法应该是最佳的 从算法能否自适应进行调整来划分： 静态路由选择策略，非自适应路由选择：简单和开销较小，适用于简单的小网络。 动态路由选择策略 分层次的路由选择协议因特网采用的路由选择协议主要是自适应的，分布式路由选择协议。主要原因有： 因特网规模超大 许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议。 基于以上原因，因特网将整个互联网划分为许多较小的自治系统，记为AS。 尽管一个AS使用了多种内部路由选择协议和度量，但重要的事一个AS对其他AS表现出的是一个单一的和一致的路由选择策略。 目前的因特网中，一个大的ISP就是一个自治系统。这样因特网就把路由选择协议划分为两大类。 内部网关协议（IGP） 自治系统内部使用的路由选择协议。RIP和OSPF 外部网关协议（EGP) BGP-4","text":"路由选择协议的几个基本概念理想的路由算法路由选择协议的核心就是路由算法。理想的路由选择算法应该具有如下一些特点： 算法必须是正确和完整的。正确是指：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的计算机。 算法在计算上应该简单 能够适应通信量和网络拓扑的变化，即具有自适应性 具有稳健性 公平性，对所有用户（除了少数优先用户）都是平等的。 算法应该是最佳的 从算法能否自适应进行调整来划分： 静态路由选择策略，非自适应路由选择：简单和开销较小，适用于简单的小网络。 动态路由选择策略 分层次的路由选择协议因特网采用的路由选择协议主要是自适应的，分布式路由选择协议。主要原因有： 因特网规模超大 许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议。 基于以上原因，因特网将整个互联网划分为许多较小的自治系统，记为AS。 尽管一个AS使用了多种内部路由选择协议和度量，但重要的事一个AS对其他AS表现出的是一个单一的和一致的路由选择策略。 目前的因特网中，一个大的ISP就是一个自治系统。这样因特网就把路由选择协议划分为两大类。 内部网关协议（IGP） 自治系统内部使用的路由选择协议。RIP和OSPF 外部网关协议（EGP) BGP-4 内部网关协议（IGP）——RIP路由信息协议RIP是内部网关协议IGP中最先得到广泛使用的协议。 RIP是一种分布式的基于距离向量的路由选择协议，是因特网的标准协议，最大的特点是简单。 RIP协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录（距离向量）。 一路由器到直接连接的网络的距离定义为1 一路由到非直接连接的网络的距离定义为所经过的路由器数加1. RIP允许一条路径最多只能包含15个路由器。因此“距离为16即相当于不可到达。” 可见RIP只适用于小型互联网 RIP协议的特点： 仅和相邻路由交换信息 路由器交换的信息是当前本路由器所知道的全部信息，即自己的路由表。即交换的信息是“我到本自治系统中所有网络的最短距离，以及到每个网络应该经过的下一跳路由器。” 按固定的时间间隔交换路由信息。 路由表中最重要的信息就是： 到某个网络的距离，以及应经过的下一跳地址。 路由表更新的原则是找出到每个目的网络的最短距离。 路由信息协议RIP的工作过程路由信息协议RIP的设计思想，要求路由器周期性地向外发送路由刷新报文。路由刷新报文主要由若干（V，D）组成的表。V代表标识该路由器可以到达的目的网络或目的主机。D代表对应路由上的跳步数。 工作过程如下： 路由表的建立。对路由表（V，D）进行初始化，初始化时，路由器只包含所有与该路由器直接相连接的网络。此时（V，D）表中的距离都为0. 路由表信息的更新。路由表建立之后，路由器周期性地向外广播其（V，D）表中的内容。例如，假设路由1与路由2是一个自治系统中两个相邻的路由。路由器1接收到路由器2发送的（V，D）报文，路由器按照以下规律进行更新路由表信息： 如果路由器1中的路由表没有这一项记录，则在1中增加该项纪录，同时D加1. 如果路由器1的路由表的该项纪录比路由器2发送的记录距离D减1还要大，则路由器1在路由表中修改该项，距离D值根据路由器2提供的值加1.如下图所示。 图1.路由表信息更新的工作过程 路由选择协议RIP的特点是实现简单，只需要考虑距离，而不考虑连接路由器链路的带宽，但是它不适应大型或路由变化剧烈的互联网环境，对于中小规模的网络是是用的。 内部网关协议（IGP）——OSPF开放最短路径优先OSPF。是为了克服RIP的缺点开发出来的。 名词解释： 开放：OSPF协议不受厂商的限制 最短路径优先：指使用了Dijkstra提出的最短路径优先（SPF）算法 与RIP相比较，OSPF协议具有以下特点： OSPF主要特征是使用分布式链路状态协议，而RIP使用的是距离向量协议。 OSPF要求路由器发送的信息是本路由器与哪些路由器相邻，以及链路状态的度量。“度量”主要指：费用、距离、延时、带宽等。 OSPF链路状态改变时，使用洪泛法向所有路由器发送信息。而RIP仅向与自己相邻的路由器发送。 OSPF协议的路由器频繁交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。这个数据库存储着全网的拓扑信息。 为了适应很大规模的网络，OSPF协议要求将一个自治系统再划分为更小的范围，叫做区域。一个区域内的路由数不超过200个。 典型外部网关协议BGPBGP-4采用了路由矢量路由选择协议。 基本思想配置BGP时，每一个自治系统的管理员都要选择至少一个路由器（一般是BGP边界路由器）作为该自治系统的“BGP发言人。” BGP发言人与其他自治系统的发言人交换路由状态信息，如增加了新的路由，或是撤销过时的路由等。 BGP路由选择协议的工作过程 边界路由器初始化。刚运行时，与边界的BGP路由交换整个路由信息。而在此后，只有当发生变化时才更新有变化的部分，而不是像RIP或者OSFP那样定期更新。 BGP路由选择协议的4种分组 打开分组，与相邻的BGP发言人建立关系 更新分组，发送某一路由信息，或撤出多条路由 保持分组 通知分组 路由器的构成路由器是一种具有多个输入端口和多个输出端口的专用计算机，任务是转发分组。 工作模式：从某个输入端口收到的分组， 按照分组要去的目的地，把该分组从路由器的某个合适的输出端口转发给下一跳路由器。下一跳的路由器也按照这种方法处理分组，知道该分组到达终点为止。 路由器分为两个部分： 路由选择：控制部分，核心构件是路由选择处理机（根据路由选择协议构造出路由表，和相邻的路由器交换路由信息） 分组转发：交换结构（根据转发表对分组进行处理）、一组输入端口和一组输出端口。 虚拟专用网络VPN指明了一些专用地址，这些地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信。换言之，专用地址只能用做本地地址而不能用作全球地址。在因特网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发。RFC1918指明的专用地址是： 10.0.0.0到10.255.255.255（或记为10/8，它又称为24位块） 172.16.0.0到172.31.255.255（或记为172.16/12，它又称为20位块） 192.168.0.0到192.168.255.255（或记为192.168/16，又称为16位块） 上面的地址相当于一个A类网络、16个连续的B类网络和256个连续的C类网络。 专用IP也称为可重用IP 虚拟专用网络VPN（virtual private Network） 实现：IP隧道技术。 网络地址转换NAT网络地址转换NAT（Network Address Translation）需要在专用网连接到因特网的路由器上安装NAT软件。 装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。 图2.NAT路由器的工作原理","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"yongchunxiaofen.top/categories/计算机网络/"}],"tags":[{"name":"RIP","slug":"RIP","permalink":"yongchunxiaofen.top/tags/RIP/"},{"name":"OSFP","slug":"OSFP","permalink":"yongchunxiaofen.top/tags/OSFP/"}]},{"title":"计算机网络（三）：划分子网和构造超网","slug":"computer-networks-03","date":"2016-07-06T09:32:34.000Z","updated":"2016-07-06T13:17:13.000Z","comments":true,"path":"2016/07/06/computer-networks-03/","link":"","permalink":"yongchunxiaofen.top/2016/07/06/computer-networks-03/","excerpt":"划分子网一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网。 划分子网的方法是：从网络的主机号借用若干位作为子网号subnet-ID，当然主机号也就相应少了同样的位数。于是两级IP地址在本单位内部就变为三级IP地址、网络号、子网号和主机号。 也可以用以下记法来表示： IP地址::={&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;} 划分子网后IP地址由原来的两级结构变成了三级结构。划分子网只是把IP地址的主机号host-ID这部分进行再划分，而不改变IP地址 原来的网络号net-ID.","text":"划分子网一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网。 划分子网的方法是：从网络的主机号借用若干位作为子网号subnet-ID，当然主机号也就相应少了同样的位数。于是两级IP地址在本单位内部就变为三级IP地址、网络号、子网号和主机号。 也可以用以下记法来表示： IP地址::={&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;} 划分子网后IP地址由原来的两级结构变成了三级结构。划分子网只是把IP地址的主机号host-ID这部分进行再划分，而不改变IP地址 原来的网络号net-ID. 子网掩码： 子网掩码中的1对应于IP地址中原来的net-ID加上subnet-ID，而子网掩码中的0对应于现在的host-ID。下图d表示R1把子网掩码和收到的数据报的目的IP地址145.13.3.10逐位相与，得出了所要找的子网的网络地址。如下表所示： 图1.IP地址的各字段和子网掩码 对于不区分子网时使用子网掩码的说明：为了更便于查找路由表。 如果一个网络不划分子网，该网络使用的子网掩码为默认子网掩码。默认子网掩码中1的位置和IP地址中的net-ID正好相对应。若是采用默认子网掩码和某个不划分子网的IP地址逐位想与，能够得出该IP地址的网络地址。不用查该地址类别位便可知道是哪一类的IP地址。 A类地址的默认子网掩码是255.0.0.0B类地址的默认子网掩码是255.255.0.0C类地址的默认子网掩码是255.255.255.0 子网掩码是一个网络或一个子网的重要属性。 使用子网时分组的转发在划分子网后，路由表包含以下三项信息：目的网络地址，子网掩码和下一条地址。 分组转发算法： 从收到的数据报首部提取目的IP地址D 判断是否直接交付。 用各网络的子网掩码和D逐位相“与”，看结果是否和相应的网络地址匹配。 如果匹配，则直接交付（当然还需把D转换成物理地址，把数据报封装成帧发送出去。） 否则就是间接交付。 如果路由表中有目的地址为D的特定主机路由，则将数据报传送给路由表中所指明的下一跳路由器；如果没有，执行下一步。 对路由表中的每一行（包含目的网络地址、子网掩码、下一跳地址等信息），用其中的子网掩码和D逐位相“与”，其结果为N。 若N与该行的目的网络地址匹配，则将数据报传输给指明的下一跳路由器，否则执行下一步。 若路由器表中有一个默认路由，则将数据报传送给路由表中所指明的默认路由器；否则执行下一步。 报告转发分组出错。 总结成： 1.将本子网的子网掩码和目的地址的IP相与，得到网络地址。看是否在同一个子网络上。如果不在，则将分组交给源主机（发送主机）的默认路由器上，由该默认路由器转发。2.默认路由收到分组之后，看这一行的网络地址和收到的分组的网络地址是否匹配。使用这一行的子网掩码和收到的分组的目的地址相与，得出的网络地址和给出的网络地址进行比较，看是否一致。3.继续看下一行，用下一行的子网掩码和目的地址相“与”，如果得到的结果和路由表的网络地址相匹配，则苏红名该网络就是收到的分组所要寻找的目的网络 无分类编址CIDA（构造超网）CIDA构成无分类域间路由选择CIDR。CIDR的特点有两个： 消除了传统的A、B和C类地址以及划分子网的概念，因而可以更加有效地分配IPv4的地址空间。 CIDR将32位的地址空间划分为两个部分： 前面的部分是“网络前缀（前缀）”，用来指明网络。 后面的部分则用来指明主机 这样一来，CIDR使IP地址从三级编码又回到了两级编码，但这已是无分类的两级编码。记法为：IP地址::={&lt;网络前缀&gt;，&lt;主机号&gt;} CIDR还是用“斜线记法”，即在IP地址后面加上斜线“/”，然后写上网络前缀所占的位数。 例如：128.14.35.7/20，表示网络前缀占了20位。 CIDR将网络前缀都相同的连续IP地址组成一个CIDR地址块 例如， 128.14.35.7/20 化成二进制表示方式：128.14.35.7/20=10000000 00001110 00100011 00000111该地址所在的地址中的最小地址和最大地址可以很方便的得出。 最小地址： 128.14.32.0 10000000 00001110 00100000 00000000最大地址：128.14.47.255 10000000 00001110 00101111 11111111 一般可以使用地址块中的最小地址和网络前缀的位数表示这个地址块，例如上面的地址块可记为128.14.32.0/20.在不需要地址块的起始地址时，也可把这样的地址块简称为“/20地址块。” CIDA的子网掩码1的个数就是网络前缀的长度。斜线记法中，斜线后面的数字就是地址掩码中的1的个数。 CIDA中有许多地址，在路由表中利用CIDA地址块来查找目的网络，这种地址的聚合常称为路由聚合。 最长前缀匹配CIDR模式下路由表中的项目：网络前缀+下一跳地址 匹配时，选择前缀最长的网络前缀的路由。这叫做最长前缀匹配，是因为前缀越长，地址块越小，因而路由就越具体。最长前缀又称为最长匹配或最佳匹配。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"yongchunxiaofen.top/categories/计算机网络/"}],"tags":[{"name":"CIDR","slug":"CIDR","permalink":"yongchunxiaofen.top/tags/CIDR/"},{"name":"子网","slug":"子网","permalink":"yongchunxiaofen.top/tags/子网/"}]},{"title":"计算机网络（二）：网际协议IP","slug":"computer-networks-02","date":"2016-07-05T13:04:12.000Z","updated":"2016-07-12T02:27:35.000Z","comments":true,"path":"2016/07/05/computer-networks-02/","link":"","permalink":"yongchunxiaofen.top/2016/07/05/computer-networks-02/","excerpt":"网络层提供的两种服务因特网的设计思路：网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺。 这种设计思路可以使网络中的路由器可以做的比较简单，而且价格低廉。如果主机中的进程之间的通信需要是可靠的，就由网络的主机中的运输层负责（包括差错处理、流量控制等）。采用这种设计的好处是：网络的造价降低，运行方式灵活，能适应各种应用。 数据报数据报是通过网络传输的数据的基本单元，包含一个报头和数据本身。 报头：描述数据的目的地以及和其他数据之间的关系 数据 数据报是完备的、独立的数据实体，该实体携带要从源计算机传递到目的计算机的信息，该信息不依赖于以前在源计算机和目的计算机以及传输网络间的交换。 在IP网络中传输的数据单位称为IP数据包。IP数据包的报头至少为20个字节，其中包括版本号,报头长度，服务类型，数据报总长度，标识，标志，片偏移，生存时间，协议和头部校验和，源，目的IP地址，先项。","text":"网络层提供的两种服务因特网的设计思路：网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺。 这种设计思路可以使网络中的路由器可以做的比较简单，而且价格低廉。如果主机中的进程之间的通信需要是可靠的，就由网络的主机中的运输层负责（包括差错处理、流量控制等）。采用这种设计的好处是：网络的造价降低，运行方式灵活，能适应各种应用。 数据报数据报是通过网络传输的数据的基本单元，包含一个报头和数据本身。 报头：描述数据的目的地以及和其他数据之间的关系 数据 数据报是完备的、独立的数据实体，该实体携带要从源计算机传递到目的计算机的信息，该信息不依赖于以前在源计算机和目的计算机以及传输网络间的交换。 在IP网络中传输的数据单位称为IP数据包。IP数据包的报头至少为20个字节，其中包括版本号,报头长度，服务类型，数据报总长度，标识，标志，片偏移，生存时间，协议和头部校验和，源，目的IP地址，先项。 网际协议IP与IP配套使用的协议还有四个 地址解析协议ARP 逆地址解析协议RARP 网际控制报文协议ICMP 网际组管理协议IGMP 在IP网络层，其有如下关系： 图1.网际协议IP及其配套协议 上图中有两点需要注意： ICMP和IGMP画在了IP的上部，是因为它们需要使用IP协议 ARP和RARP画在了IP下边，因为IP经常要使用这两个协议 TCP/IP体系中的网络层通常称为网际层，或IP层。 将网络互联起来需要一些设备： 物理层使用的中间设备是转发器（repeater） 数据链路层使用的中间设备叫做网桥或者桥接器（bridge） 网络层使用的中间设备叫做路由器（router） 网络层以上使用的中间设备叫做网关（gateway） 分类的IP地址IP地址及其表示方法整个的因特网就是一个单一的、抽象的网络。IP地址就是给因特网上的每一个主机（或路由器）的每一个接口分配一个在全世界范围是唯一的32位的标识符。 IPv4的地址长度为32位，用点分十进制表示。通常的格式为X.X.X.X，其中每个X为8位，每个X的值为0~255. 分类的IP地址：将IP地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成： 第一个字段是网络号，标志主机所连接到的网络。一个网络号再整个因特网范围内必须是唯一的。 第二个字段是主机号，标志该主机。一个主机号在网络号所指明的范围内必须是唯一的。 由此可见，一个IP地址在整个因特网范围内是唯一的。 这种两级IP地址可以记为： IP地址::={&lt;网络号&gt;,&lt;主机号&gt;} 其中的::=表示“定义为”。 图2.IP地址中的网络号字段和主机号字段 其中： A、B和C类地址的网络号字段分别为1、2和3个字节长 三类的主机号又分别为3、2和1个字节长。 D类地址（前4位是1110）用于多播。 E类地址保留为今后使用 A类地址的网络号第一位为0，其余7位可以分配。因此A类地址共有128块，每一块net ID不同。第一块覆盖的地址范围为：0.0.0.0~0.255.255.255（net ID=0）第二块覆盖的地址范围为：1.0.0.0~1.255.255.255（net ID=1）最后一块覆盖的地址范围为：127.0.0.0~127.255.255.255（net ID=127）由于网络号为全0的地址和首位为0，其余全为1的A类地址留作特殊用途，其余126块可以分配。所有A类IP地址的网络只有126个。使用A类IP的网络称为A类网络。 IP地址的一些重要特点： 每一个IP地址都由网络号和主机号两部分组成 IP地址管理分配IP时只分配网络号，剩下的主机号则由得到该网络的号的单位执行分配。 路由器仅根据目的主机所连接的网络号来转发分组 IP地址是标志一个主机和一条链路的接口 一个网络是指具有相同网络号net-ID的主机的集合 IP地址中，所有分配到网络号的网络都是平等的 对于互联网中的IP地址，有以下需要注意的： 在同一个局域网上的主机或路由器的IP地址中的网络号必须是相同的 用网桥互联的网段仍然是一个局域网 路由器总是具有两个或两个以上的IP地址 当两个路由器直接相连时，在连线两端的接口处，可以分配也可以不分配IP地址。现在为了节省IP资源，常常不分配IP地址。 IP地址与硬件地址物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址。 发送数据时，数据从高层往下层传输，当传送到数据链路层时，数据链路层会将IP数据报封装成MAC帧。MAC帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在ＭＡＣ帧的首部中。 IP地址放在IP数据报的首部，硬件地址则放在MAC帧的首部。在网络层和网络层以上使用的是IP地址，而数据链路层及以下使用的是硬件地址。 有如下模型，三个局域网使用两个路由器R1和R2连接起来。主机H1要和主机H2通信。这两个主机的IP地址分别是IP1和IP2，而他们的硬件地址分别是HA1和HA2. 通信的路径是：H1-&gt;经过R1转发-&gt;在经过R2转发-&gt;H2.路由器R1因同时连接到两个局域网上，有两个硬件地址，即HA3和HA4。同理，路由器有两个硬件地址HA5和HA6. 图3.从不同层次看IP地址和硬件地址上图：网络配置；下图，不同层次，不同区间的源地址和目的地址 需要强调的是： IP层抽象的互联网上只能看到IP数据报 局域网的链路层，只能看到MAC帧。IP数据报被封装在MAC帧中。 尽管互联在一起的网络的硬件地址体系不同，但IP层抽象的互联网却屏蔽了下层这些很复杂的细节。只要我们在网络层上讨论问题，就能使用统一的、抽象的IP地址研究主机和主机或路由器之间的通信 地址解析协议ARP和逆地址解析协议RARPARP可以通过IP地址找出相应的物理地址。RARP相反。 图4.ARP和RARP协议的作用 地址解析协议ARP的工作流程： 1.ARP进程在本局域网上广播发送一个ARP请求分组；2.在本局域网上所有主机上运行的ARP进程都能收到此ARP请求分组；3.主机B在ARP分组中见到自己的IP地址，就向A发送ARP响应分组，并写入自己的硬件地址；4.主机A收到B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射。 RARP协议：逆地址协议，允许局域网的物理机器从网关服务器的ARP表或者缓存上请求其IP地址。 IP数据报的格式IP数据报能够说明IP协议都能具有什么样的功能。 TCP/IP标准中，数据格式常常以32位为单位来描述，如下图所示是IP数据报的完整格式。 IP数据报包括首部和数据部分其中，首部包含固定部分和可变部分。固定部分占用20个字节。 图5.IP数据报的格式","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"yongchunxiaofen.top/categories/计算机网络/"}],"tags":[{"name":"网际协议","slug":"网际协议","permalink":"yongchunxiaofen.top/tags/网际协议/"},{"name":"IP","slug":"IP","permalink":"yongchunxiaofen.top/tags/IP/"}]},{"title":"计算机网络（一）：计算机网络概述","slug":"computer-networks-01","date":"2016-07-04T12:24:43.000Z","updated":"2016-07-04T12:38:40.000Z","comments":true,"path":"2016/07/04/computer-networks-01/","link":"","permalink":"yongchunxiaofen.top/2016/07/04/computer-networks-01/","excerpt":"计算机网络最重要的两功能 连通性 交换信息 共享 信息共享 硬件共享 软件共享 网络：由若干结点和连接结点的链路组成。 网络将许多计算机连接在一起，而因特网则把许多网络连接在一起。 ISP：Internet Service Provider，互联网服务提供者，因特网服务提供商。 因特网的组成 边缘部分 由所有连接在因特网上的主机组成。用户直接使用 核心部分 由大量网络和连接这些网络的路由器组成。为边缘部分提供服务 计算机通信：主机A的某个进程和主机B上的另一个进程进行通信 网络边缘的终端系统中运行的程序之间的通信方式可分为： 客户服务器方式（C/S方式）：client-server 客户是服务请求方，服务器是服务提供方。 服务请求方和服务提供方都要使用网络核心部分所提供的服务 对等方式（P2P方式）：Peer-to-Peer方式 客户程序和服务器程序的一些特点：","text":"计算机网络最重要的两功能 连通性 交换信息 共享 信息共享 硬件共享 软件共享 网络：由若干结点和连接结点的链路组成。 网络将许多计算机连接在一起，而因特网则把许多网络连接在一起。 ISP：Internet Service Provider，互联网服务提供者，因特网服务提供商。 因特网的组成 边缘部分 由所有连接在因特网上的主机组成。用户直接使用 核心部分 由大量网络和连接这些网络的路由器组成。为边缘部分提供服务 计算机通信：主机A的某个进程和主机B上的另一个进程进行通信 网络边缘的终端系统中运行的程序之间的通信方式可分为： 客户服务器方式（C/S方式）：client-server 客户是服务请求方，服务器是服务提供方。 服务请求方和服务提供方都要使用网络核心部分所提供的服务 对等方式（P2P方式）：Peer-to-Peer方式 客户程序和服务器程序的一些特点： 客户服务器方式客户程序： 被用户调用后运行，通信时请求服务，客户程序必须知道服务器程序的地址 不需要特殊的硬件和很复杂的操作系统 服务器程序： 专门用来提供某种服务的程序，可同时处理多个任务 启动后一直不断运行，被动等待并接受通信请求。服务器程序不需要知道客户程序地址。 需要强大的硬件和高级操作系统的支持 对等连接方式两个主机在通信时并不区分哪一个是服务请求还是服务提供方。只要两个主机都运行了对等连接软件（P2P软件），就可以进行平等的通信。P2P文件共享。 交换方式的比较 电路交换：整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。 报文交换：整个报文先到达相邻节点，全部存储下来后查找转发表，转发到下一个结点。 分组交换：单个分组（只是整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转发到下一个结点。 计算机网络在我国的发展1994年4月20日我国用64kb/s专线正式连入因特网。 计算机网络的类别不同种类的网络不同作用范围 广域网（WAN，Wide Area Network），因特网的核心部分。 城域网（MAN，Metropolitan Area Network），以太网技术 局域网（LAN，Local Area Network），高速通信 个人局域网（PAN，Personal Area Network），在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络 不同使用者 公用网 专用网 计算机网络的性能性能指标 速率：[比特（bit，binary digit，二进制数字）]，使用比特流衡量，b/s（比特每秒）或者bit/s，也写成bps，即bit per second。数据较高时，使用kb/s,Mb/s,Gb/s或者Tb/s等。 带宽： 本来指某个信号具有的频带宽度 计算机网络中，带宽用来指网络的通信线路所能传送数据的能力。这种意义上的带宽单位是“比特每秒”，这种单位的前面也常常加上千（k）,兆（M），吉（G）这样的倍数。 吞吐量：单位时间内通过某个网络的数据量 实际用于对现实网络的一种测量。 时延：数据从网络的一端传送到另一端所需的时间。也称为延迟或者迟延 发送时延，主机等发送数据所需要的时间，从发送第一个比特到最后一个比特发送完毕需要的时间。发送时延=数据帧长度（b）/信道带宽（b/s） 传播时延，电磁波在信道中传播一定的距离需要花费的时间。 处理时延 …… 时延带宽积：传播时延和带宽相乘得到。 表示这样的链路可容纳多少个比特 链路的时延带宽积称为：以比特为单位的链路长度 往返时间RTT 利用率 网络协议三要素 语法 语义 同步 五层协议的结构自上而下分别为： 应用层：体系结构中的最高层。该层直接为用户的应用进程提供服务。因特网中支持应用层协议的有很多。 万维网应用的HTTP协议 支持电子邮件的SMTP协议 支持文件传送的FTP协议等 运输层：负责向两个主机中进程之间的通信提供服务。运输层使用以下两种协议 传输控制协议（TCP，Transmission Control Protocol）——面向连接的，数据传输的单位是报文段，能够提供可靠的交付。 用户数据报协议（UDP）——无连接的，数据传输的单位是用户数据报，只提供“尽最大努力交付” 网络层（Network layer）：负责为分组交换网上的不同主机提供通信服务。 将运输层产生的报文段或用户数据报封装成分组或包进行传输。 另一个任务是：选择合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。 因特网最主要的网络层协议是无连接的网际协议IP（Internet Protocol）和许多种路由选择协议，因特网的网络层也叫做网际层或IP层 数据链路层 该层：在两个相邻的结点之间传送数据时，数据链路层将网络层交下来的IP数据报组成成帧，在两个相邻节点的链路上“透明地”传送帧中的数据。帧中包含 数据和必要的控制信息（同步信息、地址信息、差错信息等） 物理层 传输的基本单位是比特。 任务是：透明地传送比特流 请求评价（request for comments，RFC）文档。阅读RFC文档时需要注意两点问题： 确定其是最新的文档 注意RFC文档的类别 捋一捋复杂的关系实体：可以表示任何可发送或接收信息的硬件或软件进程。 协议：控制两个对等实体进行通信的规则的集合。 协议的控制下，两个对等的实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。首先，协议的实现保证了能够向上一层提供服务。使用本层服务的实体只能看见服务而无法看见下面的协议，下面的协议对上面的实体是透明的。 服务与协议的关系 协议是“水平的”，即协议是控制对等实体之间通信的规则 服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。 只有那些被高一层实体“看得见”的功能才能称之为“服务” TCP/IP协议该协议的应用层和网络接口层都有多种协议，而中间的IP层很小，上层的各种协议都向下汇聚到一个IP协议中。 这种TCP/IP协议族表明：TCP/IP协议可以为各式各样的应用提供服务，同时TCP/IP协议也允许IP协议在各式各样的互联网上运行。 图1.TCP/IP协议族示意图","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"yongchunxiaofen.top/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"yongchunxiaofen.top/tags/计算机网络/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"yongchunxiaofen.top/tags/TCP-IP/"}]},{"title":"操作系统学习（八）：段式内存管理","slug":"operator-system-8","date":"2016-07-03T08:58:49.000Z","updated":"2016-07-03T09:22:06.000Z","comments":true,"path":"2016/07/03/operator-system-8/","link":"","permalink":"yongchunxiaofen.top/2016/07/03/operator-system-8/","excerpt":"分页系统的缺点分页系统的缺点 共享困难 一个进程只能占有一个虚拟地址空间 造成的问题就是，一个程序的大小至多只能和虚拟空间一样大，其所有的内容必须从这个共同的虚拟空间分配。 基于以上的这些麻烦引出了分段管理系统 分段管理系统分段管理：将一个程序按照逻辑单元分成多个程序段，每一个段使用自己单独的虚地址空间。 例如对于编译器来说，可以分成编译器工作所需要的5个段，占用5个虚地址空间。 图1.编译器程序5个虚地址空间以解决空间增长困难的问题","text":"分页系统的缺点分页系统的缺点 共享困难 一个进程只能占有一个虚拟地址空间 造成的问题就是，一个程序的大小至多只能和虚拟空间一样大，其所有的内容必须从这个共同的虚拟空间分配。 基于以上的这些麻烦引出了分段管理系统 分段管理系统分段管理：将一个程序按照逻辑单元分成多个程序段，每一个段使用自己单独的虚地址空间。 例如对于编译器来说，可以分成编译器工作所需要的5个段，占用5个虚地址空间。 图1.编译器程序5个虚地址空间以解决空间增长困难的问题 基本的内存管理，每一个程序被分为一段，而这里分段管理是将一个程序分成多个段。 将基本内存管理的段式管理称为纯粹分段，而一个程序分为多个段的分段管理成为逻辑分段 分段的优缺点优点： 每个逻辑单元可独占一个虚拟空间，使得编写程序的空间大为增长 段式按逻辑关系而分，共享方便 空间稀疏的程序来说，分段管理将节省大量的空间。 缺点： 外部碎片 一个段必须全部加载到内存 对程序里面的段进行分页，形成段页式内存管理模式。 段页式内存管理这种内存管理的模式是将程序分成多个逻辑段，在每个段里面又进行分页，即将分段和分页组合起来使用。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"yongchunxiaofen.top/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"yongchunxiaofen.top/tags/操作系统/"},{"name":"段式内存管理","slug":"段式内存管理","permalink":"yongchunxiaofen.top/tags/段式内存管理/"}]},{"title":"操作系统学习（七）：分页存储管理","slug":"operator-system-7","date":"2016-07-03T08:58:38.000Z","updated":"2016-07-03T09:14:03.000Z","comments":true,"path":"2016/07/03/operator-system-7/","link":"","permalink":"yongchunxiaofen.top/2016/07/03/operator-system-7/","excerpt":"交换产生的问题： 内存和磁盘的交换产生碎片 地址空间增长困难 空间增长效率低下 空间增长存在“天花板”限制 解决办法碎片产生的原因：每个程序大小不同 解决办法：将空间按照某种规定大小进行分配。只要将虚拟内存与物理内存都分成大小一样的部分，我们称为页。然后按页分配，即可以克服碎片问题。 解决空间增长受限的原因：一个程序需要完全加载到内存中才可以运行 解决办法：使程序无需全部加载就可以运行。 用分页的思想处理：将当前需要的页面放在内存中，暂时不用的页面放在磁盘上。","text":"交换产生的问题： 内存和磁盘的交换产生碎片 地址空间增长困难 空间增长效率低下 空间增长存在“天花板”限制 解决办法碎片产生的原因：每个程序大小不同 解决办法：将空间按照某种规定大小进行分配。只要将虚拟内存与物理内存都分成大小一样的部分，我们称为页。然后按页分配，即可以克服碎片问题。 解决空间增长受限的原因：一个程序需要完全加载到内存中才可以运行 解决办法：使程序无需全部加载就可以运行。 用分页的思想处理：将当前需要的页面放在内存中，暂时不用的页面放在磁盘上。 分页内存管理核心：将虚拟内存空间和物理内存空间划分为大小相同的页面，并以页面作为内存空间分配的最小单位 分析：这样分配之后，物理空间是页面的整数倍，并且空间分配以页面为单位，将不会产生外部碎片。 分页系统下：一个程序发出的虚拟地址由 页面号和页内偏移值 组成。 页面号 页内偏移地址 X Y 图1.虚拟地址构成 页面寻址的方法克服了交换系统所有的缺陷 地址翻译分页系统的核心：页面的翻译，即从虚拟页面到物理页面的映射。由内存管理单元（MMU）完成。 翻译过程：MMU接收由CPU发出的虚拟地址，将其翻译为物理地址后发送给内存。内存单元按照物理地址进行相应访问后读出或写入相关数据。 对于每个程序，MMU都为其保存一个页表，该表里存放的是虚拟页面到物理页面的映射。 图2.虚拟页面到物理页面的翻译过程 页表页表的根本功能是提供虚拟页面到物理页面的映射。 MMU依赖页表进行一切与页面有关的管理活动。这些活动包括判断某一页面号是否在内存里，页面是否受到保护，页面是否有非法空间等。 页表的功能除了提供虚拟到物理页的映射外，还记录以下相关信息。 缓存禁止 访问位 修改位 保护标识区 在内存否 物理页面号 图3.页表记录内容举例 缓存禁止：指示页面是否允许放在缓存里 访问位记录：该页面是否被访问过 修改位：该页面自从加载到物理内存后是否被修改过 保护标识位：记录该页的受保护情况，如是否允许读写执行等。 在内存否：记录该虚拟页面是否已经在物理内存里 物理页面号：该虚拟页面对应的物理页面（如果该虚拟页面已经映射到物理内存的话） 多级页表多级页表根据存放的内容分为：顶级页表，一级页表、二级页表等。 顶级页表中存放一级页表的信息，一级页表存放二级页表的信息。最后一级页表中存放的才是虚拟页面到物理页面的映射。 程序运行时，顶级页表常驻内存，次级页表按需要决定是否放在物理内存。 假如：使用两层页表，虚拟地址的前10位可作为顶级页表的索引，中间10位可作为次级页表索引，最后12位可作为页内偏移值。 CPU发出一个虚拟地址时，将虚拟地址一分为三。用最前面的10位值找到顶级页表对应记录，得到次级页表。用中间10位值作为索引在刚才获得的次级页表中找到对应的记录，得到对应的物理页面号。然后再物理页面号与页内偏移值合并起来获得最后的物理地址。 多级页表的缺点：因为内存访问要经过好多次访问，所以降低了系统的速度。 由于产生缺页中断需要更换页面分页系统下，一个程序的所有页面不一定都在内存中，这样，在执行的过程中就可能发生页面不在内存的情况。 如果访问的页面不存在，则系统发生却也中断。缺页中断服务程序将负责把位于磁盘上的数据加载到物理内存上。如果物理内存还有空闲页面，直接使用空闲的页面。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"yongchunxiaofen.top/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"yongchunxiaofen.top/tags/操作系统/"},{"name":"分页管理","slug":"分页管理","permalink":"yongchunxiaofen.top/tags/分页管理/"}]},{"title":"操作系统学习（六）：基本内存管理","slug":"operator-system-6","date":"2016-07-03T08:58:22.000Z","updated":"2016-07-03T09:07:25.000Z","comments":true,"path":"2016/07/03/operator-system-6/","link":"","permalink":"yongchunxiaofen.top/2016/07/03/operator-system-6/","excerpt":"内存管理的两个目标： 地址保护：一个进程不能随意访问另一个程序地址空间 地址独立：程序发出的地址应与物理主存地址无关 针对第二条地址独立做一些说明： 程序在加载到内存中然后执行一条条的指令。指令执行时需要读取操作数和写入运算结果。而读取操作数是通过地址来寻址，这个地址不能是物理地址。因为不能确定程序可能会在什么配置的机子上运行，每个机子的物理地址不同。所以读取操作数的地址应该是程序发出的一个虚拟地址，这个地址是与具体的硬件无关的。（程序可以跨平台，与硬件配置无关） 虚拟内存虚拟内存的中心思想是将主存扩大到便宜，大容量的磁盘上，将磁盘看作主存的一部分。 内存管理系统的中心功能：对程序所在位置（主存，缓存，磁盘）的判断","text":"内存管理的两个目标： 地址保护：一个进程不能随意访问另一个程序地址空间 地址独立：程序发出的地址应与物理主存地址无关 针对第二条地址独立做一些说明： 程序在加载到内存中然后执行一条条的指令。指令执行时需要读取操作数和写入运算结果。而读取操作数是通过地址来寻址，这个地址不能是物理地址。因为不能确定程序可能会在什么配置的机子上运行，每个机子的物理地址不同。所以读取操作数的地址应该是程序发出的一个虚拟地址，这个地址是与具体的硬件无关的。（程序可以跨平台，与硬件配置无关） 虚拟内存虚拟内存的中心思想是将主存扩大到便宜，大容量的磁盘上，将磁盘看作主存的一部分。 内存管理系统的中心功能：对程序所在位置（主存，缓存，磁盘）的判断 单道程序的内存管理静态地址翻译：内存中只有两个程序，操作系统和用户程序。操作系统每次定位到同一个地方来启动用户程序，这样用户程序里面的地址都可以事先计算出来，运行前就计算出所有物理地址。称之为静态地址翻译 多道程序的内存管理动态地址翻译：程序运行时进行地址翻译 固定分区： 所有用户程序排成一列等到分区中的程序执行，有空缺则队列前边的程序补上(如图1所示) 按照程序大小排成不同的队列等候在不同的分区后边（如图2所示） 地址翻译的方法：物理地址=虚拟地址+程序所在区域起始地址(基址) 非固定分区的内存管理：除了划分给操作系统的空间外，其余的内存空间是作为一个整体存在的。 非固定分区的缺点：每个程序像叠罗汉一样累计，如果该程序需要更多空间则无法再重新分配。针对非固定分区缺点的解决办法：在给每个程序分配空间时留有一定的增长空间。如图3所示。 图1.共享队列的固定分区 图2.分开队列的固定分区 虚拟内存的根本是将内存扩展到磁盘上，将磁盘当成是内存的一部分。 图3.程序执行过程中的空间增长 图4.数据和栈的生长方式","categories":[{"name":"操作系统","slug":"操作系统","permalink":"yongchunxiaofen.top/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"yongchunxiaofen.top/tags/操作系统/"},{"name":"内存管理","slug":"内存管理","permalink":"yongchunxiaofen.top/tags/内存管理/"}]},{"title":"操作系统学习（五）：死锁","slug":"operator-system-5","date":"2016-06-30T09:07:38.000Z","updated":"2016-06-30T13:45:38.000Z","comments":true,"path":"2016/06/30/operator-system-5/","link":"","permalink":"yongchunxiaofen.top/2016/06/30/operator-system-5/","excerpt":"死锁死锁发生的原因归根结底是对资源的竞争。大家都想要某种资源，但是却不能随心所欲的得到资源，在争夺的僵局中，谁都无法继续推进。 资源：一般一个程序工作时所需要的东西：磁盘驱动器，锁、信号量、数据表格等。既可以是软件资源也可以是硬件资源。 资源又可以分为：可抢占资源和不可抢占资源。 死锁的描述：如果有一组线程，每个线程都在等待一个事件的发生，而这个事件只能由该组线程里面的另一线程发出，称这组线程发生死锁。 这里的事件通常指资源的释放。 死锁发生的四个必要条件 资源有限。（也称为资源互斥条件，即资源不能共享，在一个时刻只能由一个线程使用） 持有等待。（一个线程在请求新线程时，已经获得的资源不释放，而是继续持有。） 不能抢占。 循环等待条件。","text":"死锁死锁发生的原因归根结底是对资源的竞争。大家都想要某种资源，但是却不能随心所欲的得到资源，在争夺的僵局中，谁都无法继续推进。 资源：一般一个程序工作时所需要的东西：磁盘驱动器，锁、信号量、数据表格等。既可以是软件资源也可以是硬件资源。 资源又可以分为：可抢占资源和不可抢占资源。 死锁的描述：如果有一组线程，每个线程都在等待一个事件的发生，而这个事件只能由该组线程里面的另一线程发出，称这组线程发生死锁。 这里的事件通常指资源的释放。 死锁发生的四个必要条件 资源有限。（也称为资源互斥条件，即资源不能共享，在一个时刻只能由一个线程使用） 持有等待。（一个线程在请求新线程时，已经获得的资源不释放，而是继续持有。） 不能抢占。 循环等待条件。 死锁的经典问题-哲学家就餐问题死锁处理 死锁预防 死锁避免 死锁检测和修复 处理死锁的综合方法 死锁预防死锁预防就是防止死锁发生的可能性。从萌芽状态杀死死锁发生的必要条件。 分为：间接方法和直接方法。间接方法是防止产生死锁的前三个条件：资源有限（互斥），持有等待、非抢占 直接方法是防止第四个条件：循环等待 消除资源独占条件 增加资源（××） 资源共享 消除保持和请求条件 一个进程必须一次请求其所需要的所有资源，而不是一般情况下的请求一点资源，做一点事情。其拥有程序执行必须得资源，因此不用去竞争资源，所以不会发生死锁。 消除非抢占条件 允许对资源进行抢占 消除循环等待条件循环等待的原因是因为进程请求资源的顺序是随机的，一个进程可以先请求资源A再请求B，也可以先请求B再请求A。所以如果将资源的使用顺序固定，则死锁将不会发生。 死锁避免死锁避免使在进程申请资源时先判断这次分配是否安全，如果安全才实施分配。 死锁避免的两种方式 如果进程对资源的申请可能导致死锁，则不启动这个进程(从进程方面着手) 如果进程对资源的申请可能导致死锁，则不给进程分配该资源 （从资源方面着手） 死锁避免的缺点 进程预先申明资源的最大量需求 进程必须是独立的 资源和进程的数目必须固定 死锁检测一种方法是画出资源占用和资源需求关系的有向图，然后查看是否有循环。如果有循环，则说明有死锁。否则，无死锁。 但是这种方法实际操作难度较大。故不采用。 另一种算法是利用矩阵。用到的两个矩阵分别是：资源分配矩阵和资源等待矩阵。 资源分配矩阵里，行列交叉的数值代表该进程已经拥有该资源的数量。 资源等待矩阵里，行列交叉的值表示进程需要等待的特定资源的数量。 NULL 资源1 资源2 资源3 资源4 资源5 进程1 – 2 1 3 2 进程2 7 – 3 2 5 进程3 4 6 – 3 2 进程4 3 2 1 – 1 进程5 3 5 4 3 – 图1. 资源分配矩阵 NULL 资源1 资源2 资源3 资源4 资源5 进程1 3 2 2 1 0 进程2 0 6 1 0 0 进程3 0 0 3 1 1 进程4 1 1 0 2 1 进程5 0 0 0 0 2 图2. 资源等待矩阵 NULL 资源1 资源2 资源3 资源4 资源5 系统资源总量 20 20 10 15 10 图3. 系统资源总量 NULL 资源1 资源2 资源3 资源4 资源5 系统资源总量 3 5 1 4 0 图4. 系统当前可用资源数量 判断算法：将可用资源拿来与资源等待矩阵的每一行进行比较，如果减出来，每一个进程都有负数，则有可能发生死锁 例如上述表格中，系统可用资源与等待矩阵的每一行相减，每一行都出现了负数值。则说明有可能发生死锁。 死锁恢复死锁恢复的基本方法就是：剥夺 按复杂度增加次序排列 杀死所有进程 死锁进程回滚到已定义的监测点，重新执行他们 逐个杀死进程知道死锁消除 逐个抢占其他进程的资源知道死锁消失","categories":[{"name":"操作系统","slug":"操作系统","permalink":"yongchunxiaofen.top/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"yongchunxiaofen.top/tags/操作系统/"}]},{"title":"操作系统学习（四）：进程同步","slug":"operator-system-4","date":"2016-06-30T09:07:29.000Z","updated":"2016-06-30T13:45:52.000Z","comments":true,"path":"2016/06/30/operator-system-4/","link":"","permalink":"yongchunxiaofen.top/2016/06/30/operator-system-4/","excerpt":"进程同步线程同步的目的 不管线程之间的执行如何穿插，其运行结果都是正确的。保证多线程执行下结果的确定性。 效率 线程同步：让所有的线程按照一定的规则执行，使其正确性和效率都有迹可循。 同步手段：对线程之间的穿插进行控制 竞争：两个或者多个线程争相执行同一段代码或访问同一资源的现象 临界区：可能造成竞争的共享代码或资源成为临界区 互斥：一次仅有一个人使用共享资源，其他人皆排除在外。 锁两个基本操作：闭锁和开锁 两个步骤：1）：等待锁达到打开状态2）：获得锁并锁上 锁的基本特性： 初始状态为打开 进临界值前必须获得锁 出临界值前必须打开锁 别人持有锁的时候必须等待","text":"进程同步线程同步的目的 不管线程之间的执行如何穿插，其运行结果都是正确的。保证多线程执行下结果的确定性。 效率 线程同步：让所有的线程按照一定的规则执行，使其正确性和效率都有迹可循。 同步手段：对线程之间的穿插进行控制 竞争：两个或者多个线程争相执行同一段代码或访问同一资源的现象 临界区：可能造成竞争的共享代码或资源成为临界区 互斥：一次仅有一个人使用共享资源，其他人皆排除在外。 锁两个基本操作：闭锁和开锁 两个步骤：1）：等待锁达到打开状态2）：获得锁并锁上 锁的基本特性： 初始状态为打开 进临界值前必须获得锁 出临界值前必须打开锁 别人持有锁的时候必须等待 信号量同步原语 &amp;&amp; 通信原语，还可以当成锁来使用 semaphore说白了就一计数器。其取值为当前累积的信号数量。 支持两个操作：加法操作Up 和 减法操作Down Down减法操作： 判断信号量的取值，如果信号量 &gt;= 1,则将信号量的值减1，继续往下执行 如果信号量&lt;1，在该信号量上等待（线程挂起） Up加法操作： 将信号量的值加1（该操作叫醒一个在该信号量上等待的线程） 线程继续执行 注*：虽然Down和Up操作有多个步骤，可是这些步骤是一组原子操作，不可分开执行。 二元信号量：将信号量的取值限制为0和1的两种情况，则获得一把锁，也成为二元信号量。 二元信号量的功能和锁非常相似，Down就是获得锁，而Up就是释放锁。 信号量能够轻而易举的解决生产者和消费者的同步问题 P，V操作信号量执行的操作：初始化，P和V P表示信号量值减1，当信号量小于0时，进程置为阻塞态，重新调度。downV表示信号量加1：Up 管程基于信号量繁多时，程序编写困难效率低下而提出。 管程（Monitor）：监视的是进程或线程的同步操作。 具体来讲，管程就是：一组子程序、变量和数据结构的组合。 一个管程的例子： 1234567891011begin monitor int i; condition c; procedure producer(); ... end; procedure consumer(); ... endend monitor 编译器保证只能有一个线程活跃在管程里面。编译器看到begin monitor和end monitor之间时就知道期间的代码需要同步保护。 管程中的同步机制：所用来互斥，条件变量用来控制执行的顺序。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"yongchunxiaofen.top/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"yongchunxiaofen.top/tags/操作系统/"}]},{"title":"操作系统学习（三）：线程","slug":"operator-system-3","date":"2016-06-30T09:07:22.000Z","updated":"2016-06-30T13:46:05.000Z","comments":true,"path":"2016/06/30/operator-system-3/","link":"","permalink":"yongchunxiaofen.top/2016/06/30/operator-system-3/","excerpt":"线程同一个地址空间里面的所有线程构成了进程 线程模式下，一个进程至少有一个线程，也可以有多个线程。 线程管理线程管理：线程控制表/线程控制块 能被线程共享的资源存放在进程控制块中，不能被线程共享的资源存放在线程控制块中。 为了提高协作，希望线程间可以共享的资源越多越好。 一般的标准是：如果某资源独享会导致线程运行错误，则该资源就由线程独享，反之，如果不发生错误，就共享。","text":"线程同一个地址空间里面的所有线程构成了进程 线程模式下，一个进程至少有一个线程，也可以有多个线程。 线程管理线程管理：线程控制表/线程控制块 能被线程共享的资源存放在进程控制块中，不能被线程共享的资源存放在线程控制块中。 为了提高协作，希望线程间可以共享的资源越多越好。 一般的标准是：如果某资源独享会导致线程运行错误，则该资源就由线程独享，反之，如果不发生错误，就共享。 表 一般情况下线程共享和独享资源划分 线程共享资源 线程独享资源 地址空间 程序计数器 全局变量 寄存器 打开的文件 栈 子进程 状态字 闹铃 信号及信号服务程序 记账信息 线程的实现方式线程的管理出现两种形式 进程管理线程：用户态线程实现 OS管理线程：内核态线程实现 这也是线程实现的两种方式。 既然每个线程是不同的执行序列，说明线程应该是CPU调度的基本单位。 内核态线程实现优点：用户编程保持简单；如果一个线程执行阻塞操作，OS很容易的可以调度另一个线程去执行。 缺点： 效率低。（每次的线程调度时陷入内核态实现的，由操作系统进行调度）；内核态实现会占用稀缺的内存资源。随着线程数的增加，OS的内核空间将迅速耗尽； 内核空间满了：采取的错误最好是让它“停止运行”。 内核态实现需要修改操作系统 基于以上可怕的缺点，就引入用户态线程实现。 用户态线程实现线程通信管道管道创建：使用系统调用popen()或者pipe() popen()需要提供一个目标进程做为参数，然后在调用该函数的进程和给出的目标进程之间创建一个管道。 一个重要特点：使用管道的两个线程之间存在某种联系 记名管道使用场景：两个不相关的线程，比如两个不同进程中的线程，之间进行管道通信，则需要使用记名管道。 使用方式：一个线程通过创建一个记名管道后，另外一个线程可使用open来打开这个管道（无名管道则不能使用open操作），从而与另外一端进行交流。 套接字套接字（socket） 是另外一种可用于进程间通信的机制。 socket的功能非常强大，可以支持不同层面、不同应用、跨网络的通信。 使用方法：需要双方均创建一个套接字，一方作为服务器方，另外一方作为客户方。服务器方必须先创建一个服务区套接字，然后再该套接字上进行监听，等待远方的连接请求。 信号可以改善管道和套接字的一些缺点，比如连接需要确认和消耗系统资源，连接需要对方确认。 信号的实质：内核对象 &amp; 内核数据结构 使用方式：发送方将数据结构填好，指明信号的目标进程后，发出特定的软中断。OS收到中断请求之后，只要有进程要发送信号，于是到特定的内核数据结构里查找信号接收方，并进行通知。 信号量实质是一个简单整数。 一个进程在信号变为0或者1的情况下推进，并且将信号变为1或者0来防止别的进程推进。当进程完成任务后，则将信号再改变为0或1，从而允许其他进程执行。 通信机制 &amp;&amp; 同步机制 共享内存两个进程share共享同一片内存。这篇内存中的任何内容，二者均可以访问。 缺点： 管理复杂，且两个进程须在同一台物理机器上才能使用这种通信方式。 安全性脆弱。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"yongchunxiaofen.top/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"yongchunxiaofen.top/tags/操作系统/"}]},{"title":"操作系统学习（二）：进程","slug":"operator-system-2","date":"2016-06-30T09:07:14.000Z","updated":"2016-06-30T13:45:17.000Z","comments":true,"path":"2016/06/30/operator-system-2/","link":"","permalink":"yongchunxiaofen.top/2016/06/30/operator-system-2/","excerpt":"进程通信进程进程模型物理层面：物理内存：进程占用一片内存空间，可以说进程就是内存的某片空间。任意时刻，在CPU上只能执行一条指令，所以任意时刻上在CPU上执行的进程只有一个，到底执行哪一条由物理程序计数器决定。物理层面上，所有进程共用一个程序计数器。 逻辑层面：因为要记录每个进程的执行情况和所处的执行位置，这样才能在下次接着执行时从正确的地点开始。从这个角度来看，每个进程都有自己的计数器。从逻辑上讲，程序计数器可以有很多个。 时间推移进程的推移。","text":"进程通信进程进程模型物理层面：物理内存：进程占用一片内存空间，可以说进程就是内存的某片空间。任意时刻，在CPU上只能执行一条指令，所以任意时刻上在CPU上执行的进程只有一个，到底执行哪一条由物理程序计数器决定。物理层面上，所有进程共用一个程序计数器。 逻辑层面：因为要记录每个进程的执行情况和所处的执行位置，这样才能在下次接着执行时从正确的地点开始。从这个角度来看，每个进程都有自己的计数器。从逻辑上讲，程序计数器可以有很多个。 时间推移进程的推移。 进程的状态 执行、阻塞和就绪 对于这三种状态，可以组成六种转换。 执行-&gt;就绪 执行-&gt;阻塞 阻塞-&gt;就绪 就绪-&gt;执行 阻塞-&gt;执行 就绪-&gt;阻塞 上边的转换中，前4种转换时可以实现的。 对于后两种转换： 阻塞进程即使被给予CPU也无法执行，OS在调度时并不会在阻塞队列里挑选。因此阻塞态无法直接转换成执行态。 对于就绪状态的进程来说，因为并没有执行，自然无法进入到阻塞状态。一个进程只能在执行时才可能阻塞，没有执行的进程无法直接转换到阻塞状态。 进程创立步骤： 分配进程控制块 初始化机器寄存器 初始化页表 将程序代码从磁盘读进内存 将处理器状态设置为“用户态” 跳转到程序的起始地址（设置程序计数器） 进程管理管理工具：进程控制块（PCB，Process Control Block）。PCB里边存放和进程相关的资料（寄存器，程序计数器、状态字、栈指针、优先级、进程ID、信号、创立时间、所耗CPU时间等）。采纳的数据结构主要是线性表、链表和结构体、也可能有树和图结构。 进程管理最大的问题：资源分配","categories":[{"name":"操作系统","slug":"操作系统","permalink":"yongchunxiaofen.top/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"yongchunxiaofen.top/tags/操作系统/"}]},{"title":"操作系统学习（一）：操作系统基本知识之基本术语","slug":"operator-system-1","date":"2016-06-30T09:06:51.000Z","updated":"2016-06-30T13:44:51.000Z","comments":true,"path":"2016/06/30/operator-system-1/","link":"","permalink":"yongchunxiaofen.top/2016/06/30/operator-system-1/","excerpt":"内核态和用户态： 内核态：占有计算机中的所有资源 用户态：少部分资源 微内核结构：只将操作系统核心中的核心放在内核态运行，其他功能都移到用户态，这就同时提高了效率和安全性。 图1.微内核的操作系统结构","text":"内核态和用户态： 内核态：占有计算机中的所有资源 用户态：少部分资源 微内核结构：只将操作系统核心中的核心放在内核态运行，其他功能都移到用户态，这就同时提高了效率和安全性。 图1.微内核的操作系统结构 进程、内存和文件进程是操作系统里面的核心 OS对进程的管理是通过进程表来实现的，进程表中存放关于进程的一切信息。 进程所占有的全部资源（包括分配给该进程的内存、内核数据结构和软资源等）形成一个进程核（Core）。 核快照（Core Image）代表的是进程在某一个特定时刻的状态。 内存是OS的另一个核心概念，是进程存放场所。 系统调用OS的服务通过系统调用的方式提供。 系统调用即OS提供的应用程序界面（API），用户程序通过调用这些API获得OS的服务。 壳（shell）系统调用API获得OS的服务需要编程，而对于不编程的用户，OS提供了一个shell用来与用户进行交互。 壳是覆盖在OS服务上面的一个用户界面，既可以是图形界面，也可以是文本界面。用户在界面上输入命令，OS执行命令。 UNIX和Linux的壳都是文本形式，而Windows的壳是图形界面的形式。 Linux和UNIX中，启动壳只需要运行shell即可，Windows中启动壳需要执行explore.exe。 fork：进程的自我复制execve：用另外一个程序的内容覆盖自己，即执行新的程序。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"yongchunxiaofen.top/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"yongchunxiaofen.top/tags/操作系统/"}]},{"title":"voltile的用法","slug":"the-use-of-voltile","date":"2016-06-30T02:33:53.000Z","updated":"2016-06-30T02:50:42.000Z","comments":true,"path":"2016/06/30/the-use-of-voltile/","link":"","permalink":"yongchunxiaofen.top/2016/06/30/the-use-of-voltile/","excerpt":"volatile是一个类型修饰符，修饰被不同线程访问和修改的变量。 被voltile类型定义的变量，系统调用的时候直接从对应的内存中提取，而不是利用cache中的原有数值，以适应它的未知何时发生变化。 volatile一般修饰多线程间被多个任务共享的变量和并行设备硬件寄存器等。 准确的说，优化器在用到volatile变量时每次都重新读取变量的值，而不是使用保存在寄存器中的备份。","text":"volatile是一个类型修饰符，修饰被不同线程访问和修改的变量。 被voltile类型定义的变量，系统调用的时候直接从对应的内存中提取，而不是利用cache中的原有数值，以适应它的未知何时发生变化。 volatile一般修饰多线程间被多个任务共享的变量和并行设备硬件寄存器等。 准确的说，优化器在用到volatile变量时每次都重新读取变量的值，而不是使用保存在寄存器中的备份。","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"yongchunxiaofen.top/tags/多线程/"},{"name":"voltile","slug":"voltile","permalink":"yongchunxiaofen.top/tags/voltile/"}]},{"title":"关于sizeof（string）的问题","slug":"sizeof-string","date":"2016-06-30T02:33:13.000Z","updated":"2016-06-30T02:50:47.000Z","comments":true,"path":"2016/06/30/sizeof-string/","link":"","permalink":"yongchunxiaofen.top/2016/06/30/sizeof-string/","excerpt":"关于sizeof(string)偶然间测试sizeof(string)的时候，在32位+win10+vs2013机子上测试如下一段代码：1234string str1 = \"Hello world\";string str2[] = &#123; \"a\",\"b\",\"c\" &#125;;cout&lt;&lt;sizeof(str1)&lt;&lt;\" \"&lt;&lt;sizeof(str2)&lt;&lt;\" \"&lt;&lt;sizeof(string)&lt;&lt;endl; 得到结果分别为：28，84,28 查阅资料时发现，输出结果和不同的编译器有关。 string的实现在各类库中可能有所不同，但是在同一库中相同一点是，无论你的string里放多长的字符串，sizeof()都是固定的，字符串所占空间是从堆中动态分配的，与sizeof()无关。","text":"关于sizeof(string)偶然间测试sizeof(string)的时候，在32位+win10+vs2013机子上测试如下一段代码：1234string str1 = \"Hello world\";string str2[] = &#123; \"a\",\"b\",\"c\" &#125;;cout&lt;&lt;sizeof(str1)&lt;&lt;\" \"&lt;&lt;sizeof(str2)&lt;&lt;\" \"&lt;&lt;sizeof(string)&lt;&lt;endl; 得到结果分别为：28，84,28 查阅资料时发现，输出结果和不同的编译器有关。 string的实现在各类库中可能有所不同，但是在同一库中相同一点是，无论你的string里放多长的字符串，sizeof()都是固定的，字符串所占空间是从堆中动态分配的，与sizeof()无关。 关于sizeof的一些小细节sizeof并不是一个函数，或者可以说是一元操作符，甚至像是一个特殊的宏，因为是在编译阶段求值的。1234567891011121314151617cout&lt;&lt;sizeof(int)&lt;&lt;endl; // 32位机上int长度为4cout&lt;&lt;sizeof(1==2)&lt;&lt;endl; // == 操作符返回bool类型，相当于 cout&lt;&lt;sizeof(bool)&lt;&lt;endl; 在编译阶段已经被翻译为：cout&lt;&lt;4&lt;&lt;endl;cout&lt;&lt;1&lt;&lt;endl; 这里有个陷阱，看下面的程序：int a = 0;cout&lt;&lt;sizeof(a=3)&lt;&lt;endl;cout&lt;&lt;a&lt;&lt;endl; 输出为什么是4，0而不是期望中的4，3？？？就在于sizeof在编译阶段处理的特性。由于sizeof不能被编译成机器码，所以sizeof作用范围内，也就是()里面的内容也不能被编译，而是被替换成类型。=操作符返回左操作数的类型，所以a=3相当于int，而代码也被替换为： 12345int a = 0;cout&lt;&lt;4&lt;&lt;endl;cout&lt;&lt;a&lt;&lt;endl; 所以，sizeof是不可能支持链式表达式的，这也是和一元操作符不一样的地方。 结论：不要把sizeof当成函数，也不要看作一元操作符，把他当成一个特殊的编译预处理。 sizeof求函数的字节例如 1234567int f1()&#123;return 0;&#125;double f2()&#123;return 0;&#125;void f3()&#123;return 0;&#125;cout&lt;&lt;sizeof(f1())&lt;&lt;endl; // f1()返回值为int，因此被认为是intcout&lt;&lt;sizeof(f2())&lt;&lt;endl; // f2()返回值为double，因此被认为是doublecout&lt;&lt;sizeof(f3())&lt;&lt;endl; // 错误！无法对void类型使用sizeofcout&lt;&lt;sizeof(f1)&lt;&lt;endl; // 错误！无法对函数指针使用sizeof 结论：对函数使用sizeof，在编译阶段会被函数返回值的类型取代， 位域 在结构体和类中，可以使用位域来规定某个成员所能占用的空间，所以使用位域能在一定程度上节省结构体占用的空间。 考虑以下代码1234567891011121314151617181920212223242526272829303132struct s1&#123; int i: 8; int j: 4; double b; int a:3;&#125;;struct s2&#123; int i; int j; double b; int a;&#125;;struct s3&#123; int i; int j; int a; double b;&#125;;struct s4&#123; int i: 8; int j: 4; int a:3; double b;&#125;;cout&lt;&lt;sizeof(s1)&lt;&lt;endl; // 24cout&lt;&lt;sizeof(s2)&lt;&lt;endl; // 24cout&lt;&lt;sizeof(s3)&lt;&lt;endl; // 24cout&lt;&lt;sizeof(s4)&lt;&lt;endl; // 16 其中s1中，i和j总共占用12位，不足8字节，按照8字节对其，然后再加上double的8个字节，最后一个a占3位，也不足8字节，按照8字节对其，总共就是24字节。在s4中，i、j、a总共占用15位，不足8字节，按照double 8字节对齐，再加上double的8个字节，总共占用16个字节。","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"sizeof","slug":"sizeof","permalink":"yongchunxiaofen.top/tags/sizeof/"},{"name":"string","slug":"string","permalink":"yongchunxiaofen.top/tags/string/"},{"name":"位域","slug":"位域","permalink":"yongchunxiaofen.top/tags/位域/"}]},{"title":"身份证号码验证算法","slug":"ID-number-check","date":"2016-06-26T08:36:41.000Z","updated":"2016-06-26T08:45:28.000Z","comments":true,"path":"2016/06/26/ID-number-check/","link":"","permalink":"yongchunxiaofen.top/2016/06/26/ID-number-check/","excerpt":"经常会见到一些鉴别身份证号码是否真实的辨别，根据网上的身份证号码验证算法，做以总结。 一.18位身份证号码的结构公民身份证号码是特征组合码，由十七位数字和一位校验码组成。 排列从左往右依次为：六位数字地址码， 八位数字出生日期码， 三位数字顺序码 和一位校验码 1.地址码表示编码对象常住户口所在县(市、旗、区)的行政区域划分代码，按GB/T2260的规定执行。","text":"经常会见到一些鉴别身份证号码是否真实的辨别，根据网上的身份证号码验证算法，做以总结。 一.18位身份证号码的结构公民身份证号码是特征组合码，由十七位数字和一位校验码组成。 排列从左往右依次为：六位数字地址码， 八位数字出生日期码， 三位数字顺序码 和一位校验码 1.地址码表示编码对象常住户口所在县(市、旗、区)的行政区域划分代码，按GB/T2260的规定执行。 2.出生日期码表示编码对象出生的年、月、日，按GB/T7408的规定执行，年、月、日代码之间不用分隔符。 3.顺序码表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编定的顺序号，顺序码的奇数分配给男性，偶数分配给女性。 4.校验码计算算法4.1 十七位数字本体码加权求和公式 S=Sum(Ai * Wi), i = 0, … , 16 ，先对前 17 位数字的权求和 Ai：表示第i位置上的身份证号码数字值(0~9) Wi：7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2 （表示第 i 位置上的加权因子） （表示第 i 位置上的加权因子） 4.2 计算模值Y = mod(S,11) 4.3 根据计算的模值，查找得到对应的校验码 Y： 0 1 2 3 4 5 6 7 8 9 10 校验码: 1 0 X 9 8 7 6 5 4 3 2 二.根据17位数字本体码获取最后一位校验码程序实例12345678910111213141516171819public class Id18 &#123; int[] weight=&#123;7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2&#125;; //十七位数字本体码权重 char[] validate=&#123; '1','0','X','9','8','7','6','5','4','3','2'&#125;; //mod11,对应校验码字符值 public char getValidateCode(String id17)&#123; int sum = 0; int mode = 0; for(int i = 0; i &lt; id17.length(); i++)&#123; sum=sum+Integer.parseInt(String.valueOf(id17.charAt(i)))*weight[i]; &#125; mode = sum % 11; return validate[mode]; &#125; public static void main(String[] args)&#123; Id18 tes t= new Id18(); System.out.println(\"该身份证验证码：\"+test.getValidateCode(\"14230219700101101\")); //该身份证校验码：3 &#125;&#125; 三.说明1.程序可以根据已有的17位数字本体码，获取对应的验证码。 2.该程序可以剔除验证码不正确的身份证号码。 3.15位的身份证出生年份采用年份后2位，没有最后1位校验码。 4.完整的身份证18位，最后一位校验位可能是非数字。我们的一个项目，数据库保存前17位数字，这样对应一些SQL语句（比如inner join）有加速作用的！！！ -转自伯乐在线-身份证号码验证算法","categories":[{"name":"算法","slug":"算法","permalink":"yongchunxiaofen.top/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"yongchunxiaofen.top/tags/算法/"}]},{"title":"面向对象的五个基本原则","slug":"5-principles-of-object-oriented","date":"2016-06-25T09:08:05.000Z","updated":"2016-06-30T02:50:31.000Z","comments":true,"path":"2016/06/25/5-principles-of-object-oriented/","link":"","permalink":"yongchunxiaofen.top/2016/06/25/5-principles-of-object-oriented/","excerpt":"","text":"单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。 开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。 依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"面向对象","slug":"面向对象","permalink":"yongchunxiaofen.top/tags/面向对象/"}]},{"title":"企图修改常量区的字符串所引发的错误","slug":"char-const-pointer","date":"2016-06-25T09:04:14.000Z","updated":"2016-06-30T02:50:26.000Z","comments":true,"path":"2016/06/25/char-const-pointer/","link":"","permalink":"yongchunxiaofen.top/2016/06/25/char-const-pointer/","excerpt":"经常会采用char类型的指针来存储字符串，即为将字符串的首地址值赋给基类型为char的指针变量，从而可以从字符串首元素开始对字符串进行操作，其中有一些常见的问题。 有如下例子：1234567int main()&#123; char *p = \"hello world\"; p[0] = 'H'; printf(\"%s\\n\",p); return 0;&#125; 运行该程序会出现错误，因为*p=&quot;hello world&quot;这句仅仅声明了一个指针变量，指向字符串”hello world”,而”hello world”这个字符串程序没有给它分配空间，编译器将它分配到常量区。而常量区的字符串的值时不允许修改的。","text":"经常会采用char类型的指针来存储字符串，即为将字符串的首地址值赋给基类型为char的指针变量，从而可以从字符串首元素开始对字符串进行操作，其中有一些常见的问题。 有如下例子：1234567int main()&#123; char *p = \"hello world\"; p[0] = 'H'; printf(\"%s\\n\",p); return 0;&#125; 运行该程序会出现错误，因为*p=&quot;hello world&quot;这句仅仅声明了一个指针变量，指向字符串”hello world”,而”hello world”这个字符串程序没有给它分配空间，编译器将它分配到常量区。而常量区的字符串的值时不允许修改的。 修改如下：12345678int main()&#123; char p[12]=\"hello world\"; char *p1=p; p1[0]='H'; printf(\"%s\\n\",p1); return 0;&#125; 原因在于p[12] = &quot;hello world&quot;是自己定义的一个长度为12的字符数组，编译器会为他分配栈空间，所以能够修改它的值。","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"字符串常量","slug":"字符串常量","permalink":"yongchunxiaofen.top/tags/字符串常量/"}]},{"title":"类成员中调用delete this引发的错误解析","slug":"delete-this-in-class-body","date":"2016-06-21T06:51:38.000Z","updated":"2016-06-30T02:50:19.000Z","comments":true,"path":"2016/06/21/delete-this-in-class-body/","link":"","permalink":"yongchunxiaofen.top/2016/06/21/delete-this-in-class-body/","excerpt":"在类的成员函数中能不能调用delete this？答案是肯定的，能调用，而且很多老一点的库都有这种代码。 假设这个成员函数名字叫delete_this，而delete this就在这个delete_this方法中被调用，那么这个对象在调用delete_this方法后，还能进行其他操作，如调用该对象的其他方法么？答案仍然是肯定 的，调用delete_this之后还能调用其他的方法，但是有个前提：被调用的方法不涉及这个对象的数据成员和虚函数。说到这里，相信大家都能明白为什么会这样 了。 根本原因在于delete操作符的功能和类对象的内存模型。 当一个类对象声明时，系统会为其分配内存空间。 在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。","text":"在类的成员函数中能不能调用delete this？答案是肯定的，能调用，而且很多老一点的库都有这种代码。 假设这个成员函数名字叫delete_this，而delete this就在这个delete_this方法中被调用，那么这个对象在调用delete_this方法后，还能进行其他操作，如调用该对象的其他方法么？答案仍然是肯定 的，调用delete_this之后还能调用其他的方法，但是有个前提：被调用的方法不涉及这个对象的数据成员和虚函数。说到这里，相信大家都能明白为什么会这样 了。 根本原因在于delete操作符的功能和类对象的内存模型。 当一个类对象声明时，系统会为其分配内存空间。 在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。 为什么是不可预期的问题？ delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？ 这个问题牵涉到操作系统的内存管理策略。 delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。大致明白在成员函数中调用delete this会发生什么之后，再来看看另一个问题.如果在类的析构函数中调用delete this，会发生什么？实验告诉我们，会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存” (来自effective c++)。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。——————–我是分界面——————–上面是某大牛的分析，而在实际的运行过程中使用delele this确实会直接出现错误。这是因为：在成员函数中调用delete this，首先会调用类的析构函数，this指针已删除，会出现指针错误。下面是在XCode中使用delete this出现的错误： malloc: error for object 0xbffffa18: pointer being freed was not allocated//注意0xbffffa18即为this的地址 set a breakpoint in malloc_error_break to debug而在VS2010中使用delete this是直接导致 Debug Assertion Failed！具体的描述是：invalid null pointer总结：在成员函数中调用delete this，会导致指针错误，而在析构函数中调用delete this，出导致死循环，造成堆栈溢出。 PS：this是类中成员函数具有的一个附加的隐含形参，即指向该类对象的一个指针，它与调用成员函数的对象绑定在一起。 同时 在普通的非const成员函数中：this的类型是一个指向类类型的const指针，可以改变this指向的值，但是不能改变this所保存的地址； 在const成员函数中，this的类型是一个指向const类类型对象的const指针，既不能改变this所指向的对象，也不能改变this所保存的地址。 注意：成员函数中不能定义this形参，而是由编译器隐含地定义，但是可以在成员函数中显式使用this形参，不过也不是必须这么做。如果对类成员的引用没有限定，编译器会将这种引用处理成通过this指针的引用。 有一种情况下必须显式使用this：当我们需要将一个对象作为整体引用而不是引用对象的一个成员时。 从const成员函数返回*this：不能从const成员函数返回指向类对象的普通引用。const成员函数只能返回*this作为一个const引用。","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"析构","slug":"析构","permalink":"yongchunxiaofen.top/tags/析构/"},{"name":"this指针","slug":"this指针","permalink":"yongchunxiaofen.top/tags/this指针/"}]},{"title":"虚函数表详解","slug":"virtual-function-table-detail","date":"2016-06-21T06:44:48.000Z","updated":"2016-06-30T02:50:10.000Z","comments":true,"path":"2016/06/21/virtual-function-table-detail/","link":"","permalink":"yongchunxiaofen.top/2016/06/21/virtual-function-table-detail/","excerpt":"假如有如下类： 12345678910111213141516class Base&#123;public: virtual void f() &#123; cout &lt;&lt; \"Base::f()\" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; \"Base::g()\" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; \"Base::h()\" &lt;&lt; endl; &#125;&#125;; 通过Base的实例得到虚表。","text":"假如有如下类： 12345678910111213141516class Base&#123;public: virtual void f() &#123; cout &lt;&lt; \"Base::f()\" &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; \"Base::g()\" &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; \"Base::h()\" &lt;&lt; endl; &#125;&#125;; 通过Base的实例得到虚表。 1234567891011typedef void(*Fun)(void);Base b;Fun pFun = NULL;cout &lt;&lt; \"虚函数表地址：\" &lt;&lt; (int *)(&amp;b) &lt;&lt; endl;cout &lt;&lt; \"虚函数表-第一个函数地址：\" &lt;&lt; (int *)*(int *)(&amp;b) &lt;&lt; endl;pFun = (Fun)*((int*)*(int*)(&amp;b));pFun(); 输出： 虚函数表地址：0014FD10 虚函数表-第一个函数地址：0105DA58 Base::f() 解析：强行将&amp;b转换成int *,取得虚函数表的地址，然后，对其再次取地址就可以得到第一个虚函数的地址了，也就是Base::f().同理，如果要调用剩下的两个函数，代码为： (Fun)*((int*)*(int*)(&amp;b)+1); // Base::g() (Fun)*((int*)*(int*)(&amp;b)+2); // Base::h() 虚表的对象模型如下表所示： 一般继承的对象模型（无虚函数覆盖） 该继承关系中，子类没有重载父类的任何一个函数。则派生类实例中，虚函数的表如下所示： 对于实例：Derived d的虚函数表如下所示： 有两点需要注意 虚函数按照其声明顺序放于表中。 父类的虚函数在子类的虚函数前面。 有虚函数覆盖的一般继承有如下的继承关系： 如上的继承关系中，只有一个虚函数f，派生类的实例中对象模型如下图所示： 同样，有两点需要注意： 覆盖的f()函数被放到了虚表中原来父类虚函数的位置。 没有被覆盖的函数依旧。 这样，对于如下代码： Base *b = new Derive(); b-&gt;f(); 由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。 多重继承（无虚函数覆盖） 有如上图所示的继承关系，子类实例中的虚函数表，对象模型如下图所示： 两点注意 每个父类都有自己的虚表 子类的成员函数被放到了第一个父类的表中（第一个父类是按照声明顺序来说得） 多重继承（有虚函数覆盖） 子类实例中的虚函数表： 三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。 参考文章 陈皓-C++ 虚函数表解析","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"虚函数","slug":"虚函数","permalink":"yongchunxiaofen.top/tags/虚函数/"},{"name":"virtual function table","slug":"virtual-function-table","permalink":"yongchunxiaofen.top/tags/virtual-function-table/"}]},{"title":"对一道类型转换的题目的思考","slug":"a-topic-of-type-conversion","date":"2016-06-14T14:18:16.000Z","updated":"2016-06-30T02:50:04.000Z","comments":true,"path":"2016/06/14/a-topic-of-type-conversion/","link":"","permalink":"yongchunxiaofen.top/2016/06/14/a-topic-of-type-conversion/","excerpt":"牛客上刷题的时候，碰上了一道如下所示的题目：123456int main()&#123; unsigned char i = 1; i -= 4; printf(“the value of i is: % d”, i);&#125; 请问i的值是： A.253 B.254 C.255 D.256 正确答案是：A：253 刚开始做这个题的时候没多大注意，普通的类型转换无符号数的加减。然而，我选择的254是错误的。","text":"牛客上刷题的时候，碰上了一道如下所示的题目：123456int main()&#123; unsigned char i = 1; i -= 4; printf(“the value of i is: % d”, i);&#125; 请问i的值是： A.253 B.254 C.255 D.256 正确答案是：A：253 刚开始做这个题的时候没多大注意，普通的类型转换无符号数的加减。然而，我选择的254是错误的。 在看题目下边网友的回答中，大多数的回答是说计算i-4之后结果为-3，最后printf输出%d输出的时候转换成10进制输出。 我在边看回答的过程中，顺便将代码贴到编译器中一步一步调试了看了一下，结果发现，在执行完i-=4之后，i就已经是253了，而不是回答所说的-3. 通过查阅资料，这里涉及两点内容 整型提升：在表达式计算时，各种整型首先要提升为int类型，然后执行表达式的运算。 计算机中的减法运算：在计算机中，是将减法转换成加法来计算的。在计算时，将负数转换成对应的补码进行计算。 因此，在计算i-=4的时候就已经发生了类型转换，由unsigned int转换成了int类型。 因而在计算完i-=4这一步以后i的值就已经是253了，而不是-3.在计算 i-=4这一步时，会发生如下转换：实际计算的是 i+(-4)的计算。i=1 ：0000 0001-4作为负数，在计算机中是以补码的形式参与运算。[ -4 ]原=1000 0100[ -4 ] 反 =1111 1011[ -4 ] 补 =1111 1100 在计算时，以下两个值进行相加：i=1: 0000 0001-4： 1111 1100相加之和是：1111 1101即：253","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"C","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"类型转换","slug":"类型转换","permalink":"yongchunxiaofen.top/tags/类型转换/"}]},{"title":"C++中的强制类型转换","slug":"reinterpret-cast-in-Cpp","date":"2016-06-14T14:14:16.000Z","updated":"2016-06-30T02:49:56.000Z","comments":true,"path":"2016/06/14/reinterpret-cast-in-Cpp/","link":"","permalink":"yongchunxiaofen.top/2016/06/14/reinterpret-cast-in-Cpp/","excerpt":"本节介绍四个强制类型转换运算符：const_cast、reinterpret_cast、static_cast和dynamic_cast。 1. const_cast转换符使用表达式const_cast&lt;T&gt;(v)可以更改指针或者引用的const或者volatile限定符。T必须是指针、引用或者指向成员的指针类型。 12345678910111213141516class A&#123;public: virtual void f(); int i;&#125;;extern const volatile int *cvip;extern int *ip;void use_of_const_cast()&#123; const A a1; const_cast&lt;A&amp;&gt;(a1).f(); //remove const ip=const_cast&lt;int *&gt;(cvip); //remove const and volatile&#125;","text":"本节介绍四个强制类型转换运算符：const_cast、reinterpret_cast、static_cast和dynamic_cast。 1. const_cast转换符使用表达式const_cast&lt;T&gt;(v)可以更改指针或者引用的const或者volatile限定符。T必须是指针、引用或者指向成员的指针类型。 12345678910111213141516class A&#123;public: virtual void f(); int i;&#125;;extern const volatile int *cvip;extern int *ip;void use_of_const_cast()&#123; const A a1; const_cast&lt;A&amp;&gt;(a1).f(); //remove const ip=const_cast&lt;int *&gt;(cvip); //remove const and volatile&#125; 2. reinterpret_cast例如pointer和int 的无关类型的转换。reinterpret_cast(v)用于更改表达式v值的解释。 转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针。 在比特位级上进行转换。它可以把一个指针转换成一个整数，反过来亦可。 最普通的用法就是函数指针类型之间进行转换。 很难保证移植性。此强制转换运算符不是通用的，因此，它不能保证可移植到其它编译器。 1234567const char* str = \"hello\";int i = static_cast&lt;int&gt;(str);//error C2440: 'static_cast' : cannot // convert from 'const char *' to 'int'int j = (int)str; // C-style cast. Did the programmer really intend // to do this?int k = reinterpret_cast&lt;int&gt;(str);// Programming intent is clear. // However, it is not 64-bit safe. 3. static_cast转换用法： static_cast ( expression ) static_cast可用于将指向基类的指针转换为指向派生类的指针等操作，该类型转换并非始终安全。 基类和父类之间的转换。子类指针转换成父类指针时安全的，但是父类指针指向子类指针时不安全的。（基类和子类的动态类型转换建议使用dynamic_cast） 基本类型转换。其中static_cast不能进行无关类型(如非基类和子类)指针之间的转换。 将空指针转换成目标类型的空指针 任何类型的表达式转换成void类型。 static_cast不能去掉类型的const，volitale属性。 12345int n =6;double d = static_cast&lt;double&gt;(n); // 基本类型转换int*pn =&amp;n;double*d = static_cast&lt;double*&gt;(&amp;n) //无关类型指针转换，编译错误void*p = static_cast&lt;void*&gt;(pn); //任意类型转换成void类型 4. dynamic_cast有条件转换，动态类型转换，运行时类型安全检查。（转换失败返回NULL） 安全的基类和子类的转换 基类必须要有虚函数：保持多态性才能使用dynamic_cast转换 相同基类不同子类之间的交叉转换。但结果是NULL。 参考文章 博客园-C++类型转换总结 ORACLE-强制类型转换 MSDN-强制转换运算符","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"C","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"类型转换","slug":"类型转换","permalink":"yongchunxiaofen.top/tags/类型转换/"}]},{"title":"unsigned char类型数运算过程中应当注意的一些问题","slug":"complex-type-change","date":"2016-06-13T08:21:21.000Z","updated":"2016-06-30T02:49:49.000Z","comments":true,"path":"2016/06/13/complex-type-change/","link":"","permalink":"yongchunxiaofen.top/2016/06/13/complex-type-change/","excerpt":"牛客上刷题的时候，碰上了一道如下所示的题目：123456int main()&#123; unsigned char i = 1; i -= 4; printf(“the value of i is: % d”, i);&#125; 请问i的值是： A.253 B.254 C.255 D.256 正确答案是：A：253 刚开始做这个题的时候没多大注意，普通的类型转换无符号数的加减。然而，我选择的254是错误的。","text":"牛客上刷题的时候，碰上了一道如下所示的题目：123456int main()&#123; unsigned char i = 1; i -= 4; printf(“the value of i is: % d”, i);&#125; 请问i的值是： A.253 B.254 C.255 D.256 正确答案是：A：253 刚开始做这个题的时候没多大注意，普通的类型转换无符号数的加减。然而，我选择的254是错误的。 在看题目下边网友的回答中，大多数的回答是说计算i-4之后结果为-3，最后printf输出%d输出的时候转换成10进制输出。 我在边看回答的过程中，顺便将代码贴到编译器中一步一步调试了看了一下，结果发现，在执行完i-=4之后，i就已经是253了，而不是回答所说的-3. 通过查阅资料，这里涉及两点内容 整型提升：在表达式计算时，各种整型首先要提升为int类型，然后执行表达式的运算。 计算机中的减法运算：在计算机中，是将减法转换成加法来计算的。在计算时，将负数转换成对应的补码进行计算。 因此，在计算i-=4的时候就已经发生了类型转换，由unsigned int转换成了int类型。 因而在计算完i-=4这一步以后i的值就已经是253了，而不是-3.在计算 i-=4这一步时，会发生如下转换：实际计算的是 i+(-4)的计算。i=1 ：0000 0001-4作为负数，在计算机中是以补码的形式参与运算。[ -4 ]原=1000 0100[ -4 ] 反 =1111 1011[ -4 ] 补 =1111 1100 在计算时，以下两个值进行相加：i=1: 0000 0001-4： 1111 1100相加之和是：1111 1101即：253","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"C","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"类型转换","slug":"类型转换","permalink":"yongchunxiaofen.top/tags/类型转换/"}]},{"title":"一道结合了小端模式+栈+printf+数据类型转换的题目","slug":"Little-endian-stack-printf","date":"2016-06-13T03:39:09.000Z","updated":"2016-06-30T02:49:41.000Z","comments":true,"path":"2016/06/13/Little-endian-stack-printf/","link":"","permalink":"yongchunxiaofen.top/2016/06/13/Little-endian-stack-printf/","excerpt":"题目如下： 假设在一个 32 位 little endian 的机器上运行下面的程序，结果是多少？ #include &lt;stdio.h&gt; int main(){ long long a = 1, b = 2, c = 3; printf(\"%d %d %d\\n\", a, b, c); return 0; } 正确答案：1 0 2","text":"题目如下： 假设在一个 32 位 little endian 的机器上运行下面的程序，结果是多少？ #include &lt;stdio.h&gt; int main(){ long long a = 1, b = 2, c = 3; printf(\"%d %d %d\\n\", a, b, c); return 0; } 正确答案：1 0 2 解析：感谢牛客网网友@千江乐 提供解决思路 printf()是一个库函数，C以及C++中函数的参数是从右往左入栈的； 和堆的生长方向相反，栈的生长反响是从高往低的。 小端模式是低位存储低字节 %d格式输出的是4个字节大小，而long long 为8个字节。","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"C","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"小端模式","slug":"小端模式","permalink":"yongchunxiaofen.top/tags/小端模式/"}]},{"title":"C中常见的类型转换","slug":"type-change-char-to-int","date":"2016-06-13T03:35:17.000Z","updated":"2016-06-30T02:49:26.000Z","comments":true,"path":"2016/06/13/type-change-char-to-int/","link":"","permalink":"yongchunxiaofen.top/2016/06/13/type-change-char-to-int/","excerpt":"常见的类型转换有这么一道题目： 32位的机器下，下面说法哪些是正确的？ signed char a = 0xe0; unsigned int b = a; unsigned char c = a; A. a&gt;0 &amp;&amp; c&gt;0 B. a==c C. b的十六进制的表示是：0xffffffe0 D. 以上说法都是错误的 解析： A错，signed char比较时候类型要提升成int，符号位是补最高位的1，所以a应该是负数 B错：当进行==比较时，char类型的a和c都要要先提升成int类型才进行比较，a转换成int后是0xffffffe0,它是一负数，而c转化成int之后是0x000000e0,是一正数，很明显不相等。 C对：signed char先转化成int类型再转化成unsigned int类型，signed char转化成int时候要进行符号扩展，因为是有符号类型，所以最高位就是补1.","text":"常见的类型转换有这么一道题目： 32位的机器下，下面说法哪些是正确的？ signed char a = 0xe0; unsigned int b = a; unsigned char c = a; A. a&gt;0 &amp;&amp; c&gt;0 B. a==c C. b的十六进制的表示是：0xffffffe0 D. 以上说法都是错误的 解析： A错，signed char比较时候类型要提升成int，符号位是补最高位的1，所以a应该是负数 B错：当进行==比较时，char类型的a和c都要要先提升成int类型才进行比较，a转换成int后是0xffffffe0,它是一负数，而c转化成int之后是0x000000e0,是一正数，很明显不相等。 C对：signed char先转化成int类型再转化成unsigned int类型，signed char转化成int时候要进行符号扩展，因为是有符号类型，所以最高位就是补1. char转换为int型，即signed char转换为signed int型： char类型占一个字节内存大小，int类型占用4个字节，当char转换成int型时，在int类型变量高位前3个字节填充，填充位的二进制位为char类型最高位的比特，例如： char a = 0x11; //0001 0001(占用1个字节，8位) 当发生如下转换时： int b = a; //因为char类型最高位的比特是0，所以char类型的a转换成int类型的b时，前3个字节需要填充0. 即转换后b的十六进制为：0x00000011。 同理，如果有如下的char类型a： char a = 0x81; //1000 0001 当发生如下的类型转换时， int b = a;//此时，char类型的最高位比特数位1，所以转换后的int前3个字节均填充1, 转换后的b的十六进制数为 0xffffff81 unsigned char转为int的情况 例如：unsigned char a = 0xf1; //或者是 a = 0x11 (最高位是0还是1的差别) 发生如下的类型转换时： int b = a; 无符号数转换时，无论char类型的最高位是0还是1，转换为int类型时，前3个字节一律填充0. 小结：signed char转换成int类型时，转换后的int类型前3个字节填充对应char类型最高位的比特数。 而unsigned char类型转换成int类型时，无论char类型的最高位是0还是1,在转换后的int类型前3个字节中均填充0. long转换为int类型时，由于都是4个字节，所以无需填充。 int类型转换为long long 类型 同理，signed int转换为long long时，需要在高位填充，填充符号位。 而unsigned int转换为long long 时，全部填充0. -感谢博客园@cyonks 搜集整理。 参考文章 笔试常见之C类型转换","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"C","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"类型转换","slug":"类型转换","permalink":"yongchunxiaofen.top/tags/类型转换/"}]},{"title":"pragma pack(n)与内存对其问题","slug":"the-use-of-pragma-pack","date":"2016-06-08T07:32:11.000Z","updated":"2016-06-30T02:49:21.000Z","comments":true,"path":"2016/06/08/the-use-of-pragma-pack/","link":"","permalink":"yongchunxiaofen.top/2016/06/08/the-use-of-pragma-pack/","excerpt":"作用：屏蔽掉编译器为变量设定的默认的对其方式，设定自己的对其方式 而#pragma pack(n)表示设定变量以n字节对其。 如果n大于等于该变量所占的字节数，那么偏移量必须满足默认的对其方式 如果n小于该变量的类型所占用的字节数，那么偏移量为n 的整数倍，不用满足默认的对其方式。 结构体的总大小也有个约束条件： 如果n大于所有的成员变量类型所占用的字节数，那么结构的总大小必须为占用空间最大的变量占用的空间数的倍数 如果n小于所有成员变量类型所占用的字节数，那么必须为n的倍数。 举例说明：1234567891011#pragma pack(push) //保持对齐状态#pragma pack(4) //设定为4字节对齐strust test&#123; char m1; double m4; int m3;&#125;#pragma pack(pop) //恢复对齐状态","text":"作用：屏蔽掉编译器为变量设定的默认的对其方式，设定自己的对其方式 而#pragma pack(n)表示设定变量以n字节对其。 如果n大于等于该变量所占的字节数，那么偏移量必须满足默认的对其方式 如果n小于该变量的类型所占用的字节数，那么偏移量为n 的整数倍，不用满足默认的对其方式。 结构体的总大小也有个约束条件： 如果n大于所有的成员变量类型所占用的字节数，那么结构的总大小必须为占用空间最大的变量占用的空间数的倍数 如果n小于所有成员变量类型所占用的字节数，那么必须为n的倍数。 举例说明：1234567891011#pragma pack(push) //保持对齐状态#pragma pack(4) //设定为4字节对齐strust test&#123; char m1; double m4; int m3;&#125;#pragma pack(pop) //恢复对齐状态","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"C","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"内存对齐","slug":"内存对齐","permalink":"yongchunxiaofen.top/tags/内存对齐/"},{"name":"pragma pack","slug":"pragma-pack","permalink":"yongchunxiaofen.top/tags/pragma-pack/"}]},{"title":"类中构造函数的顺序","slug":"the-order-of-structor","date":"2016-06-08T07:29:08.000Z","updated":"2016-06-30T02:49:16.000Z","comments":true,"path":"2016/06/08/the-order-of-structor/","link":"","permalink":"yongchunxiaofen.top/2016/06/08/the-order-of-structor/","excerpt":"在一个class及其继承类中，不但有父类，还有类的成员，还有子类。那么父类的构造函数，成员变量的构造函数以及子类的构造函数的顺序是怎么样的，有以下例题：123456789101112131415161718192021222324252627282930313233343536# include &lt;iostream&gt;using namespace std;class A &#123; public: A() &#123; cout&lt;&lt;\"create A\"&lt;&lt;endl; &#125; A(const A&amp; other)&#123; cout&lt;&lt;\"copy A\"&lt;&lt;endl;&#125; //复制构造函数 ~A() &#123; cout&lt;&lt;\"~A\"&lt;&lt;endl; &#125; &#125;; class C&#123;public: C() &#123; cout&lt;&lt;\"create C\"&lt;&lt;endl; &#125; C(const A&amp; other)&#123; cout&lt;&lt;\"copy C\"&lt;&lt;endl;&#125; //复制构造函数 ~C() &#123; cout&lt;&lt;\"~C\"&lt;&lt;endl; &#125; &#125;;class B:public A &#123; public: B() &#123; cout&lt;&lt;\"create B\"&lt;&lt;endl; &#125; ~B() &#123; cout&lt;&lt;\"~B\"&lt;&lt;endl; &#125; private: C _a; &#125;; int main(void) &#123; B b; cout&lt;&lt;\"------------------------\"&lt;&lt;endl;&#125;","text":"在一个class及其继承类中，不但有父类，还有类的成员，还有子类。那么父类的构造函数，成员变量的构造函数以及子类的构造函数的顺序是怎么样的，有以下例题：123456789101112131415161718192021222324252627282930313233343536# include &lt;iostream&gt;using namespace std;class A &#123; public: A() &#123; cout&lt;&lt;\"create A\"&lt;&lt;endl; &#125; A(const A&amp; other)&#123; cout&lt;&lt;\"copy A\"&lt;&lt;endl;&#125; //复制构造函数 ~A() &#123; cout&lt;&lt;\"~A\"&lt;&lt;endl; &#125; &#125;; class C&#123;public: C() &#123; cout&lt;&lt;\"create C\"&lt;&lt;endl; &#125; C(const A&amp; other)&#123; cout&lt;&lt;\"copy C\"&lt;&lt;endl;&#125; //复制构造函数 ~C() &#123; cout&lt;&lt;\"~C\"&lt;&lt;endl; &#125; &#125;;class B:public A &#123; public: B() &#123; cout&lt;&lt;\"create B\"&lt;&lt;endl; &#125; ~B() &#123; cout&lt;&lt;\"~B\"&lt;&lt;endl; &#125; private: C _a; &#125;; int main(void) &#123; B b; cout&lt;&lt;\"------------------------\"&lt;&lt;endl;&#125; 该程序的输出结果为1234567create Acreate Ccreate B------------------------~B~C~A -感谢@牛客网 网友提供以上题目。 从以上的构造顺序可以看出： 父类的构造函数&gt;成员变量C的构造函数&gt;子类的构造函数 而析构的过程恰恰相反。","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"C","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"构造函数","slug":"构造函数","permalink":"yongchunxiaofen.top/tags/构造函数/"}]},{"title":"为什么虚函数(virtual)不能是static函数","slug":"static-virtual-function","date":"2016-06-08T07:22:30.000Z","updated":"2016-06-30T02:49:10.000Z","comments":true,"path":"2016/06/08/static-virtual-function/","link":"","permalink":"yongchunxiaofen.top/2016/06/08/static-virtual-function/","excerpt":"简而言之，成员函数实例相关，静态函数类相关。 虚函数，是一种特殊的成员函数，用来实现运行时多态。 静态成员函数，可以不通过对象来调用，没有隐藏的this指针。 virtual函数一定要通过对象来调用，有隐藏的this指针。 所以，关键问题是static成员没有this指针。 static function 是静态决议（编译的时候就绑定了） 而virtual function 是动态决议的（运行时才绑定） 引用stackoverflow网友@Kerrek SB 的回答： That would make no sense. The point of virtual member functions is that they are dispatched based on the dynamic type of the object instance on which they are called. On the other hand, static functions are not related to any instances and are rather a property of the class. Thus it makes no sense for them to be virtual. If you must, you can use a non-static dispatcher. 即是说：virtual成员函数的关键是动态类型绑定的实例调用。然而，静态函数和任何类的实例都不相关，它是class的属性。","text":"简而言之，成员函数实例相关，静态函数类相关。 虚函数，是一种特殊的成员函数，用来实现运行时多态。 静态成员函数，可以不通过对象来调用，没有隐藏的this指针。 virtual函数一定要通过对象来调用，有隐藏的this指针。 所以，关键问题是static成员没有this指针。 static function 是静态决议（编译的时候就绑定了） 而virtual function 是动态决议的（运行时才绑定） 引用stackoverflow网友@Kerrek SB 的回答： That would make no sense. The point of virtual member functions is that they are dispatched based on the dynamic type of the object instance on which they are called. On the other hand, static functions are not related to any instances and are rather a property of the class. Thus it makes no sense for them to be virtual. If you must, you can use a non-static dispatcher. 即是说：virtual成员函数的关键是动态类型绑定的实例调用。然而，静态函数和任何类的实例都不相关，它是class的属性。","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"C","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"}]},{"title":"逗号运算符和逗号表达式","slug":"comma-expression-and-comma-operator","date":"2016-06-07T02:36:15.000Z","updated":"2016-06-30T02:49:04.000Z","comments":true,"path":"2016/06/07/comma-expression-and-comma-operator/","link":"","permalink":"yongchunxiaofen.top/2016/06/07/comma-expression-and-comma-operator/","excerpt":"逗号运算符和逗号表达式逗号运算符逗号运算符是以逗号为分隔符的列表中最后一个表达式的值。本质上讲，逗号的作用是导致一系列运算都被顺序执行。 最右边的那个表达式的值将作为整个逗号表达式的值，其他的表达式的值将会被丢弃。 逗号运算符是所有运算符中级别最低的。 例如，有如下表达式： var = (count = 19, incr = 10, count + 1); 上式在计算时，首先将count的值赋给19，将10赋值给incr，然后在最后一个表达式中，将最右边的count+1的计算结果20赋给var。上面表达式中的括号是必须得，因为逗号运算符的优先级低于赋值操作符。","text":"逗号运算符和逗号表达式逗号运算符逗号运算符是以逗号为分隔符的列表中最后一个表达式的值。本质上讲，逗号的作用是导致一系列运算都被顺序执行。 最右边的那个表达式的值将作为整个逗号表达式的值，其他的表达式的值将会被丢弃。 逗号运算符是所有运算符中级别最低的。 例如，有如下表达式： var = (count = 19, incr = 10, count + 1); 上式在计算时，首先将count的值赋给19，将10赋值给incr，然后在最后一个表达式中，将最右边的count+1的计算结果20赋给var。上面表达式中的括号是必须得，因为逗号运算符的优先级低于赋值操作符。 例如，有如下例子： 1234567891011121314#include&lt;iostream&gt;using std::cout;int main()&#123; int i, j; j = 10; i = (j ++, j + 100, 999 + j); cout &lt;&lt; i; return 0;&#125; 当上面的代码被编译和执行时，其结果为： 1010 逗号表达式逗号表达式是一种特殊的运算符，它可以将两个表达式连接起来。如： 3 + 5,6 + 8这种类型的运算符成为逗号表达式，又称为“顺序求值运算符”。逗号表达式的一般形式是： 表达式1，表达式2 求解顺序是：先求解表达式1，再求解表达式2.整个逗号表达式的值时表达式2的值。比如上式例子中表达式3 + 5,6 + 8的值是14. 又如，逗号表达式 a = 3 5, a 4 对该表达式，可能会有两种解读。 一种认为，等号右边的3 * 5,a * 4是一个逗号表达式，先求出此逗号表达式的值，在将逗号运算符的值赋给a。比如如果a的原值是3，则逗号表达式的值为12，将12赋值给a，因此最后a的值为12. 另一种认为，a = 3 * 5是一个赋值表达式，a * 4是另一个表达式，二者用逗号相连，构成一个逗号表达式。 这两种看法哪种正确呢？ 其实，赋值运算符的优先级高于逗号运算符的优先级，因此应该首先求解a = 3 * 5，此时a的值为15，然后再求解a*4,得60.整个逗号表达式的值为60. 因此，逗号表达式的一般形式可以扩展为： 表达式1，表达式2，表达式3，......表达式n 它的值为表达式n的值。 参考文章 菜鸟教程——C++逗号运算符 C语言中逗号运算符和逗号表达式——秋水ThinKing的博客","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"C","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"C++小结","slug":"C-小结","permalink":"yongchunxiaofen.top/tags/C-小结/"}]},{"title":"typedef用法小结","slug":"simple-use-of-typedef","date":"2016-06-07T02:33:27.000Z","updated":"2016-06-30T02:48:51.000Z","comments":true,"path":"2016/06/07/simple-use-of-typedef/","link":"","permalink":"yongchunxiaofen.top/2016/06/07/simple-use-of-typedef/","excerpt":"typedef使用小结stackoverflow上看到的一个问题。 typedef void(*FunctionFunc)(); Three Question:1.Why is typedef used?2.The syntax looks odd;after void should there not be a function name or something? It looks like an anonymous function.3.Is a function pointer created to store the memory address of a function ? 三个问题概括一下就是： 使用typedef有什么好处 语法和常见的语法不同 创建一个函数指针是不是来存储函数的内存地址的？","text":"typedef使用小结stackoverflow上看到的一个问题。 typedef void(*FunctionFunc)(); Three Question:1.Why is typedef used?2.The syntax looks odd;after void should there not be a function name or something? It looks like an anonymous function.3.Is a function pointer created to store the memory address of a function ? 三个问题概括一下就是： 使用typedef有什么好处 语法和常见的语法不同 创建一个函数指针是不是来存储函数的内存地址的？ Answer1：typedef 是一个联系变量类型和变量名称的构造语言 你可以以类型初始化的方式使用它，比如： typedef int myinteger; typedef char *mystring; typedef void (*myfunc)(); 可以使用以下的方式对上面的定义加以使用： myinteger i; // is equivalent to int i; mystring s; // is the same as char *s; myfunc f; //compile equally as void(*f)(); 如上所示，可以使用如上所示的定义来替换typedef定义的名称。 主要的难点在于C和C++中函数指针语法的可读性，使用typedef可以提高这类声明的可读性。然而，虽然在语法上是行得通的，但是函数不像其他简单的类型，函数可能会有返回值和参数，这样有时候会有复杂的函数指针。对于以上的三个问题，回答如下： Why is typedef used? 为了简化代码的可读性-尤其是函数指针或者是结构体名称 The syntax looks odd– 使得代码的可读性更高。 Is a function pointer created to … 是的，函数指针存储函数的地址。然而，当typedef用于结构体中时，仅仅是为了提高程序的可读性，程序在编译时编译器会在typedef使用的地方使用实际代码替换。 Example： typedef int (*t_somefunc)(int,int); int product(int u, int v) { return u*v; } t_somefunc afunc = &amp;product; ... int x2 = (*afunc)(123, 456); // call product() to calculate 123*456","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"C","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"C++小结","slug":"C-小结","permalink":"yongchunxiaofen.top/tags/C-小结/"}]},{"title":"Git常用指令速查","slug":"git-use-list","date":"2016-06-04T02:17:37.000Z","updated":"2016-06-30T02:48:39.000Z","comments":true,"path":"2016/06/04/git-use-list/","link":"","permalink":"yongchunxiaofen.top/2016/06/04/git-use-list/","excerpt":"Git命令名词解释： workspace： 工作区 Index/Stage： 暂存区 Repository： 仓库区（或本地仓库） Remote： 远程仓库 一、新建代码库# 在当前目录新建一个Git代码库 $git init # 新建一个目录，将其初始化为Git代码库 $git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url]","text":"Git命令名词解释： workspace： 工作区 Index/Stage： 暂存区 Repository： 仓库区（或本地仓库） Remote： 远程仓库 一、新建代码库# 在当前目录新建一个Git代码库 $git init # 新建一个目录，将其初始化为Git代码库 $git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name &quot;[name]&quot; $ git config [--global] user.email &quot;[email address]&quot; 三、增删文件# 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 四、代码提交# 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 五、分支# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 六、标签# 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 七、查看信息# 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 八、远程同步# 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 九、撤销# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 十、其他# 生成一个可供发布的压缩包 $ git archive 转自：阮一峰的网络日志-常用Git命令清单，感谢原发布者整理收集。","categories":[{"name":"Git","slug":"Git","permalink":"yongchunxiaofen.top/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"yongchunxiaofen.top/tags/Git/"}]},{"title":"Gitcafe使用笔记","slug":"simple-use-of-gitcafe","date":"2016-06-03T12:45:44.000Z","updated":"2016-06-30T02:48:22.000Z","comments":true,"path":"2016/06/03/simple-use-of-gitcafe/","link":"","permalink":"yongchunxiaofen.top/2016/06/03/simple-use-of-gitcafe/","excerpt":"gitcafe使用小记这是原来的域名，https://gitcafe.com/。后来gitcafe被合并到 Coding.net。所以新的域名是：https://coding.net/ 注册帐号 新建项目，可以选择public或者private。我选择的是public。 配置SSH 下载Git客户端，安装。 在Git上配置SSH密钥。 启动Git，生成一个存放SSH的文件夹。 mkdir ~/.ssh 生成Gitcafe的SSH密钥。","text":"gitcafe使用小记这是原来的域名，https://gitcafe.com/。后来gitcafe被合并到 Coding.net。所以新的域名是：https://coding.net/ 注册帐号 新建项目，可以选择public或者private。我选择的是public。 配置SSH 下载Git客户端，安装。 在Git上配置SSH密钥。 启动Git，生成一个存放SSH的文件夹。 mkdir ~/.ssh 生成Gitcafe的SSH密钥。 1ssh-keygen -t rsa -C &quot;your_email@email.com&quot; -f ~/.ssh/gitcafe 将your_email@email.com换成你的邮箱。 生成过程中，如果你不输入passphrase口令，可以直接回车。 SSH密钥生成结束后，打开存放SSH的文件夹，可以看到私钥gitcafe和公钥gitcafe.pub这两个文件。 生成配置文件。 touch ~/.ssh/config 打开该配置文件，复制一下内容到该config文件，保存。 12Host git.coding.net IdentityFile ~/.ssh/gitcafe 链接Gitcafe使用Git管理代码 打开之前生成的公钥文件gitcafe.pub，复制里边的内容。 进入Gitcafe&gt;账户&gt;SSH公钥。 将复制的内容添加到SSH-RSA公钥内容下的框里。 测试是否连接到Gitcafe服务器。 1ssh -T git@git.coding.net -i ~/.ssh/gitcafe 如果设置成功，则有如下提示 设置用户名和邮箱，并且touch-add-commit-push 全局设置: 12git config --global user.name &quot;yourname&quot;git config --global user.email youremail@email.com 接下来:在本地创建新的 Git 仓库 //如果你想在特定的文件夹下新建的话可以先cd进入文件夹，然后再执行以下命令。 mkdir ycwang522 cd ycwang522 git init touch README.md git add README.md git commit -m &apos;first commit&apos; git remote add origin https://git.coding.net/ycwang522/ycwang522.git git push -u origin master 这样，将新建的README.md文件就推送到了Gitcafe上ycwang522仓库了。 使用Gitcafe Pages搭建个人空间 创建一个gitcafe-pages的分支，并切换到该分支。 git checkout -b gitcafe-pages","categories":[{"name":"Gitcafe","slug":"Gitcafe","permalink":"yongchunxiaofen.top/categories/Gitcafe/"}],"tags":[{"name":"Git","slug":"Git","permalink":"yongchunxiaofen.top/tags/Git/"},{"name":"Gitcafe","slug":"Gitcafe","permalink":"yongchunxiaofen.top/tags/Gitcafe/"}]},{"title":"VS中的反汇编代码学习","slug":"assembly-language","date":"2016-06-02T03:06:16.000Z","updated":"2016-06-30T02:48:12.000Z","comments":true,"path":"2016/06/02/assembly-language/","link":"","permalink":"yongchunxiaofen.top/2016/06/02/assembly-language/","excerpt":"反汇编程序在内存中的模型编译器为程序分配的内存在逻辑上可分为：代码段、数据段、堆、栈 代码段： 保存程序文本 数据段： 保存初始化的全局变量和静态变量 BSS： 未初始化的全局变量和静态变量 堆： 动态内存分配，向地址增大的方向增长 栈： 存放局部变量，向地址减小的方向增长","text":"反汇编程序在内存中的模型编译器为程序分配的内存在逻辑上可分为：代码段、数据段、堆、栈 代码段： 保存程序文本 数据段： 保存初始化的全局变量和静态变量 BSS： 未初始化的全局变量和静态变量 堆： 动态内存分配，向地址增大的方向增长 栈： 存放局部变量，向地址减小的方向增长 寄存器的作用 EAX：累加(Accumulator)寄存器，常用于函数返回值 EBX：基址(Base)寄存器，以它为基址访问内存 ECX：计数器(Counter)寄存器，常用作字符串和循环操作中的计数器 EDX：数据(Data)寄存器，常用于乘除法和I/O指针 ESI：源变址寄存器DSI：目的变址寄存器 ESP：堆栈(Stack)指针寄存器，指向堆栈顶部 EBP：基址指针寄存器，指向当前堆栈底部 EIP：指令寄存器，指向下一条指令的地址 汇编代码常用指令 add：加法指令，第一个是目标操作数，第二个是源操作数，格式为：目标操作数 = 目标操作数 + 源操作数； sub：减法指令，格式同 add； call：调用函数，一般函数的参数放在寄存器中； ret：跳转会调用函数的地方。对应于call，返回到对应的call调用的下一条指令，若有返回值，则放入eax中； push：把一个32位的操作数压入堆栈中，这个操作在32位机中会使得esp被减4（字节），esp通常是指向栈顶的 pop：与push相反，esp每次加4（字节），一个数据出栈。pop的参数一般是一个寄存器，栈顶的数据被弹出到这个寄存器中； mov：数据传送。第一个参数是目的操作数，第二个参数是源操作数，就是把源操作数拷贝到目的一份。 xor：异或指令，这本身是一个逻辑运算指令，但在汇编指令中通常会见到它被用来实现清零功能。用 xor eax,eax这种操作来实现 mov eax,0，可以使速度更快，占用字节数更少。 lea：取得第二个参数地址后放入到前面的寄存器（第一个参数）中。然而lea也同样可以实现mov的操作，例如：lea edi,[ebx-0ch]方括号表示存储单元，也就是提取方括号中的数据所指向的内容，然而lea提取内容的地址，这样就实现了把（ebx-0ch）放入到了edi中，但是mov指令是不支持第二个操作数是一个寄存器减去一个数值的。 stos：串行存储指令，它实现把eax中的数据放入到edi所指的地址中，同时edi后移4个字节，这里的stos实际上对应的是stosd，其他的还有stosb,stosw分别对应1，2个字节。 jmp：无条件跳转指令，对应于大量的条件跳转指令。 jg：条件跳转，大于时成立，进行跳转，通常条件跳转之前会有一条比较指令（用于设置标志位）。 jl：小于时跳转 move ax,[bx][]表示间接寻址。 bx和[bx]的区别是： 前者操作数就是bx中存放的数，后者操作数是以bx中存放的数为地址的单元中的数。 比如：bx中存放的数是40F6H，40F6H、40F7H两个单元中存放的数是22H、23H，则： move ax，[bx]；//2223H传送到ax中 move ax，bx；//40F6H传送到ax中 ILT 是静态函数跳转表。 作用是记录了一些函数的入口然后跳过去，每个跳转jmp占一个字节，然后就是一个四字节的内存地址，加起来为五个字节。 函数的参数传递方式函数调用规则指的是调用者和被调用函数间传递参数及返回参数的方法，在Windows上，常用的有 Pascal方式、WINAPI方式（_stdcall）、C方式（_cdecl）。 _cdecl C调用规则 参数从右到左进入堆栈 在函数返回后，调用者要负责清除堆栈。 这种调用方式通常会生成较大的可执行程序。 _stdcall又称为WINAPI，调用规则为 参数从右到左进入堆栈 被调函数在返回前自行清理堆栈 这种方式生成的代码比cdecl小 Pascal调用规则（现在基本不用） 参数从左到右进入堆栈 被调函数在返回前自行清理堆栈 不支持可变参数的函数调用 参考文章 浅析VS2010反汇编，[寒山拾得 的专栏]，http://blog.csdn.net/u013467442/article/details/47060261","categories":[{"name":"汇编","slug":"汇编","permalink":"yongchunxiaofen.top/categories/汇编/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"yongchunxiaofen.top/tags/汇编/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"yongchunxiaofen.top/tags/Visual-Studio/"}]},{"title":"强制类型转换","slug":"type-casts","date":"2016-06-02T03:03:29.000Z","updated":"2016-06-30T02:47:57.000Z","comments":true,"path":"2016/06/02/type-casts/","link":"","permalink":"yongchunxiaofen.top/2016/06/02/type-casts/","excerpt":"首先看一道例子： 12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int a =6336; char *b = (char *)&amp;a; printf(\"%d\",*b); getchar(); return 0;&#125; 输出结果为：-64。 暂且不分析上边的题目，从内存模型入手分析。 C中，每一个变量都对应一个地址。地址空间中的值即0或1的高低电平。","text":"首先看一道例子： 12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int a =6336; char *b = (char *)&amp;a; printf(\"%d\",*b); getchar(); return 0;&#125; 输出结果为：-64。 暂且不分析上边的题目，从内存模型入手分析。 C中，每一个变量都对应一个地址。地址空间中的值即0或1的高低电平。 在内存中，存储的值不是0就是1.而变量解析时，是通过起始地址和变量类型来解析的。在计算机内存中，是没有「类型」这个概念的，类型如何定义只是语言层面的事情。 所以数据在内存中的存储是没有区别的，有区别的仅仅是对数据的处理方式不同。 例如，有如下变量：123int a;float b;double c; 假设起始地址是100，那么机器并不知道100-203是整型或者104-107是float型变量b。当有(float)a时，则是先按照int类型取出该变量在地址中的值，然后再将其按照int to float的规则转换成float型，编译器在取出int a对应的值时知道规则是从a的起始地址开始往后取4个字节的值。 对于指针之间的转换，指针 to 指针的强制类型转换是指针所指内容的类型由原来的类型转换为后面的类型。123int a =1;int *p=&amp;a;float *p1=(float *)p; 则p和p1的值都是&amp;a，但是*p是将&amp;a地址中的值按照int型变量进行解释，而*p1则是将&amp;a地址中的值按照float型变量进行解释。 例：指针类型强制转换123int m;int *pm = &amp;m;char *cp = (char *)&amp;m; pm指向一个整型，cp指向整型数的第一个字节 回到文章一开始的题目： 题目是将一个int类型数的地址强制转换成char类型指针，然后输出char类型指针指向的值。 从以上的分析可知，转换后的char类型指针指向int类型的第一个字节（实际上是低地址位的一个字节）。 如此，可以计算：6336的二进制数是：1 1000 1100 0000，char类型指针指向低地址位的一个字节， 那么char类型的指针指向的是：1100 0000， 而我们知道，计算机中正数是二进制的补码表示，所以将其转换成补码（负数的补码是在原码的基础上除符号位不变之外按位取反然后再加1）就是：1100 0000，即为-64。 参考文章 C语言指针强制类型转换，[mhjcumt的专栏].http://blog.csdn.net/mhjcumt/article/details/7355127 C语言指针强制类型转换,[jltxgcy的专栏].http://blog.csdn.net/jltxgcy/article/details/8766537 指针类型的强制转换问题,[知乎].https://www.zhihu.com/question/24174125","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"类型转换","slug":"类型转换","permalink":"yongchunxiaofen.top/tags/类型转换/"}]},{"title":"复杂指针解析","slug":"complex-pointer","date":"2016-05-31T15:01:57.000Z","updated":"2016-06-30T02:47:51.000Z","comments":true,"path":"2016/05/31/complex-pointer/","link":"","permalink":"yongchunxiaofen.top/2016/05/31/complex-pointer/","excerpt":"右左法则—-复杂指针解析&lt;转&gt;http://blog.csdn.net/code_crash/article/details/4854965 首先看看如下一个声明： int* ( *( *fun )( int* ) )[10]; 这是一个会让初学者感到头晕目眩、感到恐惧的函数指针声明。在熟练掌握C/C++的声明语法之前，不学习一定的规则，想理解好这类复杂声明是比较困难的。 C/C++所有复杂的声明结构，都是由各种声明嵌套构成的。 如何解读复杂指针声明？右左法则是一个很著名、很有效的方法。 不过，右左法则其实并不是C/C++标准里面的内容，它是从C/C++标准的声明规定中归纳出来的方法。 C/C++标准的声明规则，是用来解决如何创建声明的，而右左法则是用来解决如何辩识一个声明的，从嵌套的角度看，两者可以说是一个相反的过程。右左法则的英文原文是这样说的： The right-left rule: Start reading the declaration from the innermost parentheses, go right, and then go left. When you encounter parentheses, the direction should be reversed. Once everything in the parentheses has been parsed, jump out of it. Continue till the whole declaration has been parsed.","text":"右左法则—-复杂指针解析&lt;转&gt;http://blog.csdn.net/code_crash/article/details/4854965 首先看看如下一个声明： int* ( *( *fun )( int* ) )[10]; 这是一个会让初学者感到头晕目眩、感到恐惧的函数指针声明。在熟练掌握C/C++的声明语法之前，不学习一定的规则，想理解好这类复杂声明是比较困难的。 C/C++所有复杂的声明结构，都是由各种声明嵌套构成的。 如何解读复杂指针声明？右左法则是一个很著名、很有效的方法。 不过，右左法则其实并不是C/C++标准里面的内容，它是从C/C++标准的声明规定中归纳出来的方法。 C/C++标准的声明规则，是用来解决如何创建声明的，而右左法则是用来解决如何辩识一个声明的，从嵌套的角度看，两者可以说是一个相反的过程。右左法则的英文原文是这样说的： The right-left rule: Start reading the declaration from the innermost parentheses, go right, and then go left. When you encounter parentheses, the direction should be reversed. Once everything in the parentheses has been parsed, jump out of it. Continue till the whole declaration has been parsed. 这段英文的翻译如下： 右左法则：首先从最里面的圆括号看起，然后往右看，再往左看。每当遇到圆括号时，就应该掉转阅读方向。一旦解析完圆括号里面所有的东西，就跳出圆括号。重复这个过程直到整个声明解析完毕。 笔者要对这个法则进行一个小小的修正，应该是从未定义的标识符开始阅读，而不是从括号读起，之所以是未定义的标识符，是因为一个声明里面可能有多个标识符，但未定义的标识符只会有一个。 现在通过一些例子来讨论右左法则的应用，先从最简单的开始，逐步加深： int (*func)(int *p); 首先找到那个未定义的标识符，就是func，它的外面有一对圆括号，而且左边是一个号，这说明func是一个指针，然后跳出这个圆括号，先看右边，也是一个圆括号，这说明(func)是一个函数，而func是一个指向这类函数的指针，就是一个函数指针，这类函数具有int*类型的形参，返回值类型是int。 int (*func)(int *p, int (*f)(int*)); func被一对括号包含，且左边有一个*号，说明func是一个指针，跳出括号，右边也有个括号，那么func是一个指向函数的指针，这类函数具有int *和int (*)(int*)这样的形参，返回值为int类型。再来看一看func的形参int (*f)(int*)，类似前面的解释，f也是一个函数指针，指向的函数具有int*类型的形参，返回值为int。 int (*func[5])(int *p); func右边是一个[]运算符，说明func是一个具有5个元素的数组，func的左边有一个*，说明func的元素是指针，要注意这里的*不是修饰func的，而是修饰func[5]的，原因是[]运算符优先级比*高，func先跟[]结合，因此*修饰的是func[5]。跳出这个括号，看右边，也是一对圆括号，说明func数组的元素是函数类型的指针，它所指向的函数具有int*类型的形参，返回值类型为int。 int (*(*func)[5])(int *p); func被一个圆括号包含，左边又有一个*，那么func是一个指针，跳出括号，右边是一个[]运算符号，说明func是一个指向数组的指针，现在往左看，左边有一个*号，说明这个数组的元素是指针，再跳出括号，右边又有一个括号，说明这个数组的元素是指向函数的指针。总结一下，就是：func是一个指向数组的指针，这个数组的元素是函数指针，这些指针指向具有int*形参，返回值为int类型的函数。 int (*(*func)(int *p))[5]; func是一个函数指针，这类函数具有int*类型的形参，返回值是指向数组的指针，所指向的数组的元素是具有5个int元素的数组。 要注意有些复杂指针声明是非法的，例如： int func(void) [5]; func是一个返回值为具有5个int元素的数组的函数。但C语言的函数返回值不能为数组，这是因为如果允许函数返回值为数组，那么接收这个数组的内容的东西，也必须是一个数组，但C/C++语言的数组名是一个不可修改的左值，它不能直接被另一个数组的内容修改，因此函数返回值不能为数组。 int func[5](void); func是一个具有5个元素的数组，这个数组的元素都是函数。这也是非法的，因为数组的元素必须是对象，但函数不是对象，不能作为数组的元素。 实际编程当中，需要声明一个复杂指针时，如果把整个声明写成上面所示这些形式，将对可读性带来一定的损害，应该用typedef来对声明逐层分解，增强可读性。 typedef是一种声明，但它声明的不是变量，也没有创建新类型，而是某种类型的别名。typedef有很大的用途，对一个复杂声明进行分解以增强可读性是其作用之一。例如对于声明： int (*(*func)(int *p))[5]; 可以这样分解： typedef int (*PARA)[5]; typedef PARA (*func)(int *); 这样就容易看得多了。 typedef的另一个作用，是作为基于对象编程的高层抽象手段。在ADT中，它可以用来在C/C++和现实世界的物件间建立关联，将这些物件抽象成C/C++的类型系统。在设计ADT的时候，我们常常声明某个指针的别名，例如： typedef struct node * list; 从ADT的角度看，这个声明是再自然不过的事情，可以用list来定义一个列表。但从C/C++语法的角度来看，它其实是不符合C/C++声明语法的逻辑的，它暴力地将指针声明符从指针声明器中分离出来，这会造成一些异于人们阅读习惯的现象，考虑下面代码： const struct node *p1; typedef struct node *list; const list p2; p1类型是const struct node*，那么p2呢？如果你以为就是把list简单“代入”p2，然后得出p2类型也是const struct node*的结果，就大错特错了。p2的类型其实是struct node * const p2，那个const限定的是p2，不是node。造成这一奇异现象的原因是指针声明器被分割，标准中规定： 6.7.5.1 Pointer declarators Semantics If in the declaration ‘‘T D1’’, D1 has the form type-qualifier-listopt D and the type specified for ident in the declaration ‘‘T D’’ is ‘‘derived-declarator-type-list T’’ then the type specified for ident is ‘‘derived-declarator-type-list type-qualifier-list pointer to T’’ For each type qualifier in the list, ident is a so-qualified pointer. 指针的声明器由指针声明符*、可选的类型限定词type-qualifier-listopt和标识符D组成，这三者在逻辑上是一个整体，构成一个完整的指针声明器。这也是多个变量同列定义时指针声明符必须紧跟标识符的原因，例如： int *p, q, *k; p和k都是指针，但q不是，这是因为*p、*k是一个整体指针声明器，以表示声明的是一个指针。编译器会把指针声明符左边的类型包括其限定词作为指针指向的实体的类型，右边的限定词限定被声明的标识符。但现在typedef struct node *list硬生生把*从整个指针声明器中分离出来，编译器找不到*，会认为const list p2中的const是限定p2的，正因如此，p2的类型是node * const而不是const node*。 虽然typedef struct node* list不符合声明语法的逻辑，但基于typedef在ADT中的重要作用以及信息隐藏的要求，我们应该让用户这样使用list A，而不是list *A，因此在ADT的设计中仍应使用上述typedef语法，但需要注意其带来的不利影响。","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"指针","slug":"指针","permalink":"yongchunxiaofen.top/tags/指针/"}]},{"title":"C++中的转义序列","slug":"Escape-character","date":"2016-05-31T14:59:41.000Z","updated":"2016-06-30T02:47:45.000Z","comments":true,"path":"2016/05/31/Escape-character/","link":"","permalink":"yongchunxiaofen.top/2016/05/31/Escape-character/","excerpt":"","text":"C++中的转义序列两类字符不能直接使用： 一类是不可打印字符，例如退格等。因为没有可视的图符。 另一类是有特殊含义的字符（单引号，双引号，问号，反斜线）等。 这些情况下会用到转义序列，转移序列均以反斜线\\开始。 C++规定了如下的转义字符： 123456789101112131415换行符 \\n 横线制表符 \\t响铃符 \\a 纵向制表符 \\v退格符 \\b 双引号 \\\"反斜线 \\\\ 问号 \\?单引号 \\' 回车符 \\r``` 程序中，上述转义符被当作一个字符来使用。&lt;!-- more --&gt;泛化的转义序列，形式是`\\x`后跟一个或多个十六进制数字，或者`\\`后边跟1个、2个、或者3个八进制数字。例如```cpp\\7（响铃） \\12（换行符）\\40（空格） \\0（空字符）\\115（字符M） \\x4d（字符M） 注意: 如果反斜线后边跟着的八进制数字超过3个，只有前3个数字与\\构成转义序列。 例如”\\1234“表示两个字符，即八进制数123对应的字符以及字符4. 相反，\\x要用到后边跟着的所有数字，例如”\\x1234“表示一个16位的字符，该字符由这4个十六进制数所对应的比唯一确定。 例题： 以下程序段的输出结果是：12char s[]=\"\\\\123456\\123456\\t\";printf(\"%d\\n\",strlen(s)); 答案：12","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"转义字符","slug":"转义字符","permalink":"yongchunxiaofen.top/tags/转义字符/"}]},{"title":"计算代码运行时间","slug":"calculate-runtime-of-code","date":"2016-05-31T09:19:40.000Z","updated":"2016-06-30T02:47:37.000Z","comments":true,"path":"2016/05/31/calculate-runtime-of-code/","link":"","permalink":"yongchunxiaofen.top/2016/05/31/calculate-runtime-of-code/","excerpt":"计算代码的运行时间包含头文件1#include&lt;time.h&gt; 在程序执行的起始点，插入代码12clock_t start,finish;start=clock(); 在程序执行的终点，插入代码：12finish=clock();printf(\"共耗时%.3lf秒\"，((double)finish - start)/1000);","text":"计算代码的运行时间包含头文件1#include&lt;time.h&gt; 在程序执行的起始点，插入代码12clock_t start,finish;start=clock(); 在程序执行的终点，插入代码：12finish=clock();printf(\"共耗时%.3lf秒\"，((double)finish - start)/1000); 例如，有如下代码：123456void swap(int a[], int i, int j)&#123; int temp = a[i]; a[i] = a[j]; a[j] = temp;&#125; 123456789101112131415//Sort1void BubbleSort1(int a[], int length)&#123; int i, j; for (i = 0; i &lt; length - 1; i++) &#123; for (j = length - 2; j &gt;= i; j--) &#123; if (a[j]&gt;a[j + 1]) &#123; swap(a, j, j + 1); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;stdio.h&gt;#define LENGTH 10int main()&#123; clock_t start, finish; start = clock(); srand(unsigned(time(0))); int a[LENGTH]; printf(\"排序前：\"); for (int k = 9; k &gt;=0; k--) &#123;// a[k] = rand()%10000; a[k] = k + 1; printf(\"%d \", a[k]); &#125; BubbleSort1(a,LENGTH); printf(\"\\n排序后：\"); for (int i1 = 0; i1 &lt; 10; i1++) &#123; printf(\"%d \", a[i1]); &#125; finish = clock(); printf(\"共耗时%.3lf秒\", ((double)finish - start) / 1000); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"C","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"}]},{"title":"static详解","slug":"static-detail-explaination","date":"2016-05-30T07:40:42.000Z","updated":"2016-06-30T02:47:28.000Z","comments":true,"path":"2016/05/30/static-detail-explaination/","link":"","permalink":"yongchunxiaofen.top/2016/05/30/static-detail-explaination/","excerpt":"static详解对于static关键字的作用，一般的回答为如下形式 1.限制变量的作用域 2.设置变量的存储域 static的特点是：static局部变量的“记忆性”与生存期的“全局性” 记忆性是指在两次函数调用时，在第二次调用进入时，能保持第一次调用退出时的值。 static局部变量在运行期仅初始化一次，下次再调用时，不再进行初始化，在上一次调用的基础上进行操作。","text":"static详解对于static关键字的作用，一般的回答为如下形式 1.限制变量的作用域 2.设置变量的存储域 static的特点是：static局部变量的“记忆性”与生存期的“全局性” 记忆性是指在两次函数调用时，在第二次调用进入时，能保持第一次调用退出时的值。 static局部变量在运行期仅初始化一次，下次再调用时，不再进行初始化，在上一次调用的基础上进行操作。 例如：123456789101112131415161718#include &lt;iostream&gt;using namespace std;void staticLocalVar()&#123; static int a = 0; // 运行期时初始化一次, 下次再调用时, 不进行初始化工作 cout&lt;&lt;\"a=\"&lt;&lt;a&lt;&lt;endl; ++a;&#125;int main()&#123; staticLocalVar(); // 第一次调用, 输出a=0 staticLocalVar(); // 第二次调用, 记忆了第一次退出时的值, 输出a=1 return 0;&#125; 示例程序源于static用法小结 记忆性的应用利用static局部变量的记忆性可以记录函数调用的次数。 全局性利用static变量生存期的“全局性”，可以改善“return a point/reference to a local object”的问题。 Local object的问题在于退出函数，生存期结束。利用static的作用，可以延长变量的生存期。 例如123456789// IP address to string format// Used in Ethernet Frame and IP Header analysisconst char * IpToStr(UINT32 IpAddr)&#123; static char strBuff[16]; // static局部变量, 用于返回地址有效 const unsigned char *pChIP = (const unsigned char *)&amp;IpAddr; sprintf(strBuff, \"%u.%u.%u.%u\", pChIP[0], pChIP[1], pChIP[2], pChIP[3]); return strBuff;&#125; 静态函数函数前的static不是指储存方式，而是指对函数的作用域仅限于本文件，所以静态函数又称内部函数。 对于全局变量，无论是否有static关键字，其都是存储在静态存储区，生存周期都是全局的。 使用内部函数（静态函数）的好处是：不同的人编写不同的函数，不用担心自己定义的函数，是否会与其他文件中的函数同名。 静态数据成员（C++独有）表示属于一个类而不是属于此类的任何特性的对象的变量和函数。 这儿static是指示变量/函数在此类中的唯一性。 static类型声明符在C语言中主要有三个方面的用途： 1.声明静态局部变量 2.声明静态外部全局变量 3.声明静态外部函数 静态变量的一个例子：123456789101112131415161718192021222324static int a=1;void fun1(void)&#123; a=2;&#125;void fun2(void)&#123; int a=3;&#125;void fun3(void)&#123; static int a=4;&#125;int main()&#123; printf(“%d”,a); fun1( ); printf(“%d”,a); fun2( ); printf(“%d”，a）； fun3( ) printf(“%d”,a); &#125; 程序输出的结果是：1222 分析： 首先定义一个全局变量a。 fun1中，并没有定义a，所以fun1中的a是函数外部全局变量，fun1中a被重新赋值为2. fun2中和fun3中都重新定义了a， 而fun2中的a是一局部非静态变量， 当函数调用结束后该局部变量被直接销毁。 fun3中的a为静态变量（只分配一次内存）， 虽然函数调用完成之后a不会销毁， 但只是在函数内部才会生效， 所以main函数打印的是全局变量a。","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"C","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"}]},{"title":"青蛙跳台阶题目及其延伸","slug":"interview-answer-of-tencent","date":"2016-05-30T02:51:35.000Z","updated":"2016-06-30T02:47:10.000Z","comments":true,"path":"2016/05/30/interview-answer-of-tencent/","link":"","permalink":"yongchunxiaofen.top/2016/05/30/interview-answer-of-tencent/","excerpt":"青蛙跳台阶题目初级腾讯面试题目：有一个50阶的楼梯，每次可以上一阶或者两阶，总共的方法有多少种。算法应用：递归 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//int tencent(int n)double tencent(int n) //由于递归50次计算时一个很大的值，为了防止溢出，将int改成double型。&#123; if(n==1) &#123; return 1.0; &#125; else if(n==2) &#123; return 2.0; &#125; else &#123; return tencent(n-1)+tencent(n-2); &#125;&#125;void main()&#123; printf(\"%f\",tencent(50)); getchar();&#125;","text":"青蛙跳台阶题目初级腾讯面试题目：有一个50阶的楼梯，每次可以上一阶或者两阶，总共的方法有多少种。算法应用：递归 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//int tencent(int n)double tencent(int n) //由于递归50次计算时一个很大的值，为了防止溢出，将int改成double型。&#123; if(n==1) &#123; return 1.0; &#125; else if(n==2) &#123; return 2.0; &#125; else &#123; return tencent(n-1)+tencent(n-2); &#125;&#125;void main()&#123; printf(\"%f\",tencent(50)); getchar();&#125; 青蛙跳台阶进阶题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 **题目来自牛客网@xiaobaibai同学，感谢** 123456789101112131415161718192021class Solution &#123;public: int jumpFloorII(int number) &#123; if(number==0) &#123; return -1; &#125; else if(number==1) &#123; return 1; &#125; else &#123; return jumpFloorII(number-1)*2; &#125; &#125;&#125;;","categories":[{"name":"C++面试","slug":"C-面试","permalink":"yongchunxiaofen.top/categories/C-面试/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"算法","slug":"算法","permalink":"yongchunxiaofen.top/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"yongchunxiaofen.top/tags/数据结构/"},{"name":"腾讯","slug":"腾讯","permalink":"yongchunxiaofen.top/tags/腾讯/"}]},{"title":"中缀表达式与后缀表达式之间的转换","slug":"middle-back-transfer","date":"2016-05-30T02:40:47.000Z","updated":"2016-05-30T03:00:56.000Z","comments":true,"path":"2016/05/30/middle-back-transfer/","link":"","permalink":"yongchunxiaofen.top/2016/05/30/middle-back-transfer/","excerpt":"中缀表达式转换成后缀表达式———————————————————————————— 1.转换规则从左到右遍历中缀表达式的每个数字和符号：若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。","text":"中缀表达式转换成后缀表达式———————————————————————————— 1.转换规则从左到右遍历中缀表达式的每个数字和符号：若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。 例：9+（3-1）*3+10/2转换为后缀表达式之后结果为9 3 1 - 3 * + 10 2 / + 后缀表达式结果计算2.转换规则从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。 例如：9 3 1 - 3 * + 10 2 / +经过计算之后结果为20","categories":[{"name":"数据结构","slug":"数据结构","permalink":"yongchunxiaofen.top/categories/数据结构/"}],"tags":[{"name":"中缀表达式","slug":"中缀表达式","permalink":"yongchunxiaofen.top/tags/中缀表达式/"},{"name":"数据结构","slug":"数据结构","permalink":"yongchunxiaofen.top/tags/数据结构/"}]},{"title":"类的早期绑定&迟绑定","slug":"cpp-binding","date":"2016-05-30T02:38:20.000Z","updated":"2016-06-30T02:46:26.000Z","comments":true,"path":"2016/05/30/cpp-binding/","link":"","permalink":"yongchunxiaofen.top/2016/05/30/cpp-binding/","excerpt":"对于以下的例子：123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;class animal&#123; public: void sleep()&#123; cout&lt;&lt;\"animal sleep\"&lt;&lt;endl; &#125; void breathe()&#123; cout&lt;&lt;\"animal breathe\"&lt;&lt;endl; &#125;&#125;;class fish:public animal&#123; public: void breathe()&#123; cout&lt;&lt;\"fish bubble\"&lt;&lt;endl; &#125;&#125;;int main()&#123; fish fh; animal *pAnimal=&amp;fh; pAnimal-&gt;breathe();&#125;","text":"对于以下的例子：123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;class animal&#123; public: void sleep()&#123; cout&lt;&lt;\"animal sleep\"&lt;&lt;endl; &#125; void breathe()&#123; cout&lt;&lt;\"animal breathe\"&lt;&lt;endl; &#125;&#125;;class fish:public animal&#123; public: void breathe()&#123; cout&lt;&lt;\"fish bubble\"&lt;&lt;endl; &#125;&#125;;int main()&#123; fish fh; animal *pAnimal=&amp;fh; pAnimal-&gt;breathe();&#125; 答案是输出：animal breathe产生原因分析： 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。作者：Shiyang Ao链接：https://www.zhihu.com/question/25572937/answer/34441503来源：知乎 派生类和基类的关系并不是两个独立的类型，在派生关系中，派生类型“是一个”基类类型(Derived class is a base class)。在C++语法里规定：基类指针可以指向一个派生类对象，但派生类指针不能指向基类对象。用问题里的例子来说DerivedClass is a BaseClass派生类型之间的数据结构类似于这样： BaseClass : [Base Data] DerivedClass : [Base Data][Derived Data]派生类型的数据附加在其父类之后，这意味着当使用一个父类型指针指向其派生类的时候，父类访问到的数据是派生类当中由父类继承下来的这部分数据对比起见，我们再定义一个派生类的派生类class DerivedDerivedClass : public DerivedClass它的数据结构如下：DerivedDerivedClass : [Base Data][Derived Data][DerivedDerived Data] 而通过基类指针 BaseClass pbase访问每一个类型的数据部分为：[Base Data][Base Data][Derived Data]*[Base Data][Derived Data][DerivedDerived Data] 通过派生类指针 DerivedClass pderived访问每一个类型的数据部分为：[Base Data] 不能访问，派生类型指针不能指向基类对象（因为数据内容不够大，通过派生类指针访问基类对象会导致越界）[Base Data][Derived Data]*[Base Data][Derived Data][DerivedDerived Data] 动态多态性前面输出的结果是因为编译器在编译的时候，就已经确定了对象调用的函数的地址，要解决这个问题就要使用迟绑定（late binding）技术。当编译器使用迟绑定时，就会在运行时再去确定对象的类型以及正确的调用函数。而要让编译器采用迟绑定，就要在基类中声明函数时使用virtual关键字（注意，这是必须的，很多学员就是因为没有使用虚函数而写出很多错误的例子），这样的函数我们称为虚函数。一旦某个函数在基类中声明为virtual，那么在所有的派生类中该函数都是virtual，而不需要再显式地声明为virtual。将上边一段代码修改以后： 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;class animal&#123; public: void sleep()&#123; cout&lt;&lt;\"animal sleep\"&lt;&lt;endl; &#125; virtual void breathe()&#123; cout&lt;&lt;\"animal breathe\"&lt;&lt;endl; &#125;&#125;;class fish:public animal&#123; public: void breathe()&#123; cout&lt;&lt;\"fish bubble\"&lt;&lt;endl; &#125;&#125;;int main()&#123; fish fh; animal *pAnimal=&amp;fh; pAnimal-&gt;breathe();&#125; 运行结果：fish bubble 类中内存的分布基类的内存分布情况：1)对于无虚函数的类A 1234class A&#123;void g()&#123;.....&#125;&#125;; 则sizeof(A)=1； 如果改为如下：class A{public: virtual void f() { …… } void g(){…..}}则sizeof(A)=4! 这是因为在类A中存在virtual function,为了实现多态，每个含有virtual function的类中都隐式包含着一个静态虚指针 vfptr指向该类的静态虚表vtable, vtable中的表项指向类中的每个virtual function的入口地址。 动态绑定过程的实现其过程如下： 程序运行到动态绑定时，通过基类的指针所指向的对象类型，通过vfptr找到其所指向的vtable，然后调用其相应的方法，即可实现多态。例如：A c;B e;A *pc=&e; //设置breakpoint，运行到此处pc=&c;","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"类","slug":"类","permalink":"yongchunxiaofen.top/tags/类/"},{"name":"动态绑定","slug":"动态绑定","permalink":"yongchunxiaofen.top/tags/动态绑定/"}]},{"title":"C++面试宝典备忘录","slug":"cpp-programmer-interview","date":"2016-05-30T02:33:19.000Z","updated":"2016-07-05T01:29:57.000Z","comments":true,"path":"2016/05/30/cpp-programmer-interview/","link":"","permalink":"yongchunxiaofen.top/2016/05/30/cpp-programmer-interview/","excerpt":"1. 自增自减前操作与后操作的区别 前自增自减操作的优先级大于赋值运算符（=），而后自增自减操作的优先级小于赋值运算符，后自增自减操作后表达式的值不会发生改变。 2. 指针自增自减的问题分析 指针的自增和自减是将指针的所指地址加1或者减1的操作，分前置和后置。例如：p是一个指针变量，++p将p加1，++p将p所指单元加1，p++只将p加1，++p++将p加1，同时也将*p所指单元加1.","text":"1. 自增自减前操作与后操作的区别 前自增自减操作的优先级大于赋值运算符（=），而后自增自减操作的优先级小于赋值运算符，后自增自减操作后表达式的值不会发生改变。 2. 指针自增自减的问题分析 指针的自增和自减是将指针的所指地址加1或者减1的操作，分前置和后置。例如：p是一个指针变量，++p将p加1，++p将p所指单元加1，p++只将p加1，++p++将p加1，同时也将*p所指单元加1. 3. 左值和右值的区别 左值可以出现在赋值语句的左边或右边，而右值只能出现在赋值的右边，而不能出现在左边。实际上，左值是一个储存地址，右值是一个具体的数据或者数值。 4. C++中的作用域分为 全局作用域 和 局部作用域(语句作用域)，定义在所有函数外部的变量具有全局作用域， 全局变量可以在程序中的任何地方访问。 例如 12345678910111213141516171819202122#include&lt;isotream&gt;void main()&#123; int a=0,b=0;//定义全局变量a、b，并初始化 a++; b++; cout&lt;&lt;a&lt;&lt;endl;//a=1 cout&lt;&lt;b&lt;&lt;endl;//b=1; &#123; float a=0.1;//定义局部变量a a++; b++; cout&lt;&lt;a&lt;&lt;endl;//局部变量a=1.1 cout&lt;&lt;b&lt;&lt;endl;//全局变量b=2 &#125; a++; b++; cout&lt;&lt;a&lt;&lt;endl;//a=2 cout&lt;&lt;b&lt;&lt;endl;//b=3 cin&gt;&gt;a; //不同作用域的变量可以使用相同的变量名，全局变量可以在程序中的任何地方访问。&#125; 5. 引用 引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。引用的声明方法：类型标识符 &amp;引用名=目标变量名；有关引用详细的说明参考：C++中引用（&amp;）的用法和应用实例 6.递归 递归算法解题的效率相对较低，在递归调用的过程中系统为每一层的返回值，局部量等开辟了栈了储存。使用递归的时候需要消耗较多的栈空间，所以递归过程次数较多时容易造成栈的溢出。在栈的尺寸大小受到限制时，一般避免使用递归。递归经典问题：汉诺塔问题1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;//第一个塔为初始塔，中间的塔为借用塔，最后一个塔为目标塔int i=1;//记录步数void move(int n,char from,char to) //将编号为n的盘子由from移动到to&#123;printf(\"第%d步:将%d号盘子%c----&gt;%c\\n\",i++,n,from,to);&#125;void hanoi(int n,char from,char denpend_on,char to)//将n个盘子由初始塔移动到目标塔(利用借用塔)&#123; if (n==1) move(1,from,to);//只有一个盘子是直接将初塔上的盘子移动到目的地 else &#123; hanoi(n-1,from,to,denpend_on);//先将初始塔的前n-1个盘子借助目的塔移动到借用塔上 move(n,from,to); //将剩下的一个盘子移动到目的塔上 hanoi(n-1,denpend_on,from,to);//最后将借用塔上的n-1个盘子移动到目的塔上 &#125;&#125;void main()&#123; printf(\"请输入盘子的个数:\\n\"); int n; scanf(\"%d\",&amp;n); char x='A',y='B',z='C'; printf(\"盘子移动情况如下:\\n\"); hanoi(n,x,y,z);&#125; 7. 异常与错误 异常就是程序运行时出现的不正常，它可能会导致系统无法正常运行甚至停止运行等严重的情况，编程者需要实现好的异常处理来保证程序的稳定性。C++中，异常机制可以提供程序中错误检测与错误处理部分之间的通信。详细介绍参考C++异常以及错误处理C++中，系统通过try块和异常处理构成了异常机制；其中通过catch语句来捕捉运行时的异常，并且执行异常处理，通过throw语句可以抛出异常。 8. 包含头文件时如何查找头文件 #include的使用方式有两种：123456&gt; 系统标准头文件用尖括号括起来，这样编译器会在系统文件目录下查找。&gt; 用户自定义的文件用双引号括起来，编译器首先会在用户目录下查找，然后再到C++安装目录中查找，最后在系统文件中查找。## 9. 内存分配(new)和释放(delete)&gt; new的使用方式：```指针变量=new 数据类型 实例代码：int *p；p=new int;p直接指向一段由new分配而来的新内存空间。操作时，通过对指针p的操作对p所指向的内存空间进行操作：int *p=new int; *p=100; cout&lt;&lt;*P&lt;&lt;endl;delete的使用：使用方式为：delete 指针变量 1234567示例代码：int *p;p=new int;*p=100;cout&lt;&lt;*p&lt;&lt;endl;delete p;//释放内存空间system(\"pause\"); 10. 数组指针域指针数组 数组指针：指向一个数组的指针就是数组指针。例如int (*ap) [2];//该代码定义了一个指向包含两个元素的数组指针指针数组：如果一个数组的每一个元素都是指针，则这个数组是一个指针数组。例如：char *chararr[]={&quot;Fortran&quot;,&quot;C&quot;,&quot;C++&quot;,&quot;Basic&quot;} 11. 引用与值传递 值传递是指将要传递的值作为一个副本传递。值传递过程中，被调用函数的形参作为被调函数的局部变量处理。值传递的特点是被调函数对形参的任何操作都是作为局部变量进行，不会更改主调函数的实参变量的值。例如，有如下代码： 123456789101112void func1(int x)//参数为值传递的函数&#123; x=x+10;&#125;...int n=0;func1(n);//值传递cout&lt;&lt;&quot;n=&quot;&lt;&lt;n&lt;&lt;endl;运行结果为：n=0 结果分析：由于func1函数体内的x采用的是值传递的方式，它只是外部变量n的一个副本，改变x的值不会影响n的值，所以n的值仍然为0. 引用传递传递的是引用对象的内存地址。在地址传递过程中，被调函数的形参也作为局部变量在堆栈中开辟了内存空间。 引用传递的示例代码： 123456789101112void func2(int &amp;x)&#123; x=x+10;&#125;...int n=0;func2(n);cout&lt;&lt;\"n=\"&lt;&lt;n&lt;&lt;endl;执行结果为：n=10//结果分析：由于func2（）函数体内的x采用的是引用传递的方式，x是外部变量n的引用，x和n表示的是相同的对象，所以当x发生改变时n的值也相应改变。 总结值传递传递的是一个值得副本。函数对形参的操作不会影响实参的值，而引用传递触底的引用对象的内存地址，函数对形参的操作会影响实参的值。 12. 成员变量的访问方式 三种访问方式分别为：private,protected,public三种private：只能被该类的方法(成员函数)访问，是私有变量，不能被该类的对象访问。protected：可以被该类的方法和其友元函数访问，但不能被该类的对象访问。public：可以被该类中的方法和其友元函数访问，是公有变量，也可以被该类的对象访问。 在C语言中，如果没有申明访问权限，默认的访问权限是public，在C++中，默认的访问权限是private。所以在类中的成员中如果需要外部调用都需要加上关键词为公有类型（public）。 13. 多态 是面向对象的重要特性之一，它是一种行为的封装，即“一个接口，多种实现”，也就是同一种事物表现出的多种形态。多态的主要作用表现为以下两点：1：可以不必为每一个派生类编写功能调用，只需要对抽象基类进行处理即可。2：派生类的功能可以被基类的方法或引用变量所调用，称作向后兼容。 纯虚函数 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”： virtual void funtion()=0引入原因：在很多情况下，基类本身生成对象是不合情理的，因此引入虚函数概念，则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。多态性：编译时多态性 - 重载函数实现；运行时多态性 - 虚函数实现。 14. 继承时访问级别的变化C++中，继承时可以降低父类的访问级别的public（公用继承）：基类成员保持自己的访问级别。protected（受保护继承）：基类的public和protected成员在派生类中为protected成员。基类的private成员保持为private。private（私有继承）：基类的所有成员在派生类中为private成员。 小插曲覆盖、重载和多态的区别原文转自博客园_C++覆盖、重载、多态区别 覆盖：在基类中定义了一个非虚拟函数，然后在派生类中又定义了一个同名同参数同返回类型的函数，这就是覆盖了。在派生类对象上直接调用这个函数名，只会调用派生类中的那个。例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243//coverage.cpp #include &lt;iostream&gt;using namespace std; class A&#123;public: void ShowMessage();&#125;;class B:public A&#123;public: void ShowMessage();&#125;;void A::ShowMessage()&#123; cout&lt;&lt;\"Hello,This is A./n\"; return;&#125;void B::ShowMessage()&#123; cout&lt;&lt;\"Hello,This is B./n\"; return;&#125;int main()&#123; A* p; B memb; *p = memb; p-&gt;ShowMessage(); memb.ShowMessage(); return 0;&#125;//输出为：//Hello,This is A.//Hello,This is B. 重载：在同一个类中（此处与原文略有不同），有两个或多个函数名相同的函数，但是函数的形参列表不同，virtual关键字可有可无。在调用相同函数名的函数时，根据形参列表确定到底该调用哪一个函数。例如： 12345678910111213141516171819202122232425262728293031323334//reload#include &lt;iostream&gt;using namespace std;class A&#123;public: void ShowMessage(); void ShowMessage(string str);&#125;;void A::ShowMessage()&#123;cout&lt;&lt;\"Hi,This is A./n\"; return;&#125;void A::ShowMessage(string str)&#123; cout&lt;&lt;str&lt;&lt;endl; return;&#125;int main()&#123; A mem; mem.ShowMessage(); mem.ShowMessage(\"Hello.How are you?/n\"); return 0;&#125;//输出为：//Hi,This is A.//Hello.How are you? 多态：在基类中定义了一个虚拟函数，然后在派生类中又定义一个同名，同参数表的函数，这就是多态。多态是这3种情况中唯一采用动态绑定技术的一种情况。也就是说，通过一个基类指针来操作对象，如果对象是基类对象，就会调用基类中的那个函数，如果对象实际是派生类对象，就会调用派生类中的那个函数，调用哪个函数并不由函数的参数表决定，而是由函数的实际类型决定。 123456789101112131415161718192021222324252627282930313233343536373839404142//poly.cpp#include &lt;iostream&gt;using namespace std;class A&#123;public: virtual void ShowMessage();//声明基类的虚函数&#125;;class B:public A&#123;public: void ShowMessage();&#125;;void A::ShowMessage()&#123; cout&lt;&lt;\"This is A./n\"; return;&#125;void B::ShowMessage()&#123; cout&lt;&lt;\"This is B./n\"; return;&#125;int main()&#123; A* p; p=new A(); p-&gt;ShowMessage(); p=new B(); p-&gt;ShowMessage(); return 0;&#125;//输出为：//This is A.//This is B. 15. 内联函数 在类声明的内部声明或定义的成员函数叫做内联（inline）函数。特点： 一般来说，内联机制适用于优化小的，只有几行的而且经常被调用的函数。分类：（1）在类声明的内部声明，而在类声明外部定义的叫做显式内联函数。（2）在类声明的内部声明定义，叫做隐式内联函数。内联函数的执行机制：当内联函数在调用函数处用内联函数体的代码来替换。局限性：函数中的执行代码不宜过多。 1234567891011121314151617181920212223class TableClass&#123;private: int a,b;public: int add()//定义内联函数，不使用inline关键字 &#123; return a+b; &#125;; inline int dec()//定义内联函数，使用inline关键字 &#123; return a-b; &#125; int GetNum();&#125;inline int tableclass::GetNum()&#123; return a;&#125;//在上面的代码中，类内部的函数无论是否有inline关键词，都被默认为内联函数。而外部的函数使用inline关键字定义为了类的内联函数。 16. 静态函数 静态函数就是用static关键字修饰的函数，静态成员函数的声明除了在类体的函数生命前加上关键字static，以及不能声明为const之外，与非静态成员函数相同。**静态函数没有this指针 17. 模板函数123456template&lt;class T&gt;//定义模板标识T add(T a,T b)&#123; T result=a+b; return result;&#125; 以下代码演示了如何定义一个函数模板，并且如何在程序中调用该函数。 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;class T&gt;//声明模板的标识T add(T a,T b)//函数原型&#123; T result;//使用参数化的类型定义变量 result=a+b; return result;&#125;int main(int argc, char *argv[])&#123; cout&lt;&lt;\"2+3=\"&lt;&lt;Add(2,3)&lt;&lt;endl;//输出整型类型的“+”运算结果 //输出string类型的“+”运算结果 cout&lt;&lt;\"std+123=\"&lt;&lt;Add(string(\"std\"),string(\"123\"))&lt;&lt;endl; return 0;&#125;//运行结果：//2+3=5//sdf+123=sdf123 18. 类模板 类模板使用时与函数模板有点不一样，调用时需要明确指出使用何种数据类型，而不能由编译器自行指定，如下代码所示使用类模板定义一个变量：TemplateSample&lt;int&gt; demo;//指出针对该模板使用int类型类模板的模板参数定义除了class进行定义以外，还可以使用其他数据类型，但是至少需要有一个模板形参是使用class定义的，如下所示模板参数列表定义了3个参数：tempplate&lt;class T1,class T2,int num&gt; //定义多个模板参数，且其中一个直接使用int类型","categories":[{"name":"C++面试","slug":"C-面试","permalink":"yongchunxiaofen.top/categories/C-面试/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"编程语言","slug":"编程语言","permalink":"yongchunxiaofen.top/tags/编程语言/"},{"name":"面试","slug":"面试","permalink":"yongchunxiaofen.top/tags/面试/"}]},{"title":"C++面试题30道","slug":"cpp-in-interview-30","date":"2016-05-30T02:26:23.000Z","updated":"2016-07-05T01:36:52.000Z","comments":true,"path":"2016/05/30/cpp-in-interview-30/","link":"","permalink":"yongchunxiaofen.top/2016/05/30/cpp-in-interview-30/","excerpt":"转自：http://blog.csdn.net/shihui512/article/details/9092439 ，部分节有增删改。 1.new、delete、malloc、free关系 delete会调用对象的析构函数,和new对应。free只会释放内存，new调用构造函数。 malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。 对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。","text":"转自：http://blog.csdn.net/shihui512/article/details/9092439 ，部分节有增删改。 1.new、delete、malloc、free关系 delete会调用对象的析构函数,和new对应。free只会释放内存，new调用构造函数。 malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。 对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。 2.delete与 delete []区别 delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。在More Effective C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator delete来释放内存。”delete与new配套，delete []与new []配套 12345678MemTest *mTest1=new MemTest[10];MemTest *mTest2=new MemTest;Int *pInt1=new int[10];Int *pInt2=new int;delete[]pInt1; //-1-delete[]pInt2; //-2-delete[]mTest1;//-3-delete[]mTest2;//-4- 在-4-处报错。 这就说明：对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。delete[]删除一个数组，delete删除一个指针。简单来说，用new分配的内存用delete删除；用new[]分配的内存用delete[]删除。delete[]会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。 3.C++有哪些性质（面向对象特点）封装 继承 多态 4.子类析构时要调用父类的析构函数吗？ 析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了。定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。 5.多态，虚函数，纯虚函数对虚函数和纯虚函数的详细理解，参考Hackbuteer1的专栏 多态：是对于不同对象接收相同消息时产生不同的动作。 C++的多态性具体体现在运行和编译两个方面：在程序运行时的多态性通过继承和虚函数来体现；在程序编译时多态性体现在函数和运算符的重载上； 虚函数：在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。 定义一个函数为虚函数，不代表函数为不被实现的函数。 定义为虚函数，是为了允许基类的指针调用子类的这个函数 定义一个函数为纯虚函数，才代表函数没有被实现。如下例子： 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;class A&#123;public: virtual void foo() &#123; cout &lt;&lt; \"A::foo() is called\" &lt;&lt; endl; &#125;&#125;;class B :public A&#123; void foo() &#123; cout &lt;&lt; \"B::foo() is called\" &lt;&lt; endl; &#125;&#125;;int main()&#123; A *a = new B(); a-&gt;foo();//这儿虽然a是指向A的指针，但是由于虚函数的作用，其调用的仍然是子类的对应的该函数。 return 0;&#125; 纯虚函数的作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在 纯虚函数不具备函数的功能，一般不能直接被调用。 纯虚函数存在的目的，就是为了防止基类对象被实例化。 从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）。 抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。 6.求下面函数的返回值（微软）12345678910int func(x) &#123; int countx = 0; while(x) &#123; countx ++; x = x&amp;(x-1); &#125; return countx; &#125; 假定x = 9999。 答案：8思路：将x转化为2进制，看含有的1的个数。例题分析：第一次循环： 1234x = 0010 0111 0000 1111；x-1 = 0010 0111 0000 1110； x &amp; (x - 1) = 0010 0111 0000 1110；//第一次循环的结果是 x 末尾的1被消灭掉 第二次循环 12345x = 0010 0111 0000 1110;x - 1 = 0010 0111 0000 1101;x &amp; (x - 1) = 0010 0111 0000 1100;//第二次循环的结果是 x 中的1从右往左依次被消灭掉，直至二进制中所有的值都是0，从而x=0程序退出循环。//因此，循环的次数即给定数二进制中1的个数。 7.什么是“引用”？申明和使用“引用”要注意哪些问题？ 答：引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。 声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。 有如下例子1234int i = 5;int j = 6;int &amp;k = i;//k是i的引用k = j;//该句执行的结果是，将j的值赋给k，而不是使k作为j的引用。其执行完毕之后，k和其被引用的数i的值都变成6.相当于覆盖了之前对i的赋值。 C++中，函数的参数和返回值的传递方式有三种：指针传递，引用传递和值传递。 “引用传递”的性质象”指针传递”，而书写方式象”值传递”。 实际上”引用”可以做的任何事情”指针”也都能够做，为什么还要”引用”这东西？ 答案是”用适当的工具做恰如其分的工作”。 指针能够毫无约束地操作内存中的任何东西，尽管指针功能强大，但是非常危险。 如果的确只需要借用一下某个对象的”别名”，那么就用”引用”，而不要用”指针”，以免发生意外。 8.将“引用”作为函数参数有哪些特点？ （1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。 （2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。 （3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。 9.在什么时候需要使用“常引用”？ 如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式：const 类型标识符 &amp;引用名=目标变量名；例1 1234int a ;const int &amp;ra=a;ra=1; //错误a=1; //正确 例2 12345string foo( );void bar(string &amp; s);//那么下面的表达式将是非法的：bar(foo( ));bar(\"hello world\"); 原因在于foo( )和”hello world”串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。引用型参数应该在能被定义为const的情况下，尽量定义为const 。 10.将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?格式：类型标识符 &amp;函数名（形参列表及类型说明）{ //函数体 } 关于本节可以参考Let it Be 的博客 好处：在内存中不产生被返回值的副本，而是返回对象的引用，即对象本身，程序的执行效率更高；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error! ) 注意事项：（1）不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了”无所指”的引用，程序会进入未知状态。（2）不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。（3）可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。（4）流操作符重载返回值申明为“引用”的作用：流操作符&lt;&lt;和&gt;&gt;，这两个操作符常常希望被连续使用，例如：cout &lt;&lt; “hello” &lt;&lt; endl; 因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个&lt;&lt;操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用&lt;&lt;操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。 1234567891011121314151617＃include&lt;iostream&gt;int &amp;put(int n);int vals[10];int error=-1;void main()&#123;put(0)=10; //以put(0)函数值作为左值，等价于vals[0]=10; put(9)=20; //以put(9)函数值作为左值，等价于vals[9]=20; cout&lt;&lt;vals[0]; cout&lt;&lt;vals[9];&#125; int &amp;put(int n)&#123;if (n&gt;=0 &amp;&amp; n&lt;=9 ) return vals[n]; else &#123; cout&lt;&lt;\"subscript error\"; return error; &#125;&#125; （5）在另外的一些操作符中，却千万不能返回引用：+-*/ 四则运算符。它们不能返回引用，Effective C++[1]的Item23详细的讨论了这个问题。主要原因是这四个操作符没有side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个new分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第2、3两个方案都被否决了。静态对象的引用又因为((a+b) == (c+d))会永远为true而导致错误。所以可选的只剩下返回一个对象了。 11、结构与联合有和区别？(1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。(2). 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。 12、试写出程序结果：12345678910111213int a=4;int &amp;f(int x)&#123; a=a+x; return a;&#125;int main(void)&#123; int t=5; cout&lt;&lt;f(t)&lt;&lt;endl; // a = 9 f(t)=20; // a = 20 cout&lt;&lt;f(t)&lt;&lt;endl; // t = 5,a = 20 a = 25 t=f(t); // a = 30 t = 30 cout&lt;&lt;f(t)&lt;&lt;endl; //t = 60&#125; 13.重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？常考的题目。从定义上来说：重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。重写：是指子类重新定义父类虚函数的方法。从实现原理上来说：重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。 14.有哪几种情况只能用intialization list 而不能用assignment?答案：当类中含有const、reference 成员变量；基类的构造函数都需要初始化表。//因为const对象和reference只能初始化而不能赋值，所以只能使用成员初始化列表。//如果基类没有默认构造函数，则必须在初始化列表中显式地调用构造函数。 15. C++是不是类型安全的？答案：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。 16. main 函数执行以前，还会执行什么代码？答案：全局对象的构造函数会在main 函数之前执行。 17. 描述内存分配方式以及它们的区别?C++中，内存被分成五个部分：堆，栈，静态/全局 储存区，常量储存区和自由存储区1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。 以下部分转自曹浩洋的专栏. 栈：编译器在需要的时候分配，不需要的时候释放掉。比如局部变量、函数参数等。 堆：由new分配的内存块，由程序员根据需要申请和释放，一般一个new对应一个delete，当为数组时，为 new[]对应 delete[]. 自由储存区：由malloc分配的内存块，和堆十分相似，不过其以free结束。 静态储存区：全局变量和静态变量 常量存储区：特殊的内存块，存放常量，不允许修改。 经常，堆和栈往往难以区分开，举例说明 1234void fo()&#123; int *p = new int[5];&#125; 这条短短的一句话就包含了堆与栈，看到new，我们首先就应该想到，我们分配了一块堆内存，那么指针p呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中. 堆和栈的比较： 1、管理方式不同； 2、空间大小不同； 3、能否产生碎片不同； 4、生长方向不同； 5、分配方式不同； 6、分配效率不同； 空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。 碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因 为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。 生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。 分 配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较 高。 对了，还有一件事，如果有人把堆栈合起来说，那它的意思是栈，可不是堆 18.分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。答案： 12345BOOL : if ( !a ) or if(a)int : if ( a == 0)float : const EXPRESSION EXP = 0.000001if ( a &lt; EXP &amp;&amp; a &gt;-EXP)pointer : if ( a != NULL) or if(a == NULL) 19.请说出const与#define 相比，有何优点？详细参考@奮 鬥@的专栏。 123456#define PI 3.14159const float Pi 3.14159double i=Pi; //此时为Pi分配内存，以后不再分配！ double I=PI; //编译期间进行宏替换，分配内存 double j=Pi; //没有内存分配 double J=PI; //再进行宏替换，又一次分配内存！ const 与 #define的比较 C++ 语言可以用const来定义常量，也可以用 #define来定义常量。但是前者比后者有更多的优点：（1） const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。（2） 有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。 类中的常量有时我们希望某些常量只在类中有效。由于#define定义的宏常量是全局的，不能达到目的，于是想当然地觉得应该用const修饰数据成员来实现。const数据成员的确是存在的，但其含义却不是我们所期望的。const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的，因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。 不能在类声明中初始化const数据成员。以下用法是错误的，因为类的对象未被创建时，编译器不知道SIZE的值是什么。 123456789101112131415161718class A &#123;… const int SIZE = 100; // 错误，企图在类声明中初始化const数据成员 int array[SIZE]; // 错误，未知的SIZE &#125;;const数据成员的初始化只能在类构造函数的初始化表中进行，例如 class A &#123;… A(int size); // 构造函数 const int SIZE ; &#125;; A::A(int size) : SIZE(size) // 构造函数的初始化表 &#123; … &#125; A a(100); // 对象 a 的SIZE值为100 A b(200); // 对象 b 的SIZE值为200 答案：const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。 20.简述数组与指针的区别？数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。(1)修改内容上的差别char a[] = “hello”;a[0] = ‘X’;char *p = “world”; // 注意p 指向常量字符串p[0] = ‘X’; // 编译器不能发现该错误，运行时错误(2) 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。 注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。 1234char a[] = \"hello world\";char *p = a;cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节 计算数组和指针的内存容量 1234void Func(char a[100])&#123;cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是100 字节,数组作为函数的参数时，该数组自动退化为同类型的指针。&#125; 21. int (*s[10])(int) 表示的是什么？int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。 22.栈内存与文字常量区123456789101112char str1[] = \"abc\";char str2[] = \"abc\";const char str3[] = \"abc\";const char str4[] = \"abc\";const char *str5 = \"abc\";const char *str6 = \"abc\";char *str7 = \"abc\";char *str8 = \"abc\";cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl;//0 分别指向各自的栈内存cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl;//0 分别指向各自的栈内存cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl;//1指向文字常量区地址相同cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl;//1指向文字常量区地址相同 结果是：0 0 1 1 解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。 23.将程序跳转到指定内存地址要对绝对地址0x100000赋值，我们可以用(unsigned int*)0x100000 = 1234;那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？ 123456789 *((void (*)( ))0x100000 ) ( ); 首先要将0x100000强制转换成函数指针,即: (void (*)())0x100000 然后再调用它: *((void (*)())0x100000)(); 用typedef可以看得更直观些: typedef void(*)() voidFuncPtr; *((voidFuncPtr)0x100000)(); 24.int id[sizeof(unsigned long)];这个对吗？为什么？ 答案:正确 这个 sizeof是编译时运算符，编译时就确定了 ,可以看成和机器有关的常量。 25.引用与指针有什么区别？【参考答案】 引用必须被初始化，指针不必。 引用初始化以后不能被改变，指针可以改变所指的对象。 不存在指向空值的引用，但是存在指向空值的指针。 26.const 与 #define 的比较 ，const有什么优点? 【参考答案】（1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应） 。（2） 有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。 27.复杂声明123void * ( * (*fp1)(int))[10];float (*(* fp2)(int,int,int))(int);int (* ( * fp3)())[10](); 分别表示什么意思？【标准答案】1.void*(*(*fp1)(int))[10]; fp1是一个指针，指向一个函数，这个函数的参数为int型，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个void型指针。2.`float((*fp2)(int,int,int))(int);` fp2是一个指针，指向一个函数，这个函数的参数为3个int型，函数的返回值是一个指针，这个指针指向一个函数，这个函数的参数为int型，函数的返回值是float型。 3.int (*(*fp3)())[10](); fp3是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是int型。 28.内存的分配方式有几种?【参考答案】一、从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。二、在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。三、从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。 29.基类的析构函数不是虚函数，会带来什么问题？【参考答案】派生类的析构函数用不上，会造成资源的泄漏。 有如下例子： 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;class ClxBase&#123;public: ClxBase() &#123;&#125;; virtual ~ClxBase() &#123; cout &lt;&lt; \"Output from the destructor of class ClxBase!\" &lt;&lt; endl; &#125;; virtual void DoSomething() &#123; cout &lt;&lt; \"Do something in class ClxBase!\" &lt;&lt; endl; &#125;;&#125;;class ClxDerived : public ClxBase&#123;public: ClxDerived() &#123;&#125;; ~ClxDerived() &#123; cout &lt;&lt; \"Output from the destructor of class ClxDerived!\" &lt;&lt; endl; &#125;; void DoSomething() &#123; cout &lt;&lt; \"Do something in class ClxDerived!\" &lt;&lt; endl; &#125;;&#125;;int main()&#123; ClxBase *pTest = new ClxDerived; pTest-&gt;DoSomething(); delete pTest;&#125;//此时输出为：/*Do something in class ClxDerived!Output from the destructor of class ClxDerived!Output from the destructor of class ClxBase!*/ 从上输出结果来看，调用子类的析构函数时，先调用子类的析构函数销毁掉子类的数据，然后再调用父类的析构函数销毁父类的数据。 但是，如果-&gt;基类析构函数不为虚函数，去掉基类析构函数函数前的virtual关键字，如下 12345678910111213class ClxBase&#123;public: ClxBase() &#123;&#125;; ~ClxBase() &#123; cout &lt;&lt; \"Output from the destructor of class ClxBase!\" &lt;&lt; endl; &#125;; virtual void DoSomething() &#123; cout &lt;&lt; \"Do something in class ClxBase!\" &lt;&lt; endl; &#125;;&#125;;//此时，输出为：/*Do something in class ClxDerived!Output from the destructor of class ClxBase!*/ 以上输出结果说明：如果基类的析构函数不为虚函数时，派生的子类型的析构函数被调用时，调用完毕之后不会再调用父类的析构函数，即父类中的数据并未被销毁。 30.全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？【参考答案】生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在； 使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。 +++++++++++++++++++在内存中的存储位置不同：全局变量：存储在静态存储区。局部变量：存储在栈区。","categories":[{"name":"C++面试","slug":"C-面试","permalink":"yongchunxiaofen.top/categories/C-面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"yongchunxiaofen.top/tags/面试/"}]},{"title":"Essential C++ 课后习题","slug":"answer-of-essential-cpp","date":"2016-05-30T02:23:35.000Z","updated":"2016-06-30T02:46:52.000Z","comments":true,"path":"2016/05/30/answer-of-essential-cpp/","link":"","permalink":"yongchunxiaofen.top/2016/05/30/answer-of-essential-cpp/","excerpt":"##Exercise 1.6 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/**************************************************Name：Wang**Data:2016-3-24 21:06:34**Readme:从标准设备读取一串整数，并将读入的整数依次放到array及vector 然后遍历这两种容器，求取数值的总和。 将总和及平均值输出至标准输出设备。vertirion：vector************************************************/#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdlib.h&gt;using namespace std;#define SIZE 10int main()&#123; //int a[SIZE]; int test; int cnt = 1; std::vector&lt;int&gt; ivec; std::cout &lt;&lt; &amp;ivec &lt;&lt; endl; for (int i = 0; i &lt; SIZE; i++) &#123; std::cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; cnt &lt;&lt; &quot;个数:&quot;; std::cin &gt;&gt; test; ivec.push_back(test); ++cnt; &#125; int sum = 0; for (int i = 0; i &lt; SIZE; i++) &#123; int num = ivec[i]; std::cout &lt;&lt; num &lt;&lt; endl; sum += num; &#125; cout &lt;&lt; &quot;数列的和为&quot; &lt;&lt; sum &lt;&lt; endl; cout &lt;&lt; &quot;数列的平均值为&quot; &lt;&lt; sum / SIZE &lt;&lt; endl; system(&quot;pause&quot;);&#125;","text":"##Exercise 1.6 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/**************************************************Name：Wang**Data:2016-3-24 21:06:34**Readme:从标准设备读取一串整数，并将读入的整数依次放到array及vector 然后遍历这两种容器，求取数值的总和。 将总和及平均值输出至标准输出设备。vertirion：vector************************************************/#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdlib.h&gt;using namespace std;#define SIZE 10int main()&#123; //int a[SIZE]; int test; int cnt = 1; std::vector&lt;int&gt; ivec; std::cout &lt;&lt; &amp;ivec &lt;&lt; endl; for (int i = 0; i &lt; SIZE; i++) &#123; std::cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; cnt &lt;&lt; &quot;个数:&quot;; std::cin &gt;&gt; test; ivec.push_back(test); ++cnt; &#125; int sum = 0; for (int i = 0; i &lt; SIZE; i++) &#123; int num = ivec[i]; std::cout &lt;&lt; num &lt;&lt; endl; sum += num; &#125; cout &lt;&lt; &quot;数列的和为&quot; &lt;&lt; sum &lt;&lt; endl; cout &lt;&lt; &quot;数列的平均值为&quot; &lt;&lt; sum / SIZE &lt;&lt; endl; system(&quot;pause&quot;);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142/****************************************Author:Wangdata:2016-3-24 17:22:13Readme:从标准设备读取一串整数，并将读入的整数依次放到array及vector 然后遍历这两种容器，求取数值的总和。 将总和及平均值输出至标准输出设备。vertirion：array****************************************/#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdlib.h&gt;#include&lt;vector&gt;#define SIZE 10using namespace std;int main()&#123; int a[SIZE]; int test; int cnt = 1; for (int i = 0; i &lt; SIZE; i++) &#123; std::cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; cnt &lt;&lt; &quot;个数:&quot;; std::cin &gt;&gt; test; a[i] = test; ++cnt; &#125; int sum = 0; for (int i = 0; i &lt; SIZE; i++) &#123; sum += a[i]; &#125; cout &lt;&lt; &quot;数列的和为&quot; &lt;&lt; sum &lt;&lt; endl; cout &lt;&lt; &quot;数列的平均值为&quot; &lt;&lt; sum / SIZE &lt;&lt; endl;&#125; ##Exercise 1.7 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/**************************************************Name：Wang**Data:2016-3-24 22:14:04**Readme:输入string类型的数据，然后存盘。 写一个程序，打开该文本文件，将每个字都读取到vector&lt;string&gt;对象中。 遍历该vector，将内容显示到cout。 使用泛型算法sort()，对所有文字进行排序 #include&lt;algorithm&gt; sort(container.begin(),container.end());vertirion：vector************************************************/#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#define SIZE 5using namespace std;int main()&#123; std::ofstream outfile1(&quot;text.txt&quot;); std::string str1; std::cout &lt;&lt; &quot;Please enter a string:&quot; &lt;&lt; std::endl; for (int i = 0; i &lt; SIZE; i++) &#123; std::cin &gt;&gt; str1; outfile1 &lt;&lt; str1 &lt;&lt; std::endl; &#125; std::vector&lt;string&gt; str2; std::ifstream infile1(&quot;text.txt&quot;); /*for (int i = 0; i &lt; 2; i++) &#123;*/ string name; for (int i = 0; i &lt; SIZE; i++) &#123; infile1 &gt;&gt; name ; str2.push_back(name); //std::cout &lt;&lt; name &lt;&lt; endl; &#125; for (int i = 0; i &lt; SIZE; i++) &#123; std::cout &lt;&lt; str2[i] &lt;&lt; std::endl; &#125; sort(str2.begin(), str2.end()); std::cout &lt;&lt; &quot;sort排序之后：&quot; &lt;&lt; std::endl; ofstream outfile2(&quot;sort.txt&quot;); for (int i = 0; i &lt; SIZE; i++) &#123; outfile2 &lt;&lt; str2[i] &lt;&lt; std::endl; &#125; system(&quot;pause&quot;);&#125; ##2.2 调用函数 例题分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;fstream&gt;//#include&quot;27.h&quot;void swap(int &amp;a, int &amp;b)&#123; int temp = a; a = b; b = temp;&#125;void display(std::vector&lt;int&gt;ivec)&#123; for (int ix = 0; ix &lt; (ivec.size()); ++ix) &#123; std::cout &lt;&lt; ivec[ix] &lt;&lt; std::endl; &#125;&#125;void Bubble(std::vector&lt;int&gt;vec1)&#123; std::ofstream outfile(&quot;1.txt&quot;); for (int ix = 0; ix &lt; (vec1.size()-1 );ix++) for (int jx = ix + 1; jx &lt; vec1.size(); jx++) &#123; if (vec1[ix]&gt;vec1[jx]) &#123; outfile &lt;&lt; &quot;交换之前：about to call swap! &quot; &lt;&lt; &quot;ix=&quot; &lt;&lt; ix &lt;&lt; &quot; jx=&quot; &lt;&lt; jx &lt;&lt; &quot; swaping &quot; &lt;&lt; vec1[ix] &lt;&lt; &quot; with &quot; &lt;&lt; vec1[jx] &lt;&lt; &quot;\\n&quot;; swap(vec1[ix], vec1[jx]); outfile &lt;&lt; &quot;交换之后：about to call swap! &quot; &lt;&lt; &quot;ix=&quot; &lt;&lt; ix &lt;&lt; &quot; jx=&quot; &lt;&lt; jx &lt;&lt; &quot; swaping &quot; &lt;&lt; vec1[ix] &lt;&lt; &quot; with &quot; &lt;&lt; vec1[jx] &lt;&lt; &quot;\\n&quot;; &#125; &#125;&#125;int main()&#123; int a[8] = &#123; 8, 2, 56, 65, 54, 6, 2, 10 &#125;; std::vector&lt;int&gt;vec(a, a + 8);//为vector对象赋值。 std::cout &lt;&lt; &quot;vector before sort:\\n&quot;; display(vec); Bubble(vec); std::cout &lt;&lt; &quot;vector after sort:\\n&quot;; display(vec); system(&quot;pause&quot;);&#125; 代码分析：1.对array进行赋值初始化，然后将array赋值给vector数组。2.调用display函数，打印出排序之前的数列。3.调用排序函数（冒泡排序法实现）4.打印出排序之后的序列。 结果：排序前后数列的顺序并未发生改变。说明程序有错误。 123456789101112131415161718vector before sort:825665546210vector after sort:825665546210 错误分析：1.在Bubble函数中将函数中变化的数据输出至文件，查看其变化。在if语句中，打印出数列的序号以及对应的数据是否发生变化，如下 123456789101112131415161718192021222324252627282930交换之前：about to call swap! ix=0 jx=1 swaping 8 with 2交换之后：about to call swap! ix=0 jx=1 swaping 2 with 8交换之前：about to call swap! ix=1 jx=5 swaping 8 with 6交换之后：about to call swap! ix=1 jx=5 swaping 6 with 8交换之前：about to call swap! ix=1 jx=6 swaping 6 with 2交换之后：about to call swap! ix=1 jx=6 swaping 2 with 6交换之前：about to call swap! ix=2 jx=4 swaping 56 with 54交换之后：about to call swap! ix=2 jx=4 swaping 54 with 56交换之前：about to call swap! ix=2 jx=5 swaping 54 with 8交换之后：about to call swap! ix=2 jx=5 swaping 8 with 54交换之前：about to call swap! ix=2 jx=6 swaping 8 with 6交换之后：about to call swap! ix=2 jx=6 swaping 6 with 8交换之前：about to call swap! ix=3 jx=4 swaping 65 with 56交换之后：about to call swap! ix=3 jx=4 swaping 56 with 65交换之前：about to call swap! ix=3 jx=5 swaping 56 with 54交换之后：about to call swap! ix=3 jx=5 swaping 54 with 56交换之前：about to call swap! ix=3 jx=6 swaping 54 with 8交换之后：about to call swap! ix=3 jx=6 swaping 8 with 54交换之前：about to call swap! ix=4 jx=5 swaping 65 with 56交换之后：about to call swap! ix=4 jx=5 swaping 56 with 65交换之前：about to call swap! ix=4 jx=6 swaping 56 with 54交换之后：about to call swap! ix=4 jx=6 swaping 54 with 56交换之前：about to call swap! ix=4 jx=7 swaping 54 with 10交换之后：about to call swap! ix=4 jx=7 swaping 10 with 54交换之前：about to call swap! ix=5 jx=6 swaping 65 with 56交换之后：about to call swap! ix=5 jx=6 swaping 56 with 65交换之前：about to call swap! ix=5 jx=7 swaping 56 with 54交换之后：about to call swap! ix=5 jx=7 swaping 54 with 56交换之前：about to call swap! ix=6 jx=7 swaping 65 with 56交换之后：about to call swap! ix=6 jx=7 swaping 56 with 65 以上数据说明 1&gt;swap函数能够实现其功能，完成数据的交换。 2&gt;if的条件语句书写正确，无错误。所以，现在的问题是，被调用的Bubble函数中的值只在该副本上发生变化，并没有传递到调用函数中，因此，为了使Bubble()函数的参数和传入的实际对象产生关联，应该使用pass by reference的方式传递参数。 程序修正方法：在Bubble（）函数的参数列表中，将程序第22行参数(pass by value)修改成引用(pass by reference)的形式即可。 1void Bubble(std::vector&lt;int&gt; &amp;vec1) 修改以后，程序的结果为。 123456789101112131415161718vector before sort:825665546210vector after sort:226810545665 ##Exercise 2.3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/**************************************************Name：Wang**Data:2016-03-27 10:42:23**Readme:将2.2中的Pentagonal数列求值拆分为两个函数 其中之一为inline，用来检验元素个数是否合理。 如果的确合理，而且尚未被计算，便执行第二个函数，执行实际的求值工作。vertirion：vector，inline************************************************/#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;string&gt;#define MAX 100using namespace std;vector&lt;int&gt;ivec1;inline bool NumberIsOk(const int &amp;number)&#123; if (number &lt;= 0 || number &gt; MAX) &#123; std::cout &lt;&lt; &quot;Error Input.\\n&quot; &lt;&lt; endl; return false; &#125; return true;&#125;void pentagonal(const int &amp;number)&#123; if (!NumberIsOk(number)) &#123; return; &#125; for (int ix = 1; ix &lt;= number; ++ix) &#123; ivec1.push_back(ix*(3*ix-1)/2); &#125;&#125;void display_message(vector&lt;int&gt; &amp;ivec1,const string &amp;str1)//&#123; for (int ix = 0; ix &lt; ivec1.size(); ix++) &#123; std::cout &lt;&lt; ivec1[ix] &lt;&lt; endl; &#125; std::cout &lt;&lt; &quot;TypeName of vector is &quot;&lt;&lt;str1; std::cout &lt;&lt; std::endl;&#125;int main()&#123; //vector&lt;int&gt;vec; int number1; std::cout &lt;&lt; &quot;Please enter a int number:&quot;; std::cin &gt;&gt; number1; pentagonal(number1); display_message(ivec1,&quot;int&quot;); system(&quot;pause&quot;); return 0;&#125; ##Exercise 2.6以template形式完成函数的重载。 鉴于2.5中传入的参数有不同的类型，因此，可以定义template带有不同类型参数的模板。 123456789101112131415161718192021222324//对于传入两个数的参数类型//传入的两个参数类型相同//同为int，float，或者string类型template&lt;typename T1&gt;void max(T1 a,T1 b)&#123; statement;&#125;//对于传入数组和整数类型的模板template&lt;typename T2&gt;void max(T2 a[],T2 b)&#123; statement2;&#125;//传入单个参数template&lt;typename T3&gt;void max(T3 a)&#123; statement3;//&#125;//以下，如此。","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"Essential C++","slug":"Essential-C","permalink":"yongchunxiaofen.top/tags/Essential-C/"}]},{"title":"QT生成的exe发布方式——windeployqt","slug":"Qt-exe","date":"2016-05-30T02:20:18.000Z","updated":"2016-06-30T02:45:56.000Z","comments":true,"path":"2016/05/30/Qt-exe/","link":"","permalink":"yongchunxiaofen.top/2016/05/30/Qt-exe/","excerpt":"使用release方式编译生成*exe文件 新建一文件夹，将该exe文件放入该文件夹中。 从开始菜单打开命令行E:\\Qt\\Qt5.6.0\\5.6\\mingw49_32&gt; 输入命令 ：cd /d E:\\Qt Project\\1然后使用 windeployqt 工具命令： windeployqt DuoluDesktop.exe 新建的文件夹中就会有一系列exe运行所需的文件。","text":"使用release方式编译生成*exe文件 新建一文件夹，将该exe文件放入该文件夹中。 从开始菜单打开命令行E:\\Qt\\Qt5.6.0\\5.6\\mingw49_32&gt; 输入命令 ：cd /d E:\\Qt Project\\1然后使用 windeployqt 工具命令： windeployqt DuoluDesktop.exe 新建的文件夹中就会有一系列exe运行所需的文件。","categories":[{"name":"Qt","slug":"Qt","permalink":"yongchunxiaofen.top/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"yongchunxiaofen.top/tags/Qt/"},{"name":"windeployqt","slug":"windeployqt","permalink":"yongchunxiaofen.top/tags/windeployqt/"}]},{"title":"Qt-设置Qt应用程序图标","slug":"Qt-ico","date":"2016-05-30T02:18:17.000Z","updated":"2016-06-30T02:45:16.000Z","comments":true,"path":"2016/05/30/Qt-ico/","link":"","permalink":"yongchunxiaofen.top/2016/05/30/Qt-ico/","excerpt":"准备一个icon文件，放置到project文件夹下，例如：First_Qt.ico 新建一文件，后缀改为*rc文件，文件内容为：IDI_ICON1 ICON DISCARDABLE &quot;First_Qt.ico&quot; 在Qt工程的*pro文件中最后新添加一行：RC_FILE += First_Qt.rc 最后，在mainwindow.cpp文件中的构造函数中，添加一行代码setWindowIcon(QIcon(&quot;First_Qt.ico&quot;)); 保存，运行，即可。此时，程序运行时的图标就变成我们设置的图标了。","text":"准备一个icon文件，放置到project文件夹下，例如：First_Qt.ico 新建一文件，后缀改为*rc文件，文件内容为：IDI_ICON1 ICON DISCARDABLE &quot;First_Qt.ico&quot; 在Qt工程的*pro文件中最后新添加一行：RC_FILE += First_Qt.rc 最后，在mainwindow.cpp文件中的构造函数中，添加一行代码setWindowIcon(QIcon(&quot;First_Qt.ico&quot;)); 保存，运行，即可。此时，程序运行时的图标就变成我们设置的图标了。","categories":[{"name":"Qt","slug":"Qt","permalink":"yongchunxiaofen.top/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"yongchunxiaofen.top/tags/Qt/"}]},{"title":"Linggle常用命令","slug":"resource-of-linggle","date":"2016-05-30T02:13:53.000Z","updated":"2016-05-30T02:20:43.000Z","comments":true,"path":"2016/05/30/resource-of-linggle/","link":"","permalink":"yongchunxiaofen.top/2016/05/30/resource-of-linggle/","excerpt":"","text":"http://linggle.com/ 原文链接：http://www.jianshu.com/p/f0705d09094f 1.如何形容一个单字?让我们先从比较简单的需求开始。 在写英文信、英文文章、英文报告与论文时，一个单字前面不知道应该加什么形容词来形容?这时候只要输入「 adj. beach 」，那么就会出现一系列形容海滩的词汇用法。 而同样的我们可以从每个词汇后面看到他在网路上的使用频率，找出最好的用法。 2.如果想要描述一个动作，但是不知道动词后面应该接什么单字比较正确?或是单字前面应该用哪一个动词描述行动好?一样可以用「 Linggle 」解决。 例如输入「 cultivate n. 」可以找到培养与种植后面通常接什么物件?又例如输入「 v. relationships 」可以查询要如何描述建立关系的行动。Linggle 最棒的特色就是可以限定「词性」，只要输入不同词性的关键字，就可以快速查询一个动作或形容的句子应该怎么描述，例如动词、名词、形容词、副词、介词、代词、感叹词、连接词。3.如何分析一个完整的句子：有鉴于可以用词性做搜寻分析，所以「 Linggle 」在判断与建议完整的英文句子时更有帮助。 例如输入「v. an/a adj. role」，就能找到「play an important role(在….起重要作用)」这样的句子文法用法。4.帮助用户确定是否要加某一个词汇：在英文写作时也常常发现一个句子里不知道有没有必要加上一个介词的情况，如果想知道正确用法，可以像下面这样搜寻：「 go ?to home」，就能透过搜寻引擎分析出「 go home 」是比较多人使用的用法。5.替换同义字: Linggle也能帮我们分析可以替换的同义词汇，例如使用「~important」，就能查到跟重要相关的其他英文同义词。6.比较哪个说法好: Linggle 也能分析出哪个用语比较好，例如输入「 fried/cooked rice 」，加上「/」可以查询网路上大家比较常使用的用语。","categories":[{"name":"工具","slug":"工具","permalink":"yongchunxiaofen.top/categories/工具/"}],"tags":[{"name":"linggle","slug":"linggle","permalink":"yongchunxiaofen.top/tags/linggle/"}]},{"title":"C语言点滴","slug":"c-point","date":"2016-05-30T01:53:48.000Z","updated":"2016-06-30T02:44:58.000Z","comments":true,"path":"2016/05/30/c-point/","link":"","permalink":"yongchunxiaofen.top/2016/05/30/c-point/","excerpt":"拜读赵岩老师的《C语言点滴》，目的是为了查漏补缺，在重新温习C语言基础的基础上对一些之前并未关注或者遗忘的细节给予重新定位和重视。——ycwang.2015-12-16 2.5编程风格 不应该写一个很长的函数，一个函数只实现一个功能。 编程字体的选择：等宽字体为佳。 常见的等宽字体 Monaco Lucida Console Lucida Sans Typewriter Consolas Courier New 第3章 数据类型C语言中仅有四种数据类型，分别为整型、浮点型、指针型和聚合类型（包括数组和结构体），剩下的都是从这四种类型派生或组合而来的。——《C和指针》 接上，例如char就是一个短整型。","text":"拜读赵岩老师的《C语言点滴》，目的是为了查漏补缺，在重新温习C语言基础的基础上对一些之前并未关注或者遗忘的细节给予重新定位和重视。——ycwang.2015-12-16 2.5编程风格 不应该写一个很长的函数，一个函数只实现一个功能。 编程字体的选择：等宽字体为佳。 常见的等宽字体 Monaco Lucida Console Lucida Sans Typewriter Consolas Courier New 第3章 数据类型C语言中仅有四种数据类型，分别为整型、浮点型、指针型和聚合类型（包括数组和结构体），剩下的都是从这四种类型派生或组合而来的。——《C和指针》 接上，例如char就是一个短整型。 原码、反码和补码 原码：一种计算机中对数字的二进制表示方法，数码序列中最高位为符号位，符号位为0表示正数，符号位为1表示负数。 反码：如果机器数是正数，则该机器数的反码与原码一样；如果机器数是负数，则该机器数的反码为对它的原码（符号位除外）各位取反而得到。 补码：如果机器数是正数，则该机器数的补码与原码相同；如果机器数是负数，则该机器数的补码是对它的原码（符号位除外）各位取反，并在末尾加1. 码 型 正 数 负 数 原码 数字二进制表示(符号位为0) 最高位符号位为1 反码 同原码 除符号位，对原码各位按位取反 补码 同原码 除符号位，对原码各位按位取反后在末尾加1 用原码表示一个有符号数会带来问题： 正负相加不等于零。例如1+（-1）对应0001+1001=1010，按照原码表示等于-2. 有两个零存在。分别为0000和1000。因而，原码不适合表示有符号数。 为了保证正负相加等于零。采用了反码的形式表示。但是第二个问题还没结局。因此引入补码机制。 使用补码时，也符合正负相加等于零。故而，整型数在计算机中，使用补码表示。 3.2 整型数的溢出 C语言中int型所表示的“最大正整数”到底是多少呢？不同的平台不同的编译器会有不同的定义。为此，C语言在头文件 limits.h 中给出了相关的宏定义 表3.1 整型数的极限值宏定义 char int short long long long SCHAR_MAX INT_MAX SHRT_MAX LONG_MAX LLONG_MAX SCHAR_MIN INT_MIN SHRT_MIN LONG_MIN LLONG_MIN UCHAR_MAX UINT_MAX USHRT_MAX ULONG_MAX ULLONG_MAX CHAR_MIN CHAR_MAX 3.5 int和char的关系关于getchar()官方的定义是： int getchar() Question：明明getchar返回的是一个字符，为何用int来接收？Answer：因为getchar（）读到末尾的时候，会返回EOF，而在stdio.h中，EOF被定义为-1.例如有如下代码：12345char c;//危险while(c=getchar()!=EOF)&#123;............;&#125; 3.9 sizeof运算符sizeof是C中的一个关键字，不是函数，但是其行为却类似于一个函数，因为其返回一个类型为size_t的无符号的整型数。size_t其实就是一个无符号的整型数。因为任何一个类型的size都不应该是负数。对于无符号数的减法，必须要保证被减数大于减数。如下的例子就是无符号的溢出带来的，其打印出的结果是str2 is longer than str1.1234char str1[]='abcdefg';char str2[]='abc';if(strlen(str2)-strlen(str1)&gt;0) printf(\"str2 is longer than str1\") 这里正确的比较方法应该是：if(strlen(str2)&gt;strlen(str1)) sizeof的用处由于字节对其，C中struct的长度并不等于每个单个成员变量的数据类型的长度和。所以当我们使用二进制来读写文件的时候，通常用sizeof来计算变量所占内存的真是尺寸。例如：12345struct student&#123; int num; char name[100];&#125;stu1;fwrite((char*)stu1,sizeof(stu1),1,fp); 例，数组和指针在sizeof上的区别：123456789int a[]=&#123;0,1,2,3,4,5&#125;;char c[]=&#123;'a','b'&#125;;int *ip=a;char *cp=c;printf(\"sizeof(ip)=%d\\n\",sizeof(ip));printf(\"sizeof(cp)=%d\\n\",sizeof(cp));printf(\"sizeof(a)=%d\\n\",sizeof(a));printf(\"sizeof(c)=%d\\n\",sizeof(c));printf(\"sizeof(a)/sizeof(a[0])=%d\\n\",sizeof(a)/sizeof(a[0])); 输出结果为： sizeof(ip)=4sizeof(cp)=4sizeof(a)=24sizeof(c)=2sizeof(a)/sizeof(a[0])=6 对任何类型的指针求sizeof得到的结果均是一个相同的值。C中，指针只保存一个地址，所以任何类型的指针都占用相同的字节数。而对数组名sizeof的结果是整个数组所占的字节数。可以根据该技巧计算数组中元素的数量。sizeof(a)/sizeof(a[0]) ==============本章完=============== 第四章 表达式和运算符4.1 自增（减）运算法C有三大运算符 算术 关系与逻辑 位操作 另外还有一些特殊的运算符，用于完成一些特殊的操作： 赋值运算符 条件运算符 指针运算符 以下以自增运算符为例说明，自减运算符同理。 对于自增运算符，只有用在表达式中前缀和后缀的区别才能有所体现。为了说明前后椎的问题，可以将自增运算符分为两个步骤： 一个步骤是复制一份变量的拷贝用于周围的表达式。 另一个步骤是增加自身的值 前缀和后缀的区别就是： 前缀运算符首先增加变量的值，然后复制一份拷贝； 后缀则先复制一份拷贝，而后增加值。 单目运算符都是右结合的 4.2 左值和右值左值得定义：simple：能放到等号左边的就是左值。学术定义：在内存中有一个确定位置的叫左值。 4.4 数据类型转换 隐式转换 强制转换 隐式转换的步骤： 强制类型转换格式：（类型）表达式例如：（float）i 逻辑运算符中注意的问题：&amp;&amp;与||均为从左向右的顺序进行。在&amp;&amp;中，逻辑假与任何逻辑值&amp;&amp;都是假，所以&amp;&amp;右边的操作根本不执行，该行为称为逻辑运算符中的短路效应。同理，在||中也存在短路效应。例：12if(5&lt;3 &amp;&amp; i++);if(5&gt;3 || i++); 在上式两行代码中，&amp;&amp;和||右边的操作根本不！执！行！ 除了上述三个固定顺序的运算符（&amp;&amp;，||，？：）运算符外，其他的运算符号是没有计算顺序的，例如： 12int m;printf(&quot;%d%d&quot;,m,m=7) 谁能知道上边的这个代码竟然特么的会输出7 7，而不是我们希望看到的1 7。 模运算功能： 判断整除。通过a%b==0判断a是否能被b整除。 映射到某个范围。给定任何一个数a，都可以通过a%100+1来把a映射到[1,100]的区间。例如，想模拟出扑克牌的过程，即可以通过rand()%54+1来模拟。 得到后n位数。例如a%1000可以得到a的最后三位数。 分别得到每一位上的值。运用上述思想拓展可得。例如：123456int a=1234;while(a)&#123; printf(\"%d\\n\",a%10); a=a/10;&#125; 又如，打印出整数的二进制表达式：123456int a=1234;while(a)&#123; printf(\"%d\\n\",a%2); a=a/2;&#125; 4.7 位运算位运算的一个技巧： 生成一个每一位都为1的整型数，可以利用取反操作int a=~(0)。如果要生成从右边开始数，从第三位到第5位为1的一个整形数，可以通过以下步骤来完成： 首先对0按位取反，~0得到11111111. 将上述的结果左移两位，(~0)&lt;&lt;2， 可以得到11111100 再对上述结果按位取反，~((~0)&lt;&lt;2),得到00000011 对上述结果左移三位，(~((~0)&lt;&lt;2))&lt;&lt;3,得到00011000 位运算重点总结 无论是逻辑右移还是算术右移，都是对原来的结果除以2. 对于无符号数采用逻辑右移，对有符号数采用算术右移。 逻辑右移时，最高位移入0；算术右移时，最左面的符号位复制一份，插入到符号位的右面。 第五章 输入输出5.3 单个字符输入输出 能通过键盘输入的常见的空白字符有三个，分别是空格，由&#39;\\t&#39;表示的tab键和由&#39;\\n&#39;表示的Enter键。 int getchar()该函数顾名思义，即为从流中取出一个字符，默认从stdin中输入流中得到一个字符，也就是说从键盘输入中获得一个字符，与之相对于的输出函数是putchar()函数. 例如，有如下程序：123456789101112int ch;/*first*/ch=getchar();putchar('1');putchar(ch);putchar('\\n');/*second*/ch=getchar();putchar('2');putchar(ch);putchar('\\n'); 当输入ab+Enter,其中+Enter表示回车。此时屏幕上输出为： ab1a2b请按任意键继续… 当输入a+Enter时，其中+Enter表示回车。此时屏幕上输出为： a1a2..请按任意键继续… 注意第二次的输出，请按任意键继续上边有两行空格。此时，由于数字2的后边分别输入了两个回车。输入a+Enter时的Enter被getchar读入到ch中，然后被putchar()函数输出。 由以上可以得出：getchar()函数每次只读入任意一个字符，包括回车Enter等空白字符。 5.4 字符串输入输出gets()和puts() 利用gets()函数读入键盘输入的字符串时，空格和tab键都是字符串的一部分 gets函数读入字符串的时候，以回车或者EOF为字符串的终止符，它同时把回车从缓冲区读走。 scanf函数12345678910#include&lt;stdio.h&gt;int main()&#123; char str[5]; char c; short int i; int result; result=scanf(\"%c,%hd %5s\",&amp;c,&amp;i,str); return 0;&#125; 对于上述程序，如果输入a,133 abc，此时a被保存于c中，133保存于i中，abc保存于字符型数组str中。因为有三个变量被成功写入，因此scanf返回值为3. scanf函数会忽略stdin中的空白字符，即空格和tab都会被忽略掉。scanf函数的实参是变量的地址。 scanf函数处理字符，数字和字符串 scanf(&quot;%c&quot;,&amp;c)读取一个从键盘上输入的字符时，输入中的任何字符，包括空白字符，tab字符和Enter，都不会被忽略，都会被scanf函数成功写入。这一点与getchar()函数一样 但是，当用scanf输入一个整数时，会忽略所有的空格，回车和tab。 与gets()函数不同，scanf函数输入时会忽略字符串前边的空格，tab和回车。 许多输入有问题时因为缓冲区有上次输入的剩余字符或者错误的字符。提供一种清空缓存区的方法123456789int a;do&#123;printf(\"*\\n\");scanf(\"%d\",&amp;a);while((c=getchar())!='\\n' &amp;&amp; c!=EOF) ;if(111==i) break;&#125;while(1); 使用scanf函数的时候，判断其返回值是一个比较好的方法。 5.6.6 格式化输出printf函数与scanf的区别 printf函数可以使用%f输出double和float两种类型，而scanf必须使用%f输入float型，而用%lf输入double型。 scanf格式控制字符串中不能使用&#39;\\n&#39; printf格式化输出时，比较值得注意的是%后边的m.n格式，当作用于d整数，s字符串和f浮点数的时候不太一样。 当作用于浮点数和字符串的时候，m代表输出至少要占m位（至少得意思是如果输出大于m位则正常输出，如果小于m位则输出m位，其余用空格填充）。n作用于浮点数时，代表小数点后边输出几位。n用作字符串时，用于输出几个字符。 例如：12345float f1=123.456；float f2=12.34567;printf(\"%9.2f\\t%9.2f\\n\",f1,f2);printf(\"%9.2f\\t%9.2f\\n\",f2,f1); 5.6 输入规则全真七子 键盘输入被保存于缓冲中，知道输入回车，输入函数采取缓冲区读取。 getchar()每次读取任意一个字符，包括回车。 gets读入字符串时，空格和tab都是字符串的一部分。gets以回车和EOF为字符串的终止符，同时把回车从缓冲区读走。 scanf读入数字%d或字符串%s的时候，scanf忽略掉空格，tab，回车等空白字符。 如果缓存区不为空，scanf按照自己的格式提取。成功或失败！ 掌握利用while循环清空缓存的方法，但是不要用fflush(stdin) 尝试使用fgets和sscanf. 第七章7.1.3 宏替换两种形式： object-like定义：#define 例：#define PI 3.14159 function-like123定义：#define&lt;identifier&gt;(&lt;replacement list&gt;)\\ &lt;replacement token list&gt; 例：#define zhouchang(r) (2PI(r)) 7.2 main函数main函数的三种定义方式123int main()/*无传入参数*/int main(void)/*无传入参数*/int main(int argc,char *argv[])/*有传入参数,其中argc代表传入的参数个数，argv为一个指针数组，其中每一个指针都都指向了传入参数的具体值*/ 7.4 static和constconst char *p 和 char *const p的辨析《Effictive C++》条款21中提供了一种方法，画一条垂直线穿过指针声明中的星号*。如果const出现在直线的左边，表示指针指向的数据为常量如果const出现在右边，表示指针本身为常量，不能改变指针p的指向。 static两大特性：静态和隐藏static的用法static和全局变量一样，都被存储在内存区的静态存储区。static类型的变量，如果不予初始化，其初始值为0，而不像某些自动变量那样是一个随机数。static比较经典的一个用法就是统计函数被调用了多少次。static的第二个特性 信息隐藏：static变量只在定义它的范围内可见，在其他范围内不可见。如果static用来修饰函数，这个函数只在当前的.c文件中可见。这样我们就可以在不同的.c文件中定义同名函数，而不会引起冲突，只要其中一个函数被static修饰。 如果要定义一个能被其他.c文件使用的全局变量，可以在任一个.c文件中定义这个全局变量，定义的时候不能用static修饰。在其他.c文件中使用该变量时，需要加上关键字extern对其进行修饰，表示该变量已经在其他.c文件中被定义。 表7.1 static用法总结 变量类型 声明位置 储存位置 作用域 作用 static全局变量 语句块之外 静态存储区 整个文件 不允许其他文件访问 static局部变量 语句块中 静态储存区 整个语句块 值在程序执行时一直保持: extern单独讲解 extern可置于变量或者函数前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量或函数时，在其它模块中寻找其定义。另外，extern也可用来进行链接指定。 关于头文件包含当有多个.c文件同时使用同一个函数时，在每一个文件中申明函数显得累赘，因此此时可以将函数的声明放到一个头文件中，然后每一个使用该函数的.c文件用include包含进申明了该函数的头文件便可。这样写的好处，一是看着代码不累赘；二是当函数需要发生变化时不用每个c文件都做修改，只需要在包含函数的c文件中做修改即可。再三说明：头文件中只应该包含那些不申请内存的声明语句 一般来说，头文件中应该包含的内容有如下几类 1.避免重复包含的#ifndef…#endif语句2.宏定义3.struct，union和enum等类型的typedef类型的定义4.全局变量以及不申请内存的声明（变量前加extern，函数不给出具体定义）","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"编程语言","slug":"编程语言","permalink":"yongchunxiaofen.top/tags/编程语言/"}]},{"title":"使用Github+Hexo搭建博客","slug":"hexo-blog","date":"2016-05-27T09:08:43.000Z","updated":"2016-06-30T03:22:32.000Z","comments":true,"path":"2016/05/27/hexo-blog/","link":"","permalink":"yongchunxiaofen.top/2016/05/27/hexo-blog/","excerpt":"Step0 安装GitStep1 安装Node.js该步请自行谷歌，最好选择默认路径，省去配置路径的麻烦。 Step2 安装Hexo`npm install -g hexo` 升级hexo到最新版（可以忽略） `npm update hexo -g` 这一步时间比较长，听首歌静静等待安装。 初始化 hexo init &lt;folder&gt; 指定你的文件夹路径，便会在该文件夹内初始化。 npm会自动安装依赖环境 `npm install`","text":"Step0 安装GitStep1 安装Node.js该步请自行谷歌，最好选择默认路径，省去配置路径的麻烦。 Step2 安装Hexo`npm install -g hexo` 升级hexo到最新版（可以忽略） `npm update hexo -g` 这一步时间比较长，听首歌静静等待安装。 初始化 hexo init &lt;folder&gt; 指定你的文件夹路径，便会在该文件夹内初始化。 npm会自动安装依赖环境 `npm install` 执行完这一步，在你的hexo安装的路径下运行 `hexo s` 生成的静态博客便可在本地运行了。 运行debug可以本地调试。 `hexo s --debug` 改变主题更换主题以Next主题为例进行说明。 详细过程参考：Next `hexo new `","categories":[{"name":"Hexo博客搭建","slug":"Hexo博客搭建","permalink":"yongchunxiaofen.top/categories/Hexo博客搭建/"}],"tags":[{"name":"Github","slug":"Github","permalink":"yongchunxiaofen.top/tags/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"yongchunxiaofen.top/tags/Hexo/"},{"name":"Node.js","slug":"Node-js","permalink":"yongchunxiaofen.top/tags/Node-js/"}]},{"title":"Jekyll的中的代码高亮<转>","slug":"hightlight-of-jekyll","date":"2016-05-27T08:23:37.000Z","updated":"2016-06-30T02:51:49.000Z","comments":true,"path":"2016/05/27/hightlight-of-jekyll/","link":"","permalink":"yongchunxiaofen.top/2016/05/27/hightlight-of-jekyll/","excerpt":"代码高亮方式选择1.小片段直接使用“ ` ”符号包含起来，或者使用一个tab直接利用markdown来做高亮 2.Pygments渲染Jekyll通过Pygments可以直接处理代码高亮 在Github Pages的文档里，也提到了这个方式，但是总觉得这样有点不是很舒服，打破了markdown的格式","text":"代码高亮方式选择1.小片段直接使用“ ` ”符号包含起来，或者使用一个tab直接利用markdown来做高亮 2.Pygments渲染Jekyll通过Pygments可以直接处理代码高亮 在Github Pages的文档里，也提到了这个方式，但是总觉得这样有点不是很舒服，打破了markdown的格式 3.gist嵌入方式这个方式使用了一个插件，而且gist也得管理，增大了开销…… 4.js和css处理这个方式使用了google-code-prettify来渲染代码高亮，本身库并不是很大，使用方便，最后我也选择了这个 Prettify使用1.下载代码直接到google-code-prettify官网下载代码，然后将它们放到项目下 2.包含css和js官网提到了可以直接包含run_prettify.js的方式，这个会导入远程库，我选择了自己导入，如下 &lt;link rel=&quot;stylesheet&quot; href=&quot;/public/js/prettify/prettify.css&quot;&gt; &lt;script src=&quot;/public/js/prettify/prettify.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function(){ $(&quot;pre&quot;).addClass(&quot;prettyprint linenums&quot;); prettyPrint(); }); &lt;/script&gt; 这里导入了css和js后，就可以直接用markdown的tab的方式来导入代码段了 3.更换主题默认主题不是很好看，只要更换prettify.css即可更换样式，可以到这里下载自己喜欢的主题css即可","categories":[{"name":"Jekyll","slug":"Jekyll","permalink":"yongchunxiaofen.top/categories/Jekyll/"}],"tags":[{"name":"Jekyll","slug":"Jekyll","permalink":"yongchunxiaofen.top/tags/Jekyll/"}]},{"title":"Windows和Linux切换最终解决方案<转>","slug":"share-windows-and-linux","date":"2016-05-27T08:22:11.000Z","updated":"2016-06-30T02:51:17.000Z","comments":true,"path":"2016/05/27/share-windows-and-linux/","link":"","permalink":"yongchunxiaofen.top/2016/05/27/share-windows-and-linux/","excerpt":"尝试和选择一台机器使用Windows和Linux一般有以下几个方式： Windows和Linux真正的双系统，开机两个引导 Linux下虚拟Windows（一般是xp） Windows下虚拟Linux 除了以上几个，还有一些其他方法，都没啥映像，在此不讨论。 选择两个系统无非是因为工作原因，Linux下开发，Windows下娱乐或者Word等。出现这种矛盾实在是纠结，在尝试过上述三种方案以后，我选择了在Windows下虚拟一个Linux，原因如下： 使用Vmware虚拟实在是比Virtual Box好用（主要是功能） Windows下的软件体验真的不错，而且是越来越好。虽然Linux下有各种开源软件功能一点都不差，但是你无法逃避的现实就是，用户体验真的不够。 双系统经常切换非常麻烦 Windows系统问题，虚拟出来的真的不好用 Linux真正需要的，字符界面就够用，所以一般不需要占太大资源 根据这几点，结果就定了，那么Windows下虚拟Linux怎样做最好呢?","text":"尝试和选择一台机器使用Windows和Linux一般有以下几个方式： Windows和Linux真正的双系统，开机两个引导 Linux下虚拟Windows（一般是xp） Windows下虚拟Linux 除了以上几个，还有一些其他方法，都没啥映像，在此不讨论。 选择两个系统无非是因为工作原因，Linux下开发，Windows下娱乐或者Word等。出现这种矛盾实在是纠结，在尝试过上述三种方案以后，我选择了在Windows下虚拟一个Linux，原因如下： 使用Vmware虚拟实在是比Virtual Box好用（主要是功能） Windows下的软件体验真的不错，而且是越来越好。虽然Linux下有各种开源软件功能一点都不差，但是你无法逃避的现实就是，用户体验真的不够。 双系统经常切换非常麻烦 Windows系统问题，虚拟出来的真的不好用 Linux真正需要的，字符界面就够用，所以一般不需要占太大资源 根据这几点，结果就定了，那么Windows下虚拟Linux怎样做最好呢? 配置 安装vmware 安装过程不多说，提醒一点就是，记得在配置中设置，关闭vmware后不关闭运行的虚拟机，原因待会说。 安装ubuntu server 我选择了ubuntu server最小化安装，不安装x window，结果就是512内存和1cpu就顺畅运行，做各种开发木有问题 安装securecrt或者putty vmware下直接用字符界面很蛋疼，没有全屏，所以使用securecrt来连接linux，这就是为啥第一步关闭vmware后还留下虚拟机。这么做可以让资源尽可能充足应用。 给Linux共享文件 在字符界面下安装vmtools不是很容易，方法请参考我的另外一篇文章给Vmware下的Ubuntu Server共享文件。这么做主要是为了在Windows下些代码，在Linux上运行 总结我是个实用主义，怎么顺手怎么来，如果你希望使用Windows下的软件，又无法离开Linux开发（有自己的服务器除外），那么这样的方式挺好。","categories":[{"name":"Linux","slug":"Linux","permalink":"yongchunxiaofen.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"yongchunxiaofen.top/tags/Linux/"},{"name":"Windows","slug":"Windows","permalink":"yongchunxiaofen.top/tags/Windows/"}]},{"title":"jekyll安装过程中可能会遇到的一些错误及解决办法","slug":"some-error-install-jekyll","date":"2016-05-27T08:20:41.000Z","updated":"2016-06-30T02:51:05.000Z","comments":true,"path":"2016/05/27/some-error-install-jekyll/","link":"","permalink":"yongchunxiaofen.top/2016/05/27/some-error-install-jekyll/","excerpt":"错误1 Dependency Error: Yikes! It looks like you don’t have jekyll-paginate or one of its dependencies installed. In order to use Jekyll as currently configured, you’ll need to install this gem. The full error message from Ruby is: ‘cannot load such file – jekyll-paginate’ If you run into trouble, you can find helpful resources at Getting Help jekyll 3.1.2 | Error: jekyll-paginate 解决办法：安装jekyll时候直接运行gem install jekyll-paginate即可解决。","text":"错误1 Dependency Error: Yikes! It looks like you don’t have jekyll-paginate or one of its dependencies installed. In order to use Jekyll as currently configured, you’ll need to install this gem. The full error message from Ruby is: ‘cannot load such file – jekyll-paginate’ If you run into trouble, you can find helpful resources at Getting Help jekyll 3.1.2 | Error: jekyll-paginate 解决办法：安装jekyll时候直接运行gem install jekyll-paginate即可解决。 错误2Dependency Error: Yikes! It looks like you don&apos;t have redcarpet or one of its dependencies installed. In order to use Jekyll as currently configured, you&apos;ll n eed to install this gem. The full error message from Ruby is: &apos;cannot load such file -- redcarpet&apos; If you run into trouble, you can find helpful resources at ht tp://jekyllrb.com/help/! Conversion error: Jekyll::Converters::Markdown encountered an error while conv erting &apos;_posts/2014-12-28-first-blog.md&apos;: redcarpet ERROR: YOUR SITE COULD NOT BE BUILT: ------------------------------------ redcarpet 解决办法：_config.yml中的markdown改为kramdown","categories":[{"name":"Jekyll","slug":"Jekyll","permalink":"yongchunxiaofen.top/categories/Jekyll/"}],"tags":[{"name":"Jekyll","slug":"Jekyll","permalink":"yongchunxiaofen.top/tags/Jekyll/"},{"name":"Github","slug":"Github","permalink":"yongchunxiaofen.top/tags/Github/"}]},{"title":"Git基本指令","slug":"simple-use-of-git","date":"2016-05-27T08:18:08.000Z","updated":"2016-10-28T03:07:17.000Z","comments":true,"path":"2016/05/27/simple-use-of-git/","link":"","permalink":"yongchunxiaofen.top/2016/05/27/simple-use-of-git/","excerpt":"执行git init，git add以及git commit之后，需要如下做： …or create a new repository on the command line123456echo &quot;# simpleEditor&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://github.com/ycwang522/simpleEditor.gitgit push -u origin master …or push an existing repository from the command line12git remote add origin https://github.com/ycwang522/simpleEditor.gitgit push -u origin master Git使用教程 设置用户名：git config --global user.name &quot;Your Name Here&quot; 设置邮箱：git config --global user.email &quot;your email&quot; 在网页上新建repository，点击如下图所示的网址","text":"执行git init，git add以及git commit之后，需要如下做： …or create a new repository on the command line123456echo &quot;# simpleEditor&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://github.com/ycwang522/simpleEditor.gitgit push -u origin master …or push an existing repository from the command line12git remote add origin https://github.com/ycwang522/simpleEditor.gitgit push -u origin master Git使用教程 设置用户名：git config --global user.name &quot;Your Name Here&quot; 设置邮箱：git config --global user.email &quot;your email&quot; 在网页上新建repository，点击如下图所示的网址 克隆项目到本地：git clone https://github.com/gavincook/test.git 提交代码：通过git status可以查看相应的改动然后使用git add将改动加至缓存区 当有多项改动需要add时，输入 git add -A 即可全部添加至缓存区。 git commit -a -m &apos;freehao123.com&apos; 然后使用git commit -m &quot;备注信息&quot; 将改动提交到本地仓库最后将代码提交到远程服务器 至此，就完成了一次环境搭建和代码的提交。 从远程克隆项目：从ycwang522仓库克隆ycwang522.github.io项目到本地。 git clone git@github.com:ycwang522/ycwang522.github.io.git 创建一个gitcafe-pages的分支，并切换到该分支 git checkout -b gitcafe-pages 创建项目后快速初始化仓库mkdir ycwang522 cd ycwang522 git init echo &quot;# ycwang522&quot; &gt;&gt; README.md git add README.md git commit -m &quot;first commit&quot; git remote add origin git@git.coding.net:ycwang522/ycwang522.git git push -u origin master 创建版本库版本库，即仓库（repository），这个文件夹目录中的所有文件夹都可以被Git管理起来，其中的每个文件可以修改、删除、Git都能追踪。 选择文件夹，创建一个空目录 $mkdir learngit //新建名为learngit的仓库 $cd learngit //进入该仓库 $pwd //查看该仓库在本地的路径 pwd命令用于显示当前目录 新建一文件，比如说readme.md 用命令git add将文件添加到仓库 $git add readme.md 用命令git commit告诉git，将文件提交到仓库。 $git commit -m &quot;add a readme file&quot; &amp;git add 添加多个文件时，可以写成”git add *”或者”git add -A” 版本管理及文件控制 查看当前仓库的状态：$git status 查看被修改的文件： $git diff readme.md 版本回退 显示提交日志：git log 版本回退： git reset 工作区和暂存区 git add 命令实际上就是要提交所有的修改到暂存区，然后git commit就可以一次性把暂存区的修改提交到分支。 一旦提交后，如果对工作区未做修改，那么工作区就是干净的。 丢弃工作区的修改：git checkout –file 删除文件 直接在文件管理器中把没用的文件删掉：rm test.md 从版本库中删除该文件：git rm test.md，然后git commit 如果删错了，但是版本库里还有，所以可以将误删掉的文件恢复到最新版本： git checkout -test.txt 远程仓库 创建SSH密钥。 ssh-keygen -t rsa -C “youremail@example.com” 在.ssh文件夹中可以找到id_rsa和id_rsa.pub两个密钥。 登陆Github，打开SSH key配置页面，将id_rsa.pub中的内容粘贴进去即可。 Github允许多个SSH。 版本增加及提交 本地仓库添加到远程仓库中：git remote add origin git@github.com:ycwang522/ycwang522.git 将本地库的所有内容推送到远程仓库上：git push -u origin master 将本地的内容推送到远程，用git push命令，实际上是将当前分支master推送到远程。由于远程是空的，第一次推送master分支时，加上了-u参数，Git不但会将本地的master分支内容推送到远程的master分支，还会将两个master分支关联起来，在以后的推送或者拉取时就可以简化命令。 然后，在本地提交：git push origin master 将本地的master分支的最新修改推送至github。 分支管理创建与合并分支查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt;","categories":[{"name":"Git","slug":"Git","permalink":"yongchunxiaofen.top/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"yongchunxiaofen.top/tags/Git/"}]},{"title":"MarkdownPad 2 在win10下出错：HTML 渲染错误(This view has crashed) 的解决办法 + MarkdownPad2.5 注册码","slug":"an-issue-in-markdownPad","date":"2016-05-27T08:16:35.000Z","updated":"2016-06-30T02:51:39.000Z","comments":true,"path":"2016/05/27/an-issue-in-markdownPad/","link":"","permalink":"yongchunxiaofen.top/2016/05/27/an-issue-in-markdownPad/","excerpt":"","text":"在win10上安装MarkdownPad2 时，出现如下的错误信息：HTML渲染组出错，这个问题可以通过安装某个缺失组件来解决，是否想要了解详细信息？ MarkdownPad 的FAQ文档中给出了解决办法：http://markdownpad.com/faq.html#livepreview-directx LivePreview is not working - it displays an error message stating This view has crashed! 官方给出的解释是：这个问题一般多见于win8（*当然现在win10也有，官方文档该更新啦）。错误的表现形式即：不能实时预览Markdown生成的HTML页面。 This issue has been specifically observed in Windows 8. You may see an error message as shown here, and no HTML will be rendered when you type in the Markdown Editor pane. 为了修复这个问题，你需要安装这么一个SDK工具包，点击链接获取。 To fix this issue, please try installing the Awesomium 1.6.6 SDK. 如果还没有解决，那就买个新电脑吧！ 哦！不是，让你再装个微软的渲染插件 If you continue to experience issues, please install Microsoft’s DirectX End-User Runtimes (June 2010). 彩蛋：MarkdownPad2.5 注册码邮箱：Soar360@live.com 授权密钥： GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==","categories":[{"name":"Markdown","slug":"Markdown","permalink":"yongchunxiaofen.top/categories/Markdown/"}],"tags":[{"name":"MarkdownPad","slug":"MarkdownPad","permalink":"yongchunxiaofen.top/tags/MarkdownPad/"}]},{"title":"Effective C++ 读书笔记","slug":"effective-cpp","date":"2016-05-27T08:13:10.000Z","updated":"2016-06-30T02:43:20.000Z","comments":true,"path":"2016/05/27/effective-cpp/","link":"","permalink":"yongchunxiaofen.top/2016/05/27/effective-cpp/","excerpt":"1 尽可能使用const 如果const出现在星号左边，比如 `const int *p`，则说明被指向的对象是常量， 即p指向的数据是常量，不允许赋值等运算；但是如果const出现在星号右边， 比如`int *const p`，说明指针是是常量。如果出现在两边，说明两者都是常量。 注：如果被指物是常量，有些程序员会将const写在类型前面，而有些人会将其写在类型后边，星号前边。均可。","text":"1 尽可能使用const 如果const出现在星号左边，比如 `const int *p`，则说明被指向的对象是常量， 即p指向的数据是常量，不允许赋值等运算；但是如果const出现在星号右边， 比如`int *const p`，说明指针是是常量。如果出现在两边，说明两者都是常量。 注：如果被指物是常量，有些程序员会将const写在类型前面，而有些人会将其写在类型后边，星号前边。均可。 STL迭代器的作用：类似于T *指针。 声明迭代器为const就像声明指针为const一样， 表明这个迭代器不得指向别的东西，但是其所指向的值是可以改变的。 如果希望指向的值不发生改变，则需要的是const_iterator. const最具威力的用法是： 面对函数声明时，在一个函数声明式内，其可以和函数返回类型，各参数，函数自身产生关联。 const修饰类的成员函数： 在类中，类的成员函数后边加const，表示这个成员函数不会对类对象的数组成员做任何修改。 在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加 const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更加明确的限定：有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。 2 static静态变量的用法 static变量只能初始化一次： 1234567891011121314151617181920212223&lt;?cpp#include&lt;stdio.h&gt;void fun(int i)&#123; static int value = i++; printf(\"%d\\n\", value);&#125;int main()&#123; fun(5); fun(1); fun(2); return 0;&#125;//执行该程序之后输出为0,0,0.//因为value是静态变量，只会定义一次，不管fun函数被调用多少次，以后调用该函数时，`static int value=i++`不再执行。?&gt; 如下的例子： 12345678910111213141516171819202122&lt;?cpp#include&lt;stdio.h&gt;void fun(int i)&#123; static int value = i++; value = i++; printf(\"%d\\n\", value);&#125;int main()&#123; fun(5); fun(1); fun(2); return 0;&#125;//输出为：6,1,2.?&gt; 3 引用 转载自：Mr.xu的博客 3.1 引用简介 引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。 引用的声明方法：类型标识符 &amp;引用名=目标变量名； 【例1】：int a; int &amp;ra=a; //定义引用ra,它是变量a的引用，即别名 说明： &amp;在此不是求地址运算，而是起标识作用。 类型标识符是指目标变量的类型。 声明引用时，必须同时对其进行初始化。 引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。 ra=1; 等价于 a=1; 声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。故：对引用求地址，就是对目标变量求地址。&amp;ra与&amp;a相等。 不能建立数组的引用。因为数组是一个由若干个元素所组成的集合，所以无法建立一个数组的别名。 3.2 引用的应用1&gt; 引用作为参数 引用的一个重要作用就是作为函数的参数。以前的C语言中函数参数传递是值传递，如果有大块数据作为参数传递的时候，采用的方案往往是指针，因为 这样可以避免将整块数据全部压栈，可以提高程序的效率。但是现在（C++中）又增加了一种同样有效率的选择（在某些特殊情况下又是必须的选择），就是引用。 【例2】： 1234567void swap(int &amp;p1, int &amp;p2) //此处函数的形参p1, p2都是引用&#123; int p; p=p1; p1=p2; p2=p; &#125; 为在程序中调用该函数，则相应的主调函数的调用点处，直接以变量作为实参进行调用即可，而不需要实参变量有任何的特殊要求。如：对应上面定义的swap函数，相应的主调函数可写为： 1234567891011&lt;?cppmain( )&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; //输入a,b两变量的值 swap(a,b); //直接以变量a和b作为实参调用swap函数 cout&lt;&lt;a&lt;&lt; ' ' &lt;&lt;b; //输出结果&#125;?&gt; 上述程序运行时，如果输入数据10 20并回车后，则输出结果为20 10。 由【例2】可看出： 传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。 使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给 形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。 使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”指针变量名”的 形式进行运算，这很容易产生错误且程序的阅读性较差；*另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。 如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。 3.3 常引用 常引用的格式为：const 变量标识符 &amp; 引用名=目标变量名 用这种方式声明的引用，不能通过引用对目标变量的值进行修改,从而使引用的目标成为const，达到了引用的安全性。 【例3】：有如下代码 1234int a ;const int &amp;ra=a;//const引用，不能通过引用对目标的值进行修改ra=1; //错误a=1; //正确 这不光是让代码更健壮，也有些其它方面的需要。 【例4】：假设有如下函数声明： 1234567string foo( );void bar(string &amp; s);//那么下面的表达式将是非法的：bar(foo( ));bar(&quot;hello world&quot;); 原因在于foo( )和&quot;hello world&quot;串都会产生一个临时对象， 而在C++中，这些临时对象都是const类型的。因此上面的表达式就是试图 将一个const类型的对象转换为非const类型，这是非法的。 引用型参数应该在能被定义为const的情况下，尽量定义为const 。 3.4 引用作为返回值要以引用返回函数值，则函数定义时要按以下格式： 类型标识符 &amp;函数名（形参列表及类型说明） { 函数体； } 说明： （1）以引用返回函数值，定义函数时需要在函数名前加&amp;。 （2）用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。 例[5]，有如下代码: 1234567891011121314151617181920212223242526272829303132&lt;?cpp#include&lt;iostream&gt;float temp;//定义全局变量float fn1(float r);//fn2函数声明 以返回函数值得方式返回函数值float fn2(float r);//fn2函数声明float fn1(float r) //fn1函数，以返回函数值的方式返回函数值&#123; temp=(float)(r*r*3.14); return temp;&#125;float fn2(float r)&#123; temp=(float)(r*r*3.14); return temp;&#125;void main()&#123; float a=fn1(10.0);//第1种情况，系统生成要返回值的副本（即临时变量） float &amp;b=fn1(10.0);//第2种情况，可能会出错（不同 C++系统有不同规定） //不能从被调函数中返回一个临时变量或局部变量的引用 float c=fn2(10.0); //第3种情况，系统不生成返回值的副本 //可以从被调函数中返回一个全局变量的引用 float &amp;d=fn2(10.0);//第4种情况，系统不生成返回值的副本 //可以从被调函数中返回一个全局变量的引用 std::cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;c&lt;&lt;\" \"&lt;&lt;d&lt;&lt;std::endl;&#125;?&gt; 3.5 枚举变量值的计算12345678#include&lt;stdio.h&gt;int main()&#123; enum(a,b=5,c,d=4,e); printf(&quot;%d %d %d %d %d&quot;,a,b,c,d,e); return 0;&#125;//程序执行之后，输出：0,5,6,4,5. 分析：在枚举中，某个枚举变量的值默认为前一个的值加1， 如果第一个枚举变量没有被赋值，则默认为0.","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"}]},{"title":"使用jekyll+Github搭建个人独立博客","slug":"make-blog-jekyll","date":"2016-05-27T08:06:02.000Z","updated":"2016-06-30T03:22:25.000Z","comments":true,"path":"2016/05/27/make-blog-jekyll/","link":"","permalink":"yongchunxiaofen.top/2016/05/27/make-blog-jekyll/","excerpt":"step 1.选择GitHub作为博客服务器*更详细的方法参考GitHub Pages官方文档 注册GitHub登陆https://github.com，创建属于自己的GitHub帐号（废话）。 建立一个仓库","text":"step 1.选择GitHub作为博客服务器*更详细的方法参考GitHub Pages官方文档 注册GitHub登陆https://github.com，创建属于自己的GitHub帐号（废话）。 建立一个仓库 Repository name(仓库名)必须是 your_user_name.github.io 比如我的用户名是admin，那么仓库的名称就必须是admin.github.io ，这点灰常重要。 另外新建仓库时选择Initialize this repository with a README和.gitignore和Licenses，如下图所示 一种简单的方式是，下载GitHub的桌面客户端，安装完成后，粘贴http://github.com/your_user_name/your_user_name.github.io.git 克隆到本地。 &lt;转自“授人以渔”的教你搭建个人独立博客&gt; 在新建的仓库中新建一个index.html文件或者本地新建采取上传的方式添加到新建的仓库 index.html中应包含如下代码： 1234567891011&lt;?&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;p&gt;I'm hosted with GitHub Pages.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;?&gt; 上传完毕之后仓库中应至少包含如下4个文件：gitignore,LICENSE，README.md和index.html 至此，your_name.github.io就可以飞起来了。 step 2.搭建本地运行环境jekyll以下以windows用户为例进行说明。 安装Ruby，移步Ruby下载页中国镜像站。选择高稳定版本即可。安装时勾选如下对话框。 安装rubygems，解压后运行setup.rb文件。 安装jekyll： cmd运行gem install jekyll 运行jekyll 进入你的blog文件夹：cd your-site-name 运行本地服务： jekyll s 在浏览器中运行http://127.0.0.1:4000/ 即可在本地运行调试。 step 3.发表文章文章开头，加上如下所示的代码： --- layout: post title: Welcome to Jekyll! date: 2014-01-27 categorie: Blog tags:jekyll --- 另外，文件的名称也移动得加上时间标题。 比如该文件的标题可以设置为： 2016-05-25-build-blog.md 然后将文章放入 _post文件夹下即可。 step 4.定制域名 购买域名：万网，Godaddy都可以。万网比较便宜。 在github文件夹内新建一个CNAME文件，写入你的域名，不加https://. 域名解析，可以选择Dnspod或者万网的域名解析。 以万网域名解析为例：进入管理控制台&gt;云解析&gt;域名后边有解析&gt;进入解析 接着 cmd ，输入 ping your_name.github.io 得到一个ip地址。 然后在上图域名解析中，点击添加解析 在主机记录一栏填写”www”，记录值一栏填写刚才刚才ping到的ip地址。 在添加一个解析，同上，主机记录一栏填写”@”，记录值一栏填写刚才ping到的ip地址。 这样，当你输入 your_name.github.io 的时候会被解析到你设定的网址。 至此，博客基本搭成。","categories":[{"name":"Jekyll博客搭建","slug":"Jekyll博客搭建","permalink":"yongchunxiaofen.top/categories/Jekyll博客搭建/"}],"tags":[{"name":"Jekyll","slug":"Jekyll","permalink":"yongchunxiaofen.top/tags/Jekyll/"},{"name":"Github","slug":"Github","permalink":"yongchunxiaofen.top/tags/Github/"}]},{"title":"七种常见经典排序算法总结（C++实现）","slug":"sort-algorithms","date":"2016-05-27T08:03:41.000Z","updated":"2016-06-30T02:44:01.000Z","comments":true,"path":"2016/05/27/sort-algorithms/","link":"","permalink":"yongchunxiaofen.top/2016/05/27/sort-algorithms/","excerpt":"排序算法是非常常见也非常基础的算法，以至于大部分情况下它们都被集成到了语言的辅助库中。排序算法虽然已经可以很方便的使用，但是理解排序算法可以帮助我们找到解题的方向。 1. 冒泡排序 (Bubble Sort)冒泡排序是最简单粗暴的排序方法之一。它的原理很简单，每次从左到右两两比较，把大的交换到后面，每次可以确保将前M个元素的最大值移动到最右边。 步骤 从左开始比较相邻的两个元素x和y，如果 x &gt; y 就交换两者 执行比较和交换，直到到达数组的最后一个元素 重复执行1和2，直到执行n次，也就是n个最大元素都排到了最后","text":"排序算法是非常常见也非常基础的算法，以至于大部分情况下它们都被集成到了语言的辅助库中。排序算法虽然已经可以很方便的使用，但是理解排序算法可以帮助我们找到解题的方向。 1. 冒泡排序 (Bubble Sort)冒泡排序是最简单粗暴的排序方法之一。它的原理很简单，每次从左到右两两比较，把大的交换到后面，每次可以确保将前M个元素的最大值移动到最右边。 步骤 从左开始比较相邻的两个元素x和y，如果 x &gt; y 就交换两者 执行比较和交换，直到到达数组的最后一个元素 重复执行1和2，直到执行n次，也就是n个最大元素都排到了最后 123456789101112void bubble_sort(vector&lt;int&gt; &amp;nums)&#123; for (int i = 0; i &lt; nums.size() - 1; i++) &#123; // times for (int j = 0; j &lt; nums.size() - i - 1; j++) &#123; // position if (nums[j] &gt; nums[j + 1]) &#123; int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; &#125; &#125; &#125;&#125; 交换的那一步可以不借助temp，方法是 123nums[j] += nums[j + 1];nums[j + 1] = num[j] - nums[j + 1];nums[j] -= num[j + 1]; 复杂度分析 由于我们要重复执行n次冒泡，每次冒泡要执行n次比较（实际是1到n的等差数列，也就是(a1 + an) * n / 2），也就是 O(n^2)。 空间复杂度是O(n)。 2. 插入排序（Insertion Sort）插入排序的原理是从左到右，把选出的一个数和前面的数进行比较，找到最适合它的位置放入，使前面部分有序。 步骤 从左开始，选出当前位置的数x，和它之前的数y比较，如果x &lt; y则交换两者 对x之前的数都执行1步骤，直到前面的数字都有序 选择有序部分后一个数字，插入到前面有序部分，直到没有数字可选择 123456789101112void insert_sort(vector&lt;int&gt; &amp;nums)&#123; for (int i = 1; i &lt; nums.size(); i++) &#123; // position for (int j = i; j &gt; 0; j--) &#123; if (nums[j] &lt; nums[j - 1]) &#123; int temp = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = temp; &#125; &#125; &#125;&#125; 复杂度分析 因为要选择n次，而且插入时最坏要比较n次，所以时间复杂度同样是O(n^2)。空间复杂度是O(n)。 3. 选择排序（Selection Sort）选择排序的原理是，每次都从乱序数组中找到最大（最小）值，放到当前乱序数组头部，最终使数组有序。 步骤 从左开始，选择后面元素中最小值，和最左元素交换 从当前已交换位置往后执行，直到最后一个元素 123456789101112131415void selection_sort(vector&lt;int&gt; &amp;nums)&#123; for (int i = 0; i &lt; nums.size(); i++) &#123; // position int min = i; for (int j = i + 1; j &lt; nums.size(); j++) &#123; if (nums[j] &lt; nums[min]) &#123; min = j; &#125; &#125; int temp = nums[i]; nums[i] = nums[min]; nums[min] = temp; &#125;&#125; 复杂度分析 每次要找一遍最小值，最坏情况下找n次，这样的过程要执行n次，所以时间复杂度还是O(n^2)。空间复杂度是O(n)。 4. 希尔排序（Shell Sort）希尔排序从名字上看不出来特点，因为它是以发明者命名的。它的另一个名字是“递减增量排序算法“。这个算法可以看作是插入排序的优化版，因为插入排序需要一位一位比较，然后放置到正确位置。为了提升比较的跨度，希尔排序将数组按照一定步长分成几个子数组进行排序，通过逐渐减短步长来完成最终排序。 例子 例如 [10, 80, 70, 100, 90, 30, 20]如果我们按照一次减一半的步长来算， 这个数组第一次排序时以3为步长，子数组是： 10 80 7090 30 20100 这里其实按照列划分的4个子数组，排序后结果为 10 30 2090 80 70100 也就是 [10, 30 20 90 80 70 100] 然后再以1为步长生成子数组 103020.. 这个时候就是一纵列了，也就是说最后一定是以一个数组来排序的。 步骤 计算当前步长，按步长划分子数组 子数组内插入排序 步长除以2后继续12两步，直到步长最后变成1 123456789101112131415void shell_sort(vector&lt;int&gt; &amp;nums)&#123; for (int gap = nums.size() &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;= 1) &#123; // times for (int i = gap; i &lt; nums.size(); i++) &#123; // position int temp = nums[i]; int j = i - gap; for (; j &gt;= 0 &amp;&amp; nums[j] &gt; temp; j -= gap) &#123; nums[j + gap] = nums[j]; &#125; nums[j + gap] = temp; &#125; &#125;&#125; 复杂度分析 希尔排序的时间复杂度受步长的影响，具体分析在维基百科。 5. 归并排序（Merge Sort）归并排序是采用分治法（Divide and Conquer）的一个典型例子。这个排序的特点是把一个数组打散成小数组，然后再把小数组拼凑再排序，直到最终数组有序。 步骤 把当前数组分化成n个单位为1的子数组，然后两两比较合并成单位为2的n/2个子数组 继续进行这个过程，按照2的倍数进行子数组的比较合并，直到最终数组有序 12345678910111213141516171819202122232425262728void merge_array(vector&lt;int&gt; &amp;nums, int b, int m, int e, vector&lt;int&gt; &amp;temp)&#123; int lb = b, rb = m, tb = b; while (lb != m &amp;&amp; rb != e) if (nums[lb] &lt; nums[rb]) temp[tb++] = nums[lb++]; else temp[tb++] = nums[rb++]; while (lb &lt; m) temp[tb++] = nums[lb++]; while (rb &lt; e) temp[tb++] = nums[rb++]; for (int i = b;i &lt; e; i++) nums[i] = temp[i];&#125;void merge_sort(vector&lt;int&gt; &amp;nums, int b, int e, vector&lt;int&gt; &amp;temp)&#123; int m = (b + e) / 2; if (m != b) &#123; merge_sort(nums, b, m, temp); merge_sort(nums, m, e, temp); merge_array(nums, b, m, e, temp); &#125;&#125; 这个实现中加了一个temp，是和原数组一样大的一个空间，用来临时存放排序后的子数组的。 复杂度分析 在merge_array过程中，实际的操作是当前两个子数组的长度，即2m。又因为打散数组是二分的，最终循环执行数是logn。所以这个算法最终时间复杂度是O(nlogn)，空间复杂度是O(n)。 6. 快速排序（Quick Sort）快速排序也是利用分治法实现的一个排序算法。快速排序和归并排序不同，它不是一半一半的分子数组，而是选择一个基准数，把比这个数小的挪到左边，把比这个数大的移到右边。然后不断对左右两部分也执行相同步骤，直到整个数组有序。 步骤 用一个基准数将数组分成两个子数组 将大于基准数的移到右边，小于的移到左边 递归的对子数组重复执行1，2，直到整个数组有序 1234567891011121314151617181920212223void quick_sort(vector&lt;int&gt; &amp;nums, int b, int e, vector&lt;int&gt; &amp;temp)&#123; int m = (b + e) / 2; if (m != b) &#123; int lb = b, rb = e - 1; for (int i = b; i &lt; e; i++) &#123; if (i == m) continue; if (nums[i] &lt; nums[m]) temp[lb++] = nums[i]; else temp[rb--] = nums[i]; &#125; temp[lb] = nums[m]; for (int i = b; i &lt; e; i++) nums[i] = temp[i]; quick_sort(nums, b, lb, temp); quick_sort(nums, lb + 1, e, temp); &#125;&#125; 解法2: 不需要辅助空间 12345678910111213141516void quick_sort(vector&lt;int&gt; &amp;nums, int b, int e)&#123; if (b &lt; e - 1) &#123; int lb = b, rb = e - 1; while (lb &lt; rb) &#123; while (nums[rb] &gt;= nums[b] &amp;&amp; lb &lt; rb) rb--; while (nums[lb] &lt;= nums[b] &amp;&amp; lb &lt; rb) lb++; swap(nums[lb], nums[rb]); &#125; swap(nums[b], nums[lb]); quick_sort(nums, b, lb); quick_sort(nums, lb + 1, e); &#125;&#125; 复杂度分析 快速排序也是一个不稳定排序，时间复杂度看维基百科。空间复杂度是O(n)。 7. 堆排序（Heap Sort）堆排序经常用于求一个数组中最大k个元素时。因为堆实际上是一个完全二叉树，所以用它可以用一维数组来表示。因为最大堆的第一位总为当前堆中最大值，所以每次将最大值移除后，调整堆即可获得下一个最大值，通过一遍一遍执行这个过程就可以得到前k大元素，或者使堆有序。 在了解算法之前，首先了解在一维数组中节点的下标： i节点的父节点 parent(i) = floor((i-1)/2) i节点的左子节点 left(i) = 2i + 1 i节点的右子节点 right(i) = 2i + 2 步骤 构造最大堆（Build Max Heap）：首先将当前元素放入最大堆下一个位置，然后将此元素依次和它的父节点比较，如果大于父节点就和父节点交换，直到比较到根节点。重复执行到最后一个元素。 最大堆调整（Max Heapify）：调整最大堆即将根节点移除后重新整理堆。整理方法为将根节点和最后一个节点交换，然后把堆看做n-1长度，将当前根节点逐步移动到其应该在的位置。 堆排序（HeapSort）：重复执行2，直到所有根节点都已移除。 12345678910111213141516171819202122232425262728293031323334void heap_sort(vector&lt;int&gt; &amp;nums)&#123; int n = nums.size(); for (int i = n / 2 - 1; i &gt;= 0; i--) &#123; // build max heap max_heapify(nums, i, nums.size() - 1); &#125; for (int i = n - 1; i &gt; 0; i--) &#123; // heap sort int temp = nums[i]; num[i] = nums[0]; num[0] = temp; max_heapify(nums, 0, i); &#125;&#125;void max_heapify(vector&lt;int&gt; &amp;nums, int beg, int end)&#123; int curr = beg; int child = curr * 2 + 1; while (child &lt; end) &#123; if (child + 1 &lt; end &amp;&amp; nums[child] &lt; nums[child + 1]) &#123; child++; &#125; if (nums[curr] &lt; nums[child]) &#123; int temp = nums[curr]; nums[curr] = nums[child]; num[child] = temp; curr = child; child = 2 * curr + 1; &#125; else &#123; break; &#125; &#125;&#125; 复杂度分析 堆执行一次调整需要O(logn)的时间，在排序过程中需要遍历所有元素执行堆调整，所以最终时间复杂度是O(nlogn)。空间复杂度是O(n)。 0. 参考 维基百科 经典排序算法总结与实现 堆排序C++实现 常见排序算法 - 堆排序 (Heap Sort)","categories":[{"name":"算法","slug":"算法","permalink":"yongchunxiaofen.top/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"},{"name":"算法","slug":"算法","permalink":"yongchunxiaofen.top/tags/算法/"}]},{"title":"python-常用资源","slug":"python-resources","date":"2016-05-27T08:01:19.000Z","updated":"2016-06-30T02:44:14.000Z","comments":true,"path":"2016/05/27/python-resources/","link":"","permalink":"yongchunxiaofen.top/2016/05/27/python-resources/","excerpt":"常用代码遍历对象for key in a.__dict__: print key,&apos;:&apos;,a.__dict__[key] 调试方法assert False //引发异常，观察错误界面 import logging logging.info(&apos;&apos;) //写日志","text":"常用代码遍历对象for key in a.__dict__: print key,&apos;:&apos;,a.__dict__[key] 调试方法assert False //引发异常，观察错误界面 import logging logging.info(&apos;&apos;) //写日志 获得当前时间#时间戳 time.time() #日期时间 time.ctime() #iso时间 datetime.fromtimestamp(time.time()).isoformat() #固定格式 time.strftime(&apos;%Y-%m-%d&apos;,time.localtime(time.time())) 日期到时间戳dateC=datetime.datetime(2010,6,6,8,14,59) timestamp=time.mktime(dateC.timetuple()) 时间戳到日期ltime=time.localtime(1237515355.0) timeStr=time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, ltime) 之后的包从绝对位置导入from __future__ import absolute_import","categories":[{"name":"python","slug":"python","permalink":"yongchunxiaofen.top/categories/python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"yongchunxiaofen.top/tags/Python/"}]},{"title":"shell常用资源","slug":"shell-resources","date":"2016-05-27T07:59:06.000Z","updated":"2016-06-30T03:20:39.000Z","comments":true,"path":"2016/05/27/shell-resources/","link":"","permalink":"yongchunxiaofen.top/2016/05/27/shell-resources/","excerpt":"常用指令文本内容搜索grep aaa * 文件夹操作查看文件夹大小 du -h --max-depth=1 /home/ys 查看驱动器空间 df -h 压缩命令tar zxvf aaa.tar.gz tar zcvf aaa.tar.gz aaa","text":"常用指令文本内容搜索grep aaa * 文件夹操作查看文件夹大小 du -h --max-depth=1 /home/ys 查看驱动器空间 df -h 压缩命令tar zxvf aaa.tar.gz tar zcvf aaa.tar.gz aaa 登陆到其他用户login 查看端口的占用lsof -i:8087 查看8087端口的使用 批量杀死进程ps -aux|grep name|grep -v grep|cut -c 9-15|xargs kill -9 查看当前时间date 时间 date +%s 时间戳 date -d &quot;2010-07-20 10:25:30&quot; +%s 指定时间时间戳 date -d &quot;@1279592730&quot; 时间戳转时间 date -d &quot;1970-01-01 14781 days&quot; &quot;+%Y/%m/%d %H:%M:%S&quot; 查看进程内存使用情况top -d 1 -p pid [,pid ...] pmap pid ps aux|grep process_name 查看/proc/process_id/文件夹下的status文件 查看Linux内核版本或发布版本lsb_release -a uname -a 一句话实现一个HTTP服务，把当前文件夹作为根目录python -m SimpleHTTPServer 查看本地网络服务活动状态lsof -i 查看自己的外网ipcurl ifconfig.me 下载整个网站wget --random-wait -r -p -e robots=off -U mozilla http://www.example.com 后台运行一段不中止的程序，并可随时查看它的状态screen -d -m -S some_ name ping my_router 查看进程执行的时间ps -A -opid,stime,etime,args | grep python 创建守护进程nohup python /var/www/a.py &amp; 查看当前文件夹下文件（文件夹）大小du -h --max-depth=1 . 查看所有磁盘大小df -h 诊断网络mtr ping traceroute dig 列出本机监听的端口号netstat –tlnp netstat -anop 在远程机器上运行一段脚本ssh user@server bash &lt; /path/to/local/script.sh 端口扫描nc -z -v -n 127.0.0.1 20-100 负载测试，30秒内向Google发起20个并发连接siege -c20 www.google.co.uk -b -t30s","categories":[{"name":"Shell","slug":"Shell","permalink":"yongchunxiaofen.top/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"yongchunxiaofen.top/tags/Shell/"}]},{"title":"大学告白","slug":"end-of-university","date":"2016-05-27T07:56:42.000Z","updated":"2016-05-27T08:56:20.000Z","comments":true,"path":"2016/05/27/end-of-university/","link":"","permalink":"yongchunxiaofen.top/2016/05/27/end-of-university/","excerpt":"","text":"今天上午答辩完了，准备了几个月的毕业设计，也算是给了自己一个交代。 回想自己本科四年，有过得失，有过起伏。自己在学校做了很多自己大学之前不敢，也没有机会做的事情。 这四年每天都有新鲜事情发生，现在却一件都想不起来了，唯一的感觉就是自己淡然了很多。","categories":[{"name":"生活","slug":"生活","permalink":"yongchunxiaofen.top/categories/生活/"}],"tags":[]},{"title":"Git常用资源","slug":"git-resouce","date":"2016-05-27T07:50:25.000Z","updated":"2016-06-30T03:20:22.000Z","comments":true,"path":"2016/05/27/git-resouce/","link":"","permalink":"yongchunxiaofen.top/2016/05/27/git-resouce/","excerpt":"库管理克隆库12git clone https://github.com/php/php-src.gitgit clone --depth=1 https://github.com/php/php-src.git # 只抓取最近的一次 commit 历史管理查看历史12git log --pretty=oneline filename # 一行显示git show xxxx # 查看某次修改","text":"库管理克隆库12git clone https://github.com/php/php-src.gitgit clone --depth=1 https://github.com/php/php-src.git # 只抓取最近的一次 commit 历史管理查看历史12git log --pretty=oneline filename # 一行显示git show xxxx # 查看某次修改 标签功能12345678git tag # 显示所有标签git tag -l 'v1.4.2.*' # 显示 1.4.2 开头标签git tag v1.3 # 简单打标签 git tag -a v1.2 9fceb02 # 后期加注标签git tag -a v1.4 -m 'my version 1.4' # 增加标签并注释， -a 为 annotated 缩写git show v1.4 # 看某一标签详情git push origin v1.5 # 分享某个标签git push origin --tags # 分享所有标签 回滚操作12git reset 9fceb02 # 保留修改git reset 9fceb02 --hard # 删除之后的修改 取消文件的修改12git checkout -- a.php # 取消单个文件git checkout -- # 取消所有文件的修改 删除文件12git rm a.php # 直接删除文件git rm --cached a.php # 删除文件暂存状态 移动文件1git mv a.php ./test/a.php 查看文件修改12git diff # 查看未暂存的文件更新 git diff --cached # 查看已暂存文件的更新 暂存和恢复当前staging12345git stash # 暂存当前分支的修改git stash apply # 恢复最近一次暂存git stash list # 查看暂存内容git stash apply stash@&#123;2&#125; # 指定恢复某次暂存内容git stash drop stash@&#123;0&#125; # 删除某次暂存内容 修改 commit 历史纪录1git rebase -i 0580eab8 分支管理创建分支12git branch develop # 只创建分支git checkout -b master develop # 创建并切换到 develop 分支 合并分支1234git checkout master # 切换到 master 分支git merge --no-ff develop # 把 develop 合并到 master 分支，no-ff 选项的作用是保留原分支记录git rebase develop # rebase 当前分支到 developgit branch -d develop # 删除 develop 分支 克隆远程分支12git branch -r # 显示所有分支，包含远程分支git checkout origin/android 修复develop上的合并错误 将merge前的commit创建一个分之，保留merge后代码 将develop reset --force到merge前，然后push --force 在分支中rebase develop 将分支push到服务器上重新merge 强制更新到远程分支最新版本12git reset --hard origin/mastergit submodule update --remote -f Submodule使用克隆带submodule的库1git clone --recursive https://github.com/chaconinc/MainProject clone主库后再去clone submodule123git clone https://github.com/chaconinc/MainProjectgit submodule initgit submodule update Git设置Git的全局设置在~/.gitconfig中，单独设置在project/.git/config下。 忽略设置全局在~/.gitignore_global中，单独设置在project/.gitignore下。 设置 commit 的用户和邮箱12git config user.name \"xx\"git config user.email \"xx@xx.com\" 或者直接修改config文件 123[user] name = xxx email = xxx@xxx.com 查看设置项1git config --list 设置git终端颜色```bashgit config –global color.diff autogit config –global color.status autogit config –global color.branch auto","categories":[{"name":"Git","slug":"Git","permalink":"yongchunxiaofen.top/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"yongchunxiaofen.top/tags/Git/"}]},{"title":"刷题遇上的知识点","slug":"something-should-focus-on","date":"2016-05-27T05:36:36.000Z","updated":"2016-06-30T02:43:33.000Z","comments":true,"path":"2016/05/27/something-should-focus-on/","link":"","permalink":"yongchunxiaofen.top/2016/05/27/something-should-focus-on/","excerpt":"1 运算符号|（按位取或运算） 和&amp;（按位取与运算），逗号运算符例题分析： 如果x=2014，下面函数的返回值是（） 123456789101112&lt;?cppint fun(unsigned int x)&#123; int n=0; while((x+1)) &#123; n++; x=x|(x+1); &#125; return n;&#125;&gt;","text":"1 运算符号|（按位取或运算） 和&amp;（按位取与运算），逗号运算符例题分析： 如果x=2014，下面函数的返回值是（） 123456789101112&lt;?cppint fun(unsigned int x)&#123; int n=0; while((x+1)) &#123; n++; x=x|(x+1); &#125; return n;&#125;&gt; 题目当中，有一个x|(x+1)的计算。 对于x|(x+1)，是计算 x 的二进制中0的数量。 而对于x|(x-1)，是计算 x 的二进制中1的数量。 如题目中所述，2014的二进制表示为0000 0000 0000 0000 0000 0011 1101 1111 每次计算都是将 x 的二进制数中从右往左第一个 0 变成 1 ，直至所有的数都变成 1 溢出。 例如 第一次循环： 0000 0000 0000 0000 0000 0011 1101 1111|0000 0000 0000 0000 0000 0011 1110 0000 ==0000 0000 0000 0000 0000 0011 1111 1111 以此类推。 1.1 逗号运算符 在C语言中，多个表达式可以用逗号分开，其中用逗号分开的表达式的值分别结算，但整个表达式的值是最后一个表达式的值。 逗号运算符的运算级别是所有运算符中最低的。如下例子。 1234int a=3, b=5, c;c = a&gt;b, a+b;// 运行后c值为0，因为逗号运算符的优先级低于赋值运算符，所以先将a&gt;b的结果(为0)赋值给c，之后运算a+b（结果不保存），所以c=0c = (a&gt;b, a+b); // 运行后c值为8，因为括号的优先级高于赋值运算符，所以先算括号内的表达式，此时计算结果为最后一个表达式的值，即a+b的值，所以c=8 2 sizeof求结构体的长度问题用sizeof求结构体的长度时，不能简单地使用各个成员的长度和，而是要考虑系统在存储结构体变量时的地址对其问题。 实际中，存储变量时地址要对其，应遵循两点原则： 结构体变量中成员的偏移量必须是成员大小的整数倍。 结构体大小必须是所有成员大小的整数倍，也就是所有成员大小的公倍数。即长度最大的成员的整数倍。 例如： 12345678910&lt;?struct&#123; double a; int b; char c;&#125; A;?&gt; 对A求sizeof的长度为double类型长度的整数倍，也即8的整数倍。 又如， 1234567&lt;?cstruct &#123; int a; char b;&#125;B;?c&gt; 对B求sizeof的长度为int类型长度的整数倍，也即4的整数倍。 来看一例题。 12345678910111213141516class A&#123; int a; short b; int c; char d;&#125;;class B&#123; double a; short b; int c; char d;&#125;;//在32位机器上用gcc编译以上代码，求sizeof(A),sizeof(B)分别是多少。 A中，a占4个字节，b本应占2个字节，但由于c占4个字节，为了满足条件： 结构体内的成员的首地址相对于结构体首地址的偏移量是其类型大小的整数倍，比如说double型成员相对于结构体的首地址的地址偏移量应该是8的倍数b多占用2个字节，为了满足条件1，d占用4个字节，一共16个字节。B中，a占8个字节，b占2个字节，但由于c占4个字节，为了满足条件2，b多占用2个字节，{: .notice} 即abc共占用8+4+4=16个字节， 为了满足条件1，d将占用8个字节，一共24个字节。 3 零碎的知识点 普通的运算符可以重载，特殊的不能重载，比如 . :: 等 const是常对象，也就是不改变成员变量的值，而成员函数中只有const函数可以确保不改变成员变量的值 析构函数一般定义为虚函数，构造函数不能是虚函数 重载只要求函数名相同，参数类型和个数不同，不要求返回值类型 虚函数不能是：内联函数、静态函数、构造函数 宏 宏的嵌套定义过多会影响程序的可读性，而且很容易出错 相对于函数调用，宏定义可以提高程序的运行效率 宏定义不检查参数正确性，会有安全隐患 动态分配的内存free释放当使用free释放掉一个指针内容时，需要程序员手动将该指针置为NULL，编译器不会自动置NULL，否则会产生野指针。 reinterpret_cast ————C++中的强制类型转换符1reinterpret_cast&lt;type-id&gt; (expression) type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。 它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，再把该整数转换成原类型的指针，还可以得到原先的指针值）。 有如下例题： 123456789//下面程序运行后的结果为：char str[] = &quot;glad to test something&quot;;char *p = str;p++;int *p1 = reinterpret_cast&lt;int *&gt;(p);p1++;p = reinterpret_cast&lt;char *&gt;(p1); printf(&quot;result is %s\\n&quot;, p);//结果为：result is to test something 例题分析：一开始，char类型的指针p指向str的首地址，即指向字符串中的g执行p++，指向l然后将char类型的指针p，强制转换成int类型的指针p1执行p1++，实际移动了四个字节，然后再将int类型的p1指针转换成char类型的p指针，p指向了t。所以结果输出为result is to test something 4. strcat and strcpystrcat函数的原型是：1234char *strcat( char *strDestination, const char *strSource ); strcat的作用是连接两个字符串，具体操作时，是将src所指的字符串添加到desk结尾处，覆盖掉desk结尾的‘\\0’ strcpy函数的原型是：1234char *strcpy( char *strDestination, const char *strSource ); strcpy的作用是，src所指向的字符串复制到以desk开始的地址空间 区别： strcat是无空格连接两个字符串 strcpy是覆盖掉前一个指针开始位置的字符串 5.复杂度计算复杂度的排列 常数阶：$$O(1)$$ &lt; 对数阶（$$O(log_2n$$） &lt; 线形阶（$$O(n)$$）&lt; 线形对数阶（$$O(n*log_2n)$$） 复杂度计算 例1： 1234sum = 0; 1次for(int i = 0; i &lt; n; i ++ ) n次 for(int j = 0; j &lt; n; j ++) n^2次 sum++; n^2次 因为$Θ(2n^2+n+1)=n^2$（Θ即：去低阶项，去掉常数项，去掉高阶项的常参得到），所以$T(n)= =O(n^2)$； 例2：$O(n^2)$ 123456for (i=1;i&lt;n;i++) &#123; y=y+1; ① for (j=0;j&lt;=(2*n);j++) x++; ② &#125; 解： 语句1的频度是$n-1$ 语句2的频度是$\\ (n-1)(2n+1) = (2n^2-n-1)$ 所以有$f(n)=2n^2-n-1+(n-1)=2n^2-2$ 又有$O(2^2-2)=n^2$该程序的时间复杂度$T(n)=O(n^2)$. 一般情况下，对步进循环语句只需考虑循环体中语句的执行次数，忽略该语句中步长加1、终值判别、控制转移等成分，当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。 例3：$O(log_2 n)$ 123i=1; ① while (i&lt;=n) i=i*2; ② 解：语句1的频度是1； 语句2的频度是$f(n)$,则有$2^{f(n)}&lt;=n;f(n)&lt;=log_2{n} $ 取最大值$f(n)=log_2n$, $T(n)=O(log_2n )$ 常用的算法时间复杂度和空间复杂度 排序法 平均时间 最差情形 稳定度 额外空间 备注 冒泡 $O(n^2)$ $O(n^2)$ 稳定 $O(1)$ n小时较好 交换 $O(n^2)$ $O(n^2)$ 不稳定 $O(1)$ n小时较好 —— 选择 $O(n^2)$ $O(n^2)$ 不稳定 $O(1)$ n小时较好 插入 $O(n^2)$ $O(n^2)$ 稳定 $O(1)$ 大部分已排序时较好 —- 快速 $O(logn)$ $O(n^2)$ 不稳定 $O(logn)$ n大时较好 归并 $O(logn)$ $O(n^2)$ 稳定 $O(1)$ n大时较好 堆 $O(logn)$ $O(n^2)$ 不稳定 $O(logn)$ n大时较好 —- {: rules=”groups”} 参考：zolalad的专栏{: .notice}","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"}]},{"title":"ESSENTIAL C++ 读书笔记","slug":"ESSENTIAL C++ 读书笔记","date":"2016-05-27T04:46:36.000Z","updated":"2016-06-30T02:44:23.000Z","comments":true,"path":"2016/05/27/ESSENTIAL C++ 读书笔记/","link":"","permalink":"yongchunxiaofen.top/2016/05/27/ESSENTIAL C++ 读书笔记/","excerpt":"1.条件语句if条件语句，如果括号内的运算式结果为true，那么紧接着if之后的那一条语句会被执行。当if后接多条语句时，则必须在if语句之后以大括号｛｝的形式将这些执行语句括起来，成为一个语句块。 12345if(statement=true)&#123; num++; std::cout&lt;&lt;num&lt;&lt;std::endl;&#125;","text":"1.条件语句if条件语句，如果括号内的运算式结果为true，那么紧接着if之后的那一条语句会被执行。当if后接多条语句时，则必须在if语句之后以大括号｛｝的形式将这些执行语句括起来，成为一个语句块。 12345if(statement=true)&#123; num++; std::cout&lt;&lt;num&lt;&lt;std::endl;&#125; 常见的错误是多条执行语句时忘记加大括号。例如 1234567//忘记加语句块//两条 语句当中，只有num++受if条件的控制//std::cout&lt;&lt;num&lt;&lt;std::endl;这条语句，无论if条件是否成立，它都会被执行。if(statement=true) num++; std::cout&lt;&lt;num&lt;&lt;std::endl; 另外，当面临两种选择，但是其中的一种选择又嵌套了多种选择的情况下，可以采取如下的处理方式： 12345678910111213141516171819202122232425if(user_guess == next_elem)&#123; //用户猜对&#125;else&#123; //用户猜错 if( num_tries == 1 ) //... else if( num_tries == 2 ) //... else if( num_tries == 3 ) //... ... else //... cout&lt;&lt;\"Want you try again? (Y/N)\" char user_rsp; cin &gt;&gt; user_rsp; if ( user_rsp == 'N' || user_rsp == 'n' ) go_for_it = false;&#125; 2.vector赋初值1234567891011121314int seq_size = 18;std::vector&lt;int&gt; elem_seq(seq_size); //申明一个长度为seq_size的vector数组//对其初始化时，其一的方式是：elem_seq[0]=1;elem_seq[1]=2;...elem_seq[17]=22;//另外一个方式是：利用一个已经初始化的array作为该vector的初值int elem_vals[seq_size]=&#123;1,2,3,3,4,7,2,5,12,3,6,10,4,9,16,5,12,22&#125;;//然后以elem_vals的值来初始化vectorvector&lt;int&gt; elem_seq(elem_vals,elem_vals+seq_size);//括号中的两个值都是实际内存，标出了用以将vector初始的范围。 3.数组指针与指针数组部分转自Romi-知行合一 的博客。 对于这两个概念的中文翻译太过于拗口，或许其英文名可能更加直白一些。 指针数组：array of pointers，即用于存储指针的数组，也就是数组元素都是指针。本质是数组，其中的每一个元素都是指针。 数组指针：a pointer to an array，即指向数组的指针。本质是指针，指针指向数组的起始地址。 还要注意的是他们用法的区别，下面举例说明。 int* a[4] 指针数组 表示：数组a中的元素都为int型指针 元素表示：*a[i] *(a[i])是一样的，因为[]优先级高于* int (*a)[4] 数组指针 表示：指向数组a的指针 元素表示：(*a)[i] 4.指针有以下的vector对象： vector&lt;int&gt;fibonacci,lucas,pell,triangular,square,pentagonal;当需要一个指针，指向“元素类型为int型的”vector时，指针应该是什么样？一般，指针的形式为： 1type_of_object_pointed_to * name_of_pointer_object 由于要的指针是指向vector，因此将其命名为pv，并给定初值。 1234vector&lt;int&gt; *pv=0;//pv可以依次指向每一个表示数列的vectorpv=&amp;fibonaccipv=&amp;lucas; 同时，还可以采取另一种方式访问这些数列 1234567const int seq_cnt = 6;//定义一个指针数组，数组的长度为seq_cnt;//每个指针都指向vector&lt;int&gt;对象vector&lt;int&gt; *seq_addrs[seq_cnt]=&#123; &amp;fibonacci,&amp;lucas,&amp;pell, &amp;triangular,&amp;square,&amp;pentagonal&#125;; 5.文件的读写包含头文件#include&lt;fstream&gt; 5.1 写定义一个ofstream对象，并将文件名传入： 1ofstream outfile(\"seq_data.txt\") 使用该命令写入文件时，如果不存在该文件，则新建-&gt;写入。如果存在该文件，则写入时会丢弃原来的数据。如果文件已经存在，我们不希望丢弃原有的数据，而是希望将新数据增加到该文件中，那么必须以追加模式(append mode)打开这个文件 。应该提供第二个参数ios_base::app给ofstream对象，命令为ofstream outfile(&quot;seq_data.txt&quot;,ios_base::app); 文件有可能打开失败。//如果outfile求值结果为false，表示该文件并未成功打开 12if(!outfile) 123456789if(!outfile) //因为某种原因，文档未能打开 cerr&lt;&lt;\"Unable to save session data!\\n\"; //cerr:标准错误设备，和cout一样，cerr将其输出结果定向到用户终端，差别是cerr的输出结果并无缓冲情形，会立即显示到用户终端。else outfile&lt;&lt;user_name&lt;&lt;\" \" &lt;&lt;num_tries&lt;&lt;\" \" &lt;&lt;num_right&lt;&lt;endl; 5.2 读123456789101112131415161718192021222324252627282930ifstream infile(\"seq_data.txt\")int num_tries = 0;int num_cor = 0;if(!infile)&#123; //由于某种原因，文件无法打开&#125;else&#123; string name; int nt;//the number of tries int nc;//the number of correct while(infile &gt;&gt; name) &#123; infile &gt;&gt; nt &gt;&gt; nc;//会将用户猜对的总数存入nt中，正确的次数读入nc中。 if(name == user_name) &#123; cout&lt;&lt;\"Welcome back,\"&lt;&lt;user_name &lt;&lt;\"\\nYour currents score is\"&lt;&lt;nc &lt;&lt;\" out of \"&lt;&lt;nt&lt;&lt;\"\\nGod luck!\\n\"; num_tries = nt; num_cor = nc; &#125; &#125;&#125; 6.fibonacci数组1234567891011121314151617181920212223bool fibo_elem(int pos, int &amp;elem) &#123; //**检查位置是否合理 //1024是人为设定的一个值，因为计算机的数值类型表示的数范围有限，超过上限时会溢出，造成异常。 if(pos&lt;=0 || pos &gt; 1024) &#123; elem=0; return false; &#125; //位置在1和2时，直接返回结果为1，而不进行遍历 int n_1 = 1; int n_2 = 1; elem = 1; for(int ix=3;ix&lt;=pos;++ix) &#123; elem=n_1 + n_2; n_1 = n_2; n_2 = elem; &#125; return true; &#125; 7. pass by value &amp;&amp; pass by referencepass by value(传值)：将对象进行拷贝到被调用函数中，当被调用函数中的值发生变化时，仅仅变化的是这份拷贝，调用函数中的实参并未发生变化。pass by reference(传址)： 1&gt;希望得以对传入的对象直接进行修改。 2&gt;降低复制大型对象的额外负担。例如：2.2 调用函数 例题分析一节中，display函数采用的是值传递的方式，虽然这样也能达到显示的目的，但是，如果我们采用如下方式传入vector的地址时，速度可能会更快： 12345678void display(const vector&lt;int&gt; &amp;ivec)//函数之中并不会更改vector的内容，加上const加深对程序的理解。&#123; for(int ix=0;ix&lt;ivec.size();++ix) &#123; std::cout&lt;&lt;ivec[ix]&lt;&lt;std::endl; &#125;&#125; 另外，如果有必要，我们也可以选择指针传递的方式来进行 1234567891011121314151617181920212223void display(std::vector&lt;int&gt; *ivec)&#123; if(!ivec) &#123; std::cout&lt;&lt;\"the vector pointer is 0\\n\"; return ; &#125; for(int ix=0;ix&lt;ivec-&gt;size();ix++) &#123; std::cout&lt;&lt;(*ivec)[ix]&lt;&lt;std::endl; &#125;&#125;int main()&#123; int a[8]=&#123;8,32,3,13,1,21,5,2&#125;; vector&lt;int &gt;vec(a,a+8); std::cout&lt;&lt;\"vector before sort:\"; display(&amp;vec);//传入vector数组的地址。&#125; 7.1 动态内存管理dynamic extent（动态范围）：内存系由程序的空闲空间分配而来，有时也称为堆内存（heap memory）。由程序员管理，分配：new，释放：delete。例如： 1234567891011121314151617int *pi;pi=new int;//heap分配出一个int类型的对象，然后将其地址赋值给pi，默认情况下，未被初始化。pi=new int(1024);//将分配的内存用1024初始化。//分配数组int *pia=new int[24];//指针指向数组第一个元素的地址，也就是数组的首地址，数组未被初始化。//释放分配的内存delete pi;//如果要删除数组中的所有对象，则应该在delete和数组指针之间加上一个空的下标运算符delete [] pia;//因为某种原因，程序员并未使用delete表达式，由heap分配而来的对象就永远不会被释放，这称为内存泄漏（memory leak） 7.2 局部静态对象在求Fibonacci数组的函数当中，每次调用fibona_seq(int size)函数时，都会从头开始递归计算。例如： 123456fibona_seq(24);fibona_seq(8);fibona_seq(16);//每一次调用时，都从头开始计算//如上，如果能将第一次调用计算的值储存，则调用后两个函数时则不需要再调用，直接得出结果即可。 基于以上问题，引入局部静态变量的使用。例如，如下代码： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;vector&gt;#include&lt;iostream&gt;using namespace std;const vector&lt;int&gt; *fibona_seq(int size)&#123; const int max=100; //局部静态变量（静态容器）。每次被调用时不会像局部非静态变量那样破坏又重新建立 static vector&lt;int&gt;ivec; if(size&lt;=0 || size&gt;100) &#123; cout&lt;&lt;\"Error input.\\n\"; return 0; &#125; //如果传入的size比当前静态容器中元素的个数要多，说明需要计算的数据不包含在当前的静态容器中 //需要继续往后计算，并将计算得到的结果存入静态容器当中。 for(int ix&gt;ivec.size();ix&lt;size;++ix) &#123; if(ix==0 || ix==1) &#123; ivec.push_back(1); &#125; else &#123; ivec.push_back(ivec[ix-1]+ivec[ix-2]); &#125; &#125; //如果①输入的数值合理&amp;&amp;②当前调用函数传入的size小于当前静态容器中的长度 //说明，所求的数值包含于当前的静态容器当中，此时不需要再计算，直接返回当前静态容器的地址即可。 return &amp;ivec;&#125; 7.3 设定头文件头文件中，包含与程序相关的所有函数申明都放在该文件中。函数的定义只能有一份，倒是可以有许多分声明。不将函数的定义放到头文件，是因为同一个程序的多个代码文件可能都会包含这个头文件。 原因： 首先必须了解编译的过程，编译的第一步是把所有的CPP文件编译成为点O文件，而且每一个点CPP文件都是单独编译的，该点CPP文件中用到的类型必须在它所include 的头文件当中找到，相当于把它所有include的文件中的代码都加到该CPP文件的前面，但是声明的部分将不会出现在编译后的点O文件，相当于每个CPP文件都是单独编译，因此它的ifndef在一个文件里是没有用的，两个CPP文件里如果包含同一个有ifndef的头文件，效果是两个CPP文件都把该头文件加到它的前面，但不会把声明的部分放到点O文件中，而会把头文件中定义的部分都输出到编译后的点O文件当中 因此如果在头文件当中有一个定义，那么如果有两个CPP文件当中include了它，那么将会出现重定义错误，multiple definition of 由于模板不是真实的定义，所以可以放在头文件当中 声明作用只是在链接的时候进行查找，定位，如果出现对一个声明的两个定义，则会出错 但是内联函数的定义必须要放到头文件中 其实原理很简单，就是当用#include 包含一个文件得时候，预处理得时候会直接展开这一个文件，如果文件中放有某个函数的定义，事实上就相当于把该函数定义放在了这个包含这个文件（上面得例子中得print_inline.h）的文件(main.c)中，这样就可以在main中将print_inline函数内联展开 在很多时候，由于某些函数需要经常被调用，为了加快程序的执行速度，经常要用到inline，但是如果inline函数的定义和声明是分开的，而在另外一个文件中需要调用这些inline函数得时候，内联是无法在这些调用函数内展开的（上面得第二个例子），只能调用。这样内联函数在全局范围内就失去了作用。解决的办法就是把内联函数得定义放在头文件中，当其它文件要调用这些内联函数的时候，只要包含这个头文件就可以了 ——转自sunshine的博客 8.基于对象的编程风格8.1 构造函数和析构函数首先，构造函数constructor不应指定返回类型，亦不用任何返回值。可以被重载 最简单的构造函数是默认构造函数default constructor。不需要任何参数，其包含了两种情况 不接受任何参数 12345678Triangular::Triangular&#123; //default constructor _length=1; _beg_pos=1; _next=0;&#125; 这种情况更常见，它为每个参数提供了默认值： 123456789101112131415class Triangular&#123; public: //default constructor Triangular(int len=1,int bp=1);&#125;;Triangular::Triangular(int len,int bp)&#123; _length = len &gt; 0 ? len : 1; _beg_pos = bp &gt; 0 ? bp : 1; _next = _beg_pos - 1;&#125; 8.1.1 构造函数的第二种初始化方法——成员初始化列表12345Triangular::Triangular( const Triangular &amp;rhs ) : _length(rhs._length),_beg_pos(rhs._beg_pos),_next(rhs._beg_pos-1)&#123; &#125;//空格//成员初始化列表紧跟在参数列表最后的冒号后边，是个以逗号分隔的列表。//其中，欲赋值给member的数值被放在member名称后边的小括号中。 8.1.2 析构函数（destructor）绝对不会 有返回值，也没有任何参数。由于参数列表为空，所以绝对不可能被重载。 考虑如下的Matrix class，其constructor使用new表达式从heap中分配double数组所需的空间。destructor则负责释放这些内存： 1234567891011121314151617class Matrix&#123;public: Matrix( int row , int col ) : _row(row), _col(col) &#123; _pmat = new double[row*col]; &#125; ~Matrix() &#123; delete [] _pmat; &#125;private: int _row,_col; double *_pmat;&#125;; 8.1.3 成员逐一初始化123Triangular tri1(8);Triangular tri2=tri1; class data member会被依次复制。本例中的_length,_beg_pos,_next都会依次从tri1复制到tri2，此即成员的逐一初始化操作这样逐一初始化有一个潜在的问题，如下 123456789101112131415161718&#123; Matrix mat(4,4); //该处，constructor作用 &#123; Matrix mat2=mat; //该处，进行逐一初始化 //使用mat2 //调用mat2的析构函数释放数据与内存 &#125; //该处使用mat //该处调用mat的析构函数释放内存与数据&#125;//本例中，其中有一项初始化是mat2._pmat = mat._pmat;//两个对象的_pmat指针都指向heap内的同一个数组，当调用mat2的析构函数时，数组空间被释放，而mat的指针仍然指向那个数组，对已经释放掉的数组进行操作时极为危险的行为。?&gt; 这种情况下，可以提供一个copy constructor，其可以改变“成员逐一初始化”的默认行为。我们可以产生一个独立的数组副本，这样便可以使某个对象的析构操作不至于影响到另一个对象 12345678910Matrix::Matrix(cosnt Matrix &amp;rhs) : _row(rhs._row),_col(rhs._col)&#123; //对rhs._pmt所指的数组产生一份完全复本 int elem_cnt = row * col; _pmt = new double [elem_cnt]; for( int ix = 0; ix &lt; elem_cnt ; ix ++) _pmat[ix] = rhs._pmat[ix];&#125; 类中的const常量必须在构造函数的初始化列表中初始化，而不能在构造函数的函数体中初始化。 8.2 类的静态成员部分转自MoreWindows Blog。 在C++中，静态成员是属于整个类的而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存。 eg1：通过类名调用静态成员函数和静态成员变量： 12345678910111213141516class Point&#123;public: void init() &#123; &#125; static void output() &#123; &#125;&#125;;void main()&#123; Point::init(); Point::output();&#125; 编译出错：error C2352: ‘Point::init’ : illegal call of non-static member function 结论1：不能通过类名来调用类的非静态成员函数。 eg2:通过类的对象调用静态成员函数和静态成员变量 12345678910void main()&#123; Point pt; pt.init(); pt.output();&#125;?&gt; 编译通过结论2：类的对象可以使用静态成员函数和非静态成员函数。 eg3：在类的静态成员函数中使用类的非静态成员 1234567891011121314151617181920212223#include &lt;stdio.h&gt;class Point&#123;public: void init() &#123; &#125; static void output() &#123; printf(\"%d\\n\", m_x); &#125;private: int m_x;&#125;;void main()&#123; Point pt; pt.output();&#125;?&gt; 编译出错：error C2597: illegal reference to data member ‘Point::m_x’ in a static member function 因为静态成员函数属于整个类，在类实例化对象之前就已经分配空间了，而类的非静态成员必须在类实例化对象后才有内存空间，所以这个调用就出错了，就好比没有声明一个变量却提前使用它一样。 结论3：静态成员函数中不能引用非静态成员。 eg4:在类的非静态成员函数中使用类的静态成员。 123456789101112131415161718class Point&#123;public: void init() &#123; output(); &#125; static void output() &#123; &#125;&#125;;void main()&#123; Point pt; pt.output();&#125; 编译通过，理由如上所述。 但是反过来却不行，不能在类的静态成员函数中使用类的非静态成员。 结论5：类的静态成员变量必须先初始化再使用。 结合上面的五个例子，对类的静态成员变量和成员函数作个总结： 一。静态成员函数中不能调用非静态成员。 二。非静态成员函数中可以调用静态成员。因为静态成员属于类本身，在类的对象产生之前就已经存在了，所以在非静态成员函数中是可以调用静态成员的。 三。静态成员变量使用前必须先初始化，而且只能在类体外进行。(如int MyClass::m_nNumber = 0;)，否则会在linker时出错。","categories":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"yongchunxiaofen.top/tags/C/"}]}]}