<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>C++面试题30道 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="转自：http://blog.csdn.net/shihui512/article/details/9092439  ，部分节有增删改。  1.new、delete、malloc、free关系　　delete会调用对象的析构函数,和new对应。free只会释放内存，new调用构造函数。　　malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态">
<meta name="keywords" content="面试">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面试题30道">
<meta property="og:url" content="http://yoursite.com/2016/05/30/cpp-in-interview-30/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="转自：http://blog.csdn.net/shihui512/article/details/9092439  ，部分节有增删改。  1.new、delete、malloc、free关系　　delete会调用对象的析构函数,和new对应。free只会释放内存，new调用构造函数。　　malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2016-07-05T01:36:52.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++面试题30道">
<meta name="twitter:description" content="转自：http://blog.csdn.net/shihui512/article/details/9092439  ，部分节有增删改。  1.new、delete、malloc、free关系　　delete会调用对象的析构函数,和new对应。free只会释放内存，new调用构造函数。　　malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-cpp-in-interview-30" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/30/cpp-in-interview-30/" class="article-date">
  <time datetime="2016-05-30T02:26:23.000Z" itemprop="datePublished">2016-05-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-面试/">C++面试</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      C++面试题30道
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转自：<a href="http://blog.csdn.net/shihui512/article/details/9092439" target="_blank" rel="noopener">http://blog.csdn.net/shihui512/article/details/9092439</a>  ，部分节有增删改。</p>
<hr>
<h2 id="1-new、delete、malloc、free关系"><a href="#1-new、delete、malloc、free关系" class="headerlink" title="1.new、delete、malloc、free关系"></a><font color="brown">1.new、delete、malloc、free关系</font></h2><p>　　delete会调用对象的析构函数,和new对应。free只会释放内存，new调用构造函数。<br>　　<strong>malloc与free是C++/C语言的标准库函数</strong>，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。<br>　　对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。<strong>注意new/delete不是库函数</strong>。</p>
<hr>
<a id="more"></a>
<h2 id="2-delete与-delete-区别"><a href="#2-delete与-delete-区别" class="headerlink" title="2.delete与 delete []区别"></a><font color="brown">2.delete与 delete []区别</font></h2><p>　　<strong>delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数</strong>。在More Effective C++中有更为详细的解释：“当<code>delete</code>操作符用于数组时，它为每个数组元素调用析构函数，然后调用<code>operator delete</code>来释放内存。”<code>delete</code>与<code>new</code>配套，<code>delete []</code>与<code>new []</code>配套</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MemTest *mTest1=<span class="keyword">new</span> MemTest[<span class="number">10</span>];</span><br><span class="line">MemTest *mTest2=<span class="keyword">new</span> MemTest;</span><br><span class="line">Int *pInt1=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">Int *pInt2=<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">delete</span>[]pInt1; <span class="comment">//-1-</span></span><br><span class="line"><span class="keyword">delete</span>[]pInt2; <span class="comment">//-2-</span></span><br><span class="line"><span class="keyword">delete</span>[]mTest1;<span class="comment">//-3-</span></span><br><span class="line"><span class="keyword">delete</span>[]mTest2;<span class="comment">//-4-</span></span><br></pre></td></tr></table></figure>
<p>在<code>-4-</code>处报错。<br> 　　这就说明：<strong>对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。delete[]删除一个数组，delete删除一个指针</strong>。简单来说，用new分配的内存用delete删除；用new[]分配的内存用delete[]删除。<strong>delete[]会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。</strong>如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。</p>
<hr>
<h2 id="3-C-有哪些性质（面向对象特点）"><a href="#3-C-有哪些性质（面向对象特点）" class="headerlink" title="3.C++有哪些性质（面向对象特点）"></a><font color="brown">3.C++有哪些性质（面向对象特点）</font></h2><pre><code>封装 
继承 
多态 
</code></pre><hr>
<h2 id="4-子类析构时要调用父类的析构函数吗？"><a href="#4-子类析构时要调用父类的析构函数吗？" class="headerlink" title="4.子类析构时要调用父类的析构函数吗？"></a><font color="brown">4.子类析构时要调用父类的析构函数吗？</font></h2><p>　　析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了。<strong>定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。</strong></p>
<hr>
<h2 id="5-多态，虚函数，纯虚函数"><a href="#5-多态，虚函数，纯虚函数" class="headerlink" title="5.多态，虚函数，纯虚函数"></a><font color="brown">5.多态，虚函数，纯虚函数</font></h2><p>对虚函数和纯虚函数的详细理解，参考<a href="http://blog.csdn.net/hackbuteer1/article/details/7558868" target="_blank" rel="noopener">Hackbuteer1的专栏</a></p>
<p>　　多态：是对于不同对象接收相同消息时产生不同的动作。<br>　　C++的多态性具体体现在<strong>运行和编译</strong>两个方面：在程序运行时的多态性通过继承和虚函数来体现；在程序编译时多态性体现在函数和运算符的重载上；<br>　　虚函数：在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。<br>　　<font color="brown"><br><strong>定义一个函数为虚函数，不代表函数为不被实现的函数。</strong><br>    <strong>定义为虚函数，是为了允许基类的指针调用子类的这个函数</strong><br>    <strong>定义一个函数为纯虚函数，才代表函数没有被实现。</strong></font><br>如下例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::foo() is called"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::foo() is called"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A *a = <span class="keyword">new</span> B();</span><br><span class="line">	a-&gt;foo();<span class="comment">//这儿虽然a是指向A的指针，但是由于虚函数的作用，其调用的仍然是子类的对应的该函数。</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　纯虚函数的作用：<strong>在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在 纯虚函数不具备函数的功能，一般不能直接被调用</strong>。<br>　　<br>　　<strong>纯虚函数存在的目的，就是为了防止基类对象被实例化。</strong></p>
<p>　　从基类继承来的纯虚函数，在派生类中仍是虚函数。<strong>如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）</strong>。<br>　　抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。</p>
<hr>
<h2 id="6-求下面函数的返回值（微软）"><a href="#6-求下面函数的返回值（微软）" class="headerlink" title="6.求下面函数的返回值（微软）"></a><font color="brown">6.求下面函数的返回值（微软）</font></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> countx = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">while</span>(x) </span><br><span class="line">	&#123; </span><br><span class="line">		countx ++; </span><br><span class="line">		x = x&amp;(x<span class="number">-1</span>); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> countx; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假定x = 9999。 答案：8<br>思路：将x转化为2进制，看含有的1的个数。<br>例题分析：<br>第一次循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0010</span> <span class="number">0111</span> <span class="number">0000</span> <span class="number">1111</span>；</span><br><span class="line">x<span class="number">-1</span> = <span class="number">0010</span> <span class="number">0111</span> <span class="number">0000</span> <span class="number">1110</span>； </span><br><span class="line">x &amp; (x - <span class="number">1</span>) = <span class="number">0010</span> <span class="number">0111</span> <span class="number">0000</span> <span class="number">1110</span>；</span><br><span class="line"><span class="comment">//第一次循环的结果是 x 末尾的1被消灭掉</span></span><br></pre></td></tr></table></figure>
<p>第二次循环</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0010</span> <span class="number">0111</span> <span class="number">0000</span> <span class="number">1110</span>;</span><br><span class="line">x - <span class="number">1</span> =  <span class="number">0010</span> <span class="number">0111</span> <span class="number">0000</span> <span class="number">1101</span>;</span><br><span class="line">x &amp; (x - <span class="number">1</span>) = <span class="number">0010</span> <span class="number">0111</span> <span class="number">0000</span> <span class="number">1100</span>;</span><br><span class="line"><span class="comment">//第二次循环的结果是 x 中的1从右往左依次被消灭掉，直至二进制中所有的值都是0，从而x=0程序退出循环。</span></span><br><span class="line"><span class="comment">//因此，循环的次数即给定数二进制中1的个数。</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="7-什么是“引用”？申明和使用“引用”要注意哪些问题？"><a href="#7-什么是“引用”？申明和使用“引用”要注意哪些问题？" class="headerlink" title="7.什么是“引用”？申明和使用“引用”要注意哪些问题？"></a><font color="brown">7.什么是“引用”？申明和使用“引用”要注意哪些问题？</font></h2><p>　答：引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。<br>　声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此<strong>引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。</strong></p>
<p>有如下例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 5;</span><br><span class="line">int j = 6;</span><br><span class="line">int &amp;k = i;//k是i的引用</span><br><span class="line">k = j;//该句执行的结果是，将j的值赋给k，而不是使k作为j的引用。其执行完毕之后，k和其被引用的数i的值都变成6.相当于覆盖了之前对i的赋值。</span><br></pre></td></tr></table></figure></p>
<p>C++中，函数的参数和返回值的传递方式有三种：指针传递，引用传递和值传递。</p>
<p>“引用传递”的性质象”指针传递”，而书写方式象”值传递”。 </p>
<p>实际上”引用”可以做的任何事情”指针”也都能够做，为什么还要”引用”这东西？ </p>
<font color="brown">答案是”用适当的工具做恰如其分的工作”。 </font>

<p>指针能够毫无约束地操作内存中的任何东西，尽管指针功能强大，但是非常危险。 </p>
<p>如果的确只需要借用一下某个对象的”别名”，那么就用”引用”，而不要用”指针”，以免发生意外。</p>
<h2 id="8-将“引用”作为函数参数有哪些特点？"><a href="#8-将“引用”作为函数参数有哪些特点？" class="headerlink" title="8.将“引用”作为函数参数有哪些特点？"></a><font color="brown">8.将“引用”作为函数参数有哪些特点？</font></h2><p><br></p>
<p>　　（1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。<br>　　（2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。<br>　　（3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</p>
<hr>
<h2 id="9-在什么时候需要使用“常引用”？"><a href="#9-在什么时候需要使用“常引用”？" class="headerlink" title="9.在什么时候需要使用“常引用”？　"></a><font color="brown">9.在什么时候需要使用“常引用”？　</font></h2><p>　　如果既要利用引用提高程序的效率，又要<strong>保护传递给函数的数据不在函数中被改变</strong>，就应使用常引用。常引用声明方式：<code>const 类型标识符 &amp;引用名=目标变量名；</code><br>例1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ra=a;</span><br><span class="line">ra=<span class="number">1</span>; <span class="comment">//错误</span></span><br><span class="line">a=<span class="number">1</span>; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p>例2</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">foo</span><span class="params">( )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="built_in">string</span> &amp; s)</span></span>;</span><br><span class="line"><span class="comment">//那么下面的表达式将是非法的：</span></span><br><span class="line">bar(foo( ));</span><br><span class="line">bar(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure>
<p>原因在于foo( )和”hello world”串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。引用型参数应该在能被定义为const的情况下，尽量定义为const 。</p>
<hr>
<h2 id="10-将“引用”作为函数返回值类型的格式、好处和需要遵守的规则"><a href="#10-将“引用”作为函数返回值类型的格式、好处和需要遵守的规则" class="headerlink" title="10.将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?"></a>10.将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?</h2><p>格式：类型标识符 &amp;函数名（形参列表及类型说明）{ //函数体 }</p>
<p>关于本节可以参考<a href="http://www.cnblogs.com/floatedclouds/archive/2011/10/13/2209917.html" target="_blank" rel="noopener">Let it Be 的博客</a></p>
<p>好处：在内存中不产生被返回值的副本，而是返回对象的引用，即对象本身，程序的执行效率更高；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error! )</p>
<p>注意事项：<br>（1）<strong>不能返回局部变量的引用</strong>。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了”无所指”的引用，程序会进入未知状态。<br>（2）<strong>不能返回函数内部new分配的内存的引用</strong>。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。<br>（3）<strong>可以返回类成员的引用，但最好是const</strong>。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。<br>（4）<strong>流操作符重载返回值申明为“引用”的作用</strong>：<br>流操作符&lt;&lt;和&gt;&gt;，这两个操作符常常希望被连续使用，例如：cout &lt;&lt; “hello” &lt;&lt; endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个&lt;&lt;操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用&lt;&lt;操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。<br>赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">＃include&lt;iostream&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">put</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">int</span> vals[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> error=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">put(<span class="number">0</span>)=<span class="number">10</span>; <span class="comment">//以put(0)函数值作为左值，等价于vals[0]=10; </span></span><br><span class="line">put(<span class="number">9</span>)=<span class="number">20</span>; <span class="comment">//以put(9)函数值作为左值，等价于vals[9]=20; </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;vals[<span class="number">0</span>]; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;vals[<span class="number">9</span>];</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">put</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n&gt;=<span class="number">0</span> &amp;&amp; n&lt;=<span class="number">9</span> ) <span class="keyword">return</span> vals[n]; </span><br><span class="line"><span class="keyword">else</span> &#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"subscript error"</span>; <span class="keyword">return</span> error; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（5）在另外的一些操作符中，却千万不能返回引用：+-*/ 四则运算符。它们不能返回引用，Effective C++[1]的Item23详细的讨论了这个问题。主要原因是这四个操作符没有side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个new分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第2、3两个方案都被否决了。静态对象的引用又因为((a+b) == (c+d))会永远为true而导致错误。所以可选的只剩下返回一个对象了。</p>
<hr>
<h2 id="11、结构与联合有和区别？"><a href="#11、结构与联合有和区别？" class="headerlink" title="11、结构与联合有和区别？"></a>11、结构与联合有和区别？</h2><p>(1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。<br>(2). 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。</p>
<hr>
<h2 id="12、试写出程序结果："><a href="#12、试写出程序结果：" class="headerlink" title="12、试写出程序结果："></a>12、试写出程序结果：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  a=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  &amp;<span class="title">f</span><span class="params">(<span class="keyword">int</span>  x)</span></span></span><br><span class="line"><span class="function"></span>&#123;    a=a+x;</span><br><span class="line">      <span class="keyword">return</span>  a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="keyword">int</span>   t=<span class="number">5</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;f(t)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// a = 9</span></span><br><span class="line">    f(t)=<span class="number">20</span>;            <span class="comment">// a = 20</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f(t)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">// t = 5,a = 20  a = 25</span></span><br><span class="line">     t=f(t);               <span class="comment">// a = 30 t = 30</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f(t)&lt;&lt;<span class="built_in">endl</span>;      <span class="comment">//t = 60</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="13-重载（overload-和重写-overried，有的书也叫做“覆盖”）的区别？"><a href="#13-重载（overload-和重写-overried，有的书也叫做“覆盖”）的区别？" class="headerlink" title="13.重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？"></a>13.重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？</h2><p>常考的题目。从定义上来说：<br>重载：是指允许存在多个<strong>同名函数，而这些函数的参数表不同</strong>（或许参数个数不同，或许参数类型不同，或许两者都不同）。<br>重写：是指子类<strong>重新定义父类虚函数</strong>的方法。<br>从实现原理上来说：<br>重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！<br>重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。</p>
<hr>
<h2 id="14-有哪几种情况只能用intialization-list-而不能用assignment"><a href="#14-有哪几种情况只能用intialization-list-而不能用assignment" class="headerlink" title="14.有哪几种情况只能用intialization list 而不能用assignment?"></a>14.有哪几种情况只能用intialization list 而不能用assignment?</h2><p>答案：当类中含有const、reference 成员变量；基类的构造函数都需要初始化表。<br>//因为const对象和reference只能初始化而不能赋值，所以只能使用成员初始化列表。<br>//如果基类没有默认构造函数，则必须在初始化列表中显式地调用构造函数。</p>
<hr>
<h2 id="15-C-是不是类型安全的？"><a href="#15-C-是不是类型安全的？" class="headerlink" title="15. C++是不是类型安全的？"></a>15. C++是不是类型安全的？</h2><p>答案：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。</p>
<hr>
<h2 id="16-main-函数执行以前，还会执行什么代码？"><a href="#16-main-函数执行以前，还会执行什么代码？" class="headerlink" title="16. main 函数执行以前，还会执行什么代码？"></a>16. main 函数执行以前，还会执行什么代码？</h2><p>答案：<strong>全局对象的构造函数</strong>会在main 函数之前执行。</p>
<hr>
<h2 id="17-描述内存分配方式以及它们的区别"><a href="#17-描述内存分配方式以及它们的区别" class="headerlink" title="17. 描述内存分配方式以及它们的区别?"></a>17. 描述内存分配方式以及它们的区别?</h2><p>C++中，内存被分成五个部分：堆，栈，静态/全局 储存区，常量储存区和自由存储区<br>1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。<br>2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。<br>3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。</p>
<p>以下部分转自<a href="http://blog.csdn.net/sergeycao/article/details/3793671" target="_blank" rel="noopener">曹浩洋的专栏</a>.</p>
<ul>
<li>栈：编译器在需要的时候分配，不需要的时候释放掉。比如局部变量、函数参数等。</li>
<li>堆：由new分配的内存块，由程序员根据需要申请和释放，一般一个new对应一个delete，当为数组时，为 new[]对应 delete[].</li>
<li>自由储存区：由malloc分配的内存块，和堆十分相似，不过其以free结束。</li>
<li>静态储存区：全局变量和静态变量</li>
<li>常量存储区：特殊的内存块，存放常量，不允许修改。</li>
</ul>
<p>经常，堆和栈往往难以区分开，举例说明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>这条短短的一句话就包含了堆与栈，看到new，我们首先就应该想到，我们分配了一块堆内存，那么指针p呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中.
</code></pre><p>堆和栈的比较：</p>
<pre><code>1、管理方式不同； 
2、空间大小不同； 
3、能否产生碎片不同； 
4、生长方向不同； 
5、分配方式不同； 
6、分配效率不同； 
</code></pre><p>空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。</p>
<p>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因 为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。</p>
<p>生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。 </p>
<p>分 配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较 高。</p>
<p>对了，还有一件事，<strong>如果有人把堆栈合起来说，那它的意思是栈，可不是堆</strong></p>
<hr>
<h2 id="18-分别写出BOOL-int-float-指针类型的变量a-与“零”的比较语句。"><a href="#18-分别写出BOOL-int-float-指针类型的变量a-与“零”的比较语句。" class="headerlink" title="18.分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。"></a>18.分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。</h2><p>答案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL : if ( !a ) or if(a)</span><br><span class="line">int : if ( a == 0)</span><br><span class="line">float : const EXPRESSION EXP = 0.000001</span><br><span class="line">if ( a &lt; EXP &amp;&amp; a &gt;-EXP)</span><br><span class="line">pointer : if ( a != NULL) or if(a == NULL)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="19-请说出const与-define-相比，有何优点？"><a href="#19-请说出const与-define-相比，有何优点？" class="headerlink" title="19.请说出const与#define 相比，有何优点？"></a>19.请说出const与#define 相比，有何优点？</h2><p>详细参考<a href="http://blog.csdn.net/love_gaohz/article/details/7567856" target="_blank" rel="noopener">@奮 鬥@的专栏</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define PI 3.14159</span><br><span class="line">const float Pi 3.14159</span><br><span class="line">double i=Pi; //此时为Pi分配内存，以后不再分配！  </span><br><span class="line">double I=PI; //编译期间进行宏替换，分配内存  </span><br><span class="line">double j=Pi; //没有内存分配  </span><br><span class="line">double J=PI; //再进行宏替换，又一次分配内存！</span><br></pre></td></tr></table></figure>
<p>const 与 #define的比较<br>    C++ 语言可以用const来定义常量，也可以用 #define来定义常量。但是前者比后者有更多的优点：<br>（1）   const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行<strong>类型安全检查</strong>。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。<br>（2）   有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。</p>
<p>类中的常量<br>有时我们希望某些常量只在类中有效。由于#define定义的宏常量是全局的，不能达到目的，于是想当然地觉得应该用const修饰数据成员来实现。const数据成员的确是存在的，但其含义却不是我们所期望的。const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的，因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。<br>    不能在类声明中初始化const数据成员。以下用法是错误的，因为类的对象未被创建时，编译器不知道SIZE的值是什么。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    &#123;</span>…</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>; <span class="comment">// 错误，企图在类声明中初始化const数据成员</span></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">array</span>[SIZE];       <span class="comment">// 错误，未知的SIZE</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>数据成员的初始化只能在类构造函数的初始化表中进行，例如</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    &#123;</span>…</span><br><span class="line">        A(<span class="keyword">int</span> size);       <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> SIZE ;  </span><br><span class="line">    &#125;;</span><br><span class="line">    A::A(<span class="keyword">int</span> size) : SIZE(size) <span class="comment">// 构造函数的初始化表</span></span><br><span class="line">    &#123;</span><br><span class="line">      …</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">A  <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;  <span class="comment">// 对象 a 的SIZE值为100</span></span><br><span class="line">    <span class="function">A  <span class="title">b</span><span class="params">(<span class="number">200</span>)</span></span>;  <span class="comment">// 对象 b 的SIZE值为200</span></span><br></pre></td></tr></table></figure>
<p>答案：<br>const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。<br>1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。<br>2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。</p>
<hr>
<h2 id="20-简述数组与指针的区别？"><a href="#20-简述数组与指针的区别？" class="headerlink" title="20.简述数组与指针的区别？"></a>20.简述数组与指针的区别？</h2><p>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。<br>(1)修改内容上的差别<br>char a[] = “hello”;<br>a[0] = ‘X’;<br>char *p = “world”; // 注意p 指向常量字符串<br>p[0] = ‘X’; // 编译器不能发现该错误，运行时错误<br>(2) 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。</p>
<font color="green"><strong>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。</strong></font>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = a;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 12 字节</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节</span></span><br></pre></td></tr></table></figure>
<p>计算数组和指针的内存容量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">char</span> a[<span class="number">100</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4 字节而不是100 字节,数组作为函数的参数时，该数组自动退化为同类型的指针。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="21-int-s-10-int-表示的是什么？"><a href="#21-int-s-10-int-表示的是什么？" class="headerlink" title="21. int (*s[10])(int) 表示的是什么？"></a>21. int (*s[10])(int) 表示的是什么？</h2><p>int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。</p>
<hr>
<h2 id="22-栈内存与文字常量区"><a href="#22-栈内存与文字常量区" class="headerlink" title="22.栈内存与文字常量区"></a>22.栈内存与文字常量区</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str3[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str4[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str5 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str6 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> *str7 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> *str8 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ( str1 == str2 ) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0  分别指向各自的栈内存</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ( str3 == str4 ) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//0  分别指向各自的栈内存</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ( str5 == str6 ) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1指向文字常量区地址相同</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ( str7 == str8 ) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1指向文字常量区地址相同</span></span><br></pre></td></tr></table></figure>
<p>　　结果是：0 0 1 1<br>　　解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。</p>
<hr>
<h2 id="23-将程序跳转到指定内存地址"><a href="#23-将程序跳转到指定内存地址" class="headerlink" title="23.将程序跳转到指定内存地址"></a>23.将程序跳转到指定内存地址</h2><p>要对绝对地址0x100000赋值，我们可以用(unsigned int*)0x100000 = 1234;那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">　　*((<span class="keyword">void</span> (*)( ))<span class="number">0x100000</span> ) ( );</span><br><span class="line">　　首先要将<span class="number">0x100000</span>强制转换成函数指针,即:</span><br><span class="line">　　(<span class="keyword">void</span> (*)())<span class="number">0x100000</span></span><br><span class="line">　　然后再调用它:</span><br><span class="line">　　*((<span class="keyword">void</span> (*)())<span class="number">0x100000</span>)();</span><br><span class="line">　　用<span class="keyword">typedef</span>可以看得更直观些:</span><br><span class="line">　　<span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*)</span><span class="params">()</span> voidFuncPtr</span>;</span><br><span class="line">　　*((voidFuncPtr)<span class="number">0x100000</span>)();</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="24-int-id-sizeof-unsigned-long-这个对吗？为什么？"><a href="#24-int-id-sizeof-unsigned-long-这个对吗？为什么？" class="headerlink" title="24.int id[sizeof(unsigned long)];这个对吗？为什么？"></a>24.int id[sizeof(unsigned long)];这个对吗？为什么？</h2><p> 答案:正确 这个 sizeof是编译时运算符，编译时就确定了  ,可以看成和机器有关的常量。</p>
<hr>
<h2 id="25-引用与指针有什么区别？"><a href="#25-引用与指针有什么区别？" class="headerlink" title="25.引用与指针有什么区别？"></a>25.引用与指针有什么区别？</h2><p>【参考答案】            </p>
<ul>
<li><strong>引用必须被初始化，指针不必。</strong></li>
<li><strong>引用初始化以后不能被改变</strong>，指针可以改变所指的对象。</li>
<li><strong>不存在指向空值的引用，但是存在指向空值的指针。</strong></li>
</ul>
<hr>
<h2 id="26-const-与-define-的比较-，const有什么优点"><a href="#26-const-与-define-的比较-，const有什么优点" class="headerlink" title="26.const  与 #define 的比较 ，const有什么优点?"></a>26.const  与 #define 的比较 ，const有什么优点?</h2><p> 【参考答案】<br>（1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应） 。<br>（2）  有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。</p>
<hr>
<h2 id="27-复杂声明"><a href="#27-复杂声明" class="headerlink" title="27.复杂声明"></a>27.复杂声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * ( * (*fp1)(<span class="keyword">int</span>))[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">float</span> (*(* fp2)(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>))(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (* ( * fp3)())[<span class="number">10</span>]();</span><br></pre></td></tr></table></figure>
<p>分别表示什么意思？<br>【标准答案】<br>1.<code>void*(*(*fp1)(int))[10];</code>  fp1是一个指针，指向一个函数，这个函数的参数为int型，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个void<em>型指针。<br>2.`float(</em>(*fp2)(int,int,int))(int);`   fp2是一个指针，指向一个函数，这个函数的参数为3个int型，函数的返回值是一个指针，这个指针指向一个函数，这个函数的参数为int型，函数的返回值是float型。</p>
<p>3.<code>int (*(*fp3)())[10]();</code>   fp3是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是int型。</p>
<hr>
<h2 id="28-内存的分配方式有几种"><a href="#28-内存的分配方式有几种" class="headerlink" title="28.内存的分配方式有几种?"></a>28.内存的分配方式有几种?</h2><p>【参考答案】<br>一、从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。<br>二、在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。<br>三、从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</p>
<hr>
<h2 id="29-基类的析构函数不是虚函数，会带来什么问题？"><a href="#29-基类的析构函数不是虚函数，会带来什么问题？" class="headerlink" title="29.基类的析构函数不是虚函数，会带来什么问题？"></a>29.基类的析构函数不是虚函数，会带来什么问题？</h2><p>【参考答案】派生类的析构函数用不上，会造成资源的泄漏。</p>
<p>有如下例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClxBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ClxBase() &#123;&#125;;</span><br><span class="line">	<span class="keyword">virtual</span> ~ClxBase() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Output from the destructor of class ClxBase!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Do something in class ClxBase!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClxDerived</span> :</span> <span class="keyword">public</span> ClxBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ClxDerived() &#123;&#125;;</span><br><span class="line">	~ClxDerived() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Output from the destructor of class ClxDerived!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Do something in class ClxDerived!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ClxBase *pTest = <span class="keyword">new</span> ClxDerived;</span><br><span class="line">	pTest-&gt;DoSomething();</span><br><span class="line">	<span class="keyword">delete</span> pTest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时输出为：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Do something in class ClxDerived!</span></span><br><span class="line"><span class="comment">Output from the destructor of class ClxDerived!</span></span><br><span class="line"><span class="comment">Output from the destructor of class ClxBase!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>从上输出结果来看，<strong>调用子类的析构函数时，先调用子类的析构函数销毁掉子类的数据，然后再调用父类的析构函数销毁父类的数据。</strong></p>
<p>但是，如果-&gt;基类析构函数不为虚函数，去掉基类析构函数函数前的virtual关键字，如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClxBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ClxBase() &#123;&#125;;</span><br><span class="line">	~ClxBase() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Output from the destructor of class ClxBase!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Do something in class ClxBase!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//此时，输出为：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Do something in class ClxDerived!</span></span><br><span class="line"><span class="comment">Output from the destructor of class ClxBase!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>以上输出结果说明：<strong>如果基类的析构函数不为虚函数时，派生的子类型的析构函数被调用时，调用完毕之后不会再调用父类的析构函数，即父类中的数据并未被销毁。</strong></p>
<hr>
<h2 id="30-全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？"><a href="#30-全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？" class="headerlink" title="30.全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？"></a>30.全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？</h2><p>【参考答案】<br>生命周期不同：<br>全局变量随主程序创建和创建，随主程序销毁而销毁；<br>局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</p>
<p>使用方式不同：<br>通过声明后全局变量程序的各个部分都可以用到；<br>局部变量只能在局部使用；<br>操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。</p>
<p>+++++++++++++++++++<br>在内存中的存储位置不同：<br>全局变量：存储在静态存储区。<br>局部变量：存储在栈区。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/30/cpp-in-interview-30/" data-id="cjdfbgo4t0033a8jhuojgn1n3" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/05/30/cpp-programmer-interview/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          C++面试宝典备忘录
        
      </div>
    </a>
  
  
    <a href="/2016/05/30/answer-of-essential-cpp/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">Essential C++ 课后习题</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-面试/">C++面试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Gitcafe/">Gitcafe</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo博客搭建/">Hexo博客搭建</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Jekyll/">Jekyll</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Jekyll博客搭建/">Jekyll博客搭建</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Markdown/">Markdown</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Qt/">Qt</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shell/">Shell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/汇编/">汇编</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Beautiful-Soup/">Beautiful Soup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11/">C++11</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-小结/">C++小结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-S/">C/S</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CIDR/">CIDR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Essential-C/">Essential C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitcafe/">Gitcafe</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/">Github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IP/">IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jekyll/">Jekyll</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MarkdownPad/">MarkdownPad</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OSFP/">OSFP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qt/">Qt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RIP/">RIP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UDP/">UDP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Visual-Studio/">Visual Studio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/">Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cctype/">cctype</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/idndef/">idndef</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linggle/">linggle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pragma-once/">pragma once</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pragma-pack/">pragma pack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sizeof/">sizeof</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/string/">string</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/this指针/">this指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/virtual-function-table/">virtual function table</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/voltile/">voltile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windeployqt/">windeployqt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中缀表达式/">中缀表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二叉树/">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码规范/">代码规范</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位域/">位域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存对齐/">内存对齐</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存管理/">内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分页管理/">分页管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态绑定/">动态绑定</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/华为OJ/">华为OJ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后缀表达式/">后缀表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/子网/">子网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串常量/">字符串常量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小端模式/">小端模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/常用工具/">常用工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异常处理/">异常处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/指针/">指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/智能指针/">智能指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/构造函数/">构造函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/析构/">析构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/查找/">查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/段式内存管理/">段式内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/汇编/">汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/爬虫/">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/类/">类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/类型转换/">类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程语言/">编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网际协议/">网际协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/腾讯/">腾讯</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/虚函数/">虚函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/转义字符/">转义字符</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/链表/">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面向对象/">面向对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Beautiful-Soup/" style="font-size: 10px;">Beautiful Soup</a> <a href="/tags/C/" style="font-size: 18.57px;">C</a> <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/C-11/" style="font-size: 10px;">C++11</a> <a href="/tags/C-小结/" style="font-size: 11.43px;">C++小结</a> <a href="/tags/C-S/" style="font-size: 10px;">C/S</a> <a href="/tags/CIDR/" style="font-size: 10px;">CIDR</a> <a href="/tags/Essential-C/" style="font-size: 10px;">Essential C++</a> <a href="/tags/Git/" style="font-size: 14.29px;">Git</a> <a href="/tags/Gitcafe/" style="font-size: 10px;">Gitcafe</a> <a href="/tags/Github/" style="font-size: 14.29px;">Github</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 11.43px;">Hexo</a> <a href="/tags/IP/" style="font-size: 10px;">IP</a> <a href="/tags/Jekyll/" style="font-size: 12.86px;">Jekyll</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/MarkdownPad/" style="font-size: 10px;">MarkdownPad</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/OSFP/" style="font-size: 10px;">OSFP</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Qt/" style="font-size: 11.43px;">Qt</a> <a href="/tags/RIP/" style="font-size: 10px;">RIP</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/TCP-IP/" style="font-size: 10px;">TCP/IP</a> <a href="/tags/UDP/" style="font-size: 10px;">UDP</a> <a href="/tags/Visual-Studio/" style="font-size: 10px;">Visual Studio</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a> <a href="/tags/cctype/" style="font-size: 10px;">cctype</a> <a href="/tags/idndef/" style="font-size: 10px;">idndef</a> <a href="/tags/linggle/" style="font-size: 10px;">linggle</a> <a href="/tags/pragma-once/" style="font-size: 10px;">pragma once</a> <a href="/tags/pragma-pack/" style="font-size: 10px;">pragma pack</a> <a href="/tags/python/" style="font-size: 14.29px;">python</a> <a href="/tags/sizeof/" style="font-size: 10px;">sizeof</a> <a href="/tags/string/" style="font-size: 10px;">string</a> <a href="/tags/this指针/" style="font-size: 10px;">this指针</a> <a href="/tags/virtual-function-table/" style="font-size: 10px;">virtual function table</a> <a href="/tags/voltile/" style="font-size: 10px;">voltile</a> <a href="/tags/windeployqt/" style="font-size: 10px;">windeployqt</a> <a href="/tags/中缀表达式/" style="font-size: 11.43px;">中缀表达式</a> <a href="/tags/二叉树/" style="font-size: 10px;">二叉树</a> <a href="/tags/代码规范/" style="font-size: 10px;">代码规范</a> <a href="/tags/位域/" style="font-size: 10px;">位域</a> <a href="/tags/内存对齐/" style="font-size: 10px;">内存对齐</a> <a href="/tags/内存管理/" style="font-size: 10px;">内存管理</a> <a href="/tags/分页管理/" style="font-size: 10px;">分页管理</a> <a href="/tags/动态绑定/" style="font-size: 10px;">动态绑定</a> <a href="/tags/华为OJ/" style="font-size: 14.29px;">华为OJ</a> <a href="/tags/后缀表达式/" style="font-size: 10px;">后缀表达式</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/子网/" style="font-size: 10px;">子网</a> <a href="/tags/字符串常量/" style="font-size: 10px;">字符串常量</a> <a href="/tags/小端模式/" style="font-size: 10px;">小端模式</a> <a href="/tags/常用工具/" style="font-size: 10px;">常用工具</a> <a href="/tags/异常处理/" style="font-size: 10px;">异常处理</a> <a href="/tags/指针/" style="font-size: 10px;">指针</a> <a href="/tags/操作系统/" style="font-size: 17.14px;">操作系统</a> <a href="/tags/数据结构/" style="font-size: 11.43px;">数据结构</a> <a href="/tags/智能指针/" style="font-size: 10px;">智能指针</a> <a href="/tags/构造函数/" style="font-size: 10px;">构造函数</a> <a href="/tags/析构/" style="font-size: 10px;">析构</a> <a href="/tags/查找/" style="font-size: 10px;">查找</a> <a href="/tags/段式内存管理/" style="font-size: 10px;">段式内存管理</a> <a href="/tags/汇编/" style="font-size: 10px;">汇编</a> <a href="/tags/爬虫/" style="font-size: 11.43px;">爬虫</a> <a href="/tags/算法/" style="font-size: 12.86px;">算法</a> <a href="/tags/类/" style="font-size: 10px;">类</a> <a href="/tags/类型转换/" style="font-size: 15.71px;">类型转换</a> <a href="/tags/编程语言/" style="font-size: 11.43px;">编程语言</a> <a href="/tags/网际协议/" style="font-size: 10px;">网际协议</a> <a href="/tags/腾讯/" style="font-size: 10px;">腾讯</a> <a href="/tags/虚函数/" style="font-size: 10px;">虚函数</a> <a href="/tags/计算机网络/" style="font-size: 10px;">计算机网络</a> <a href="/tags/转义字符/" style="font-size: 10px;">转义字符</a> <a href="/tags/链表/" style="font-size: 10px;">链表</a> <a href="/tags/面向对象/" style="font-size: 10px;">面向对象</a> <a href="/tags/面试/" style="font-size: 11.43px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/09/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/11/03/python-learning/">Python学习</a>
          </li>
        
          <li>
            <a href="/2016/10/25/Python-sequence/">Python-列表和元组</a>
          </li>
        
          <li>
            <a href="/2016/10/15/python-spider-00/">python爬虫实战</a>
          </li>
        
          <li>
            <a href="/2016/10/14/Beautiful-soup/">Beautiful Soup常用语法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>